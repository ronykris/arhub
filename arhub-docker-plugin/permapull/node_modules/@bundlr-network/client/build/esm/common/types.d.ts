/// <reference types="node" />
import type BigNumber from "bignumber.js";
import type { DataItem, Signer, createData, deepHash, getCryptoDriver, stringToBuffer, DataItemCreateOptions } from "arbundles";
import type { FileDataItem } from "arbundles/file";
import type Bundlr from "./bundlr.js";
export interface CreateTxData {
    amount: BigNumber.Value;
    to: string;
    fee?: string;
}
export interface Arbundles {
    createData: typeof createData;
    DataItem: typeof DataItem;
    deepHash: typeof deepHash;
    stringToBuffer: typeof stringToBuffer;
    getCryptoDriver: typeof getCryptoDriver;
}
export interface BundlrTransaction extends DataItem {
    sign: () => Promise<Buffer>;
    size: number;
    uploadWithReceipt: (opts?: UploadOptions) => Promise<UploadReceipt>;
    upload(opts: UploadOptions & {
        getReceiptSignature: true;
    }): Promise<UploadReceipt>;
    upload(opts?: UploadOptions): Promise<UploadResponse>;
}
export type BundlrTransactonCtor = new (data: string | Uint8Array, bundlr: Bundlr, opts?: BundlrTransactionCreateOptions) => BundlrTransaction;
export interface Tx {
    from: string;
    to: string;
    amount: BigNumber;
    blockHeight?: BigNumber;
    pending: boolean;
    confirmed: boolean;
}
export interface CurrencyConfig {
    bundlr: Bundlr;
    name: string;
    ticker: string;
    minConfirm?: number;
    wallet?: string | object;
    providerUrl: string;
    isSlow?: boolean;
    opts?: any;
}
export interface BundlrConfig {
    timeout?: number;
    providerUrl?: string;
    contractAddress?: string;
    currencyOpts?: object;
    headers?: Record<string, string>;
}
export interface Currency {
    isSlow: boolean;
    needsFee: boolean;
    base: [string, number];
    name: string;
    get address(): string | undefined;
    ticker: string;
    bundlr: Bundlr;
    getTx(txId: string): Promise<Tx>;
    ownerToAddress(owner: any): string;
    getId(item: FileDataItem): Promise<string>;
    price(): Promise<number>;
    sign(data: Uint8Array): Promise<Uint8Array>;
    getSigner(): Signer;
    verify(pub: any, data: Uint8Array, signature: Uint8Array): Promise<boolean>;
    getCurrentHeight(): Promise<BigNumber>;
    getFee(amount: BigNumber.Value, to?: string): Promise<BigNumber | object>;
    sendTx(data: any): Promise<string | undefined>;
    createTx(amount: BigNumber.Value, to: string, fee?: string | object): Promise<{
        txId: string | undefined;
        tx: any;
    }>;
    getPublicKey(): Promise<string | Buffer> | (string | Buffer);
    ready?(): Promise<void>;
}
export interface Manifest {
    manifest: string;
    version: string;
    paths: Record<string, Record<string, Record<"id", string>>>;
    index?: Record<"path", string>;
}
export interface UploadResponse {
    id: string;
    /**
     * All below (bar timestamp) are optional (requiring the getReceiptSignature option)
     */
    public?: string;
    signature?: string;
    deadlineHeight?: number;
    validatorSignatures?: {
        address: string;
        signature: string;
    }[];
    timestamp?: number;
    version?: "1.0.0";
    verify?: () => Promise<boolean>;
}
export type UploadReceipt = Required<UploadResponse>;
export type UploadReceiptData = Omit<UploadReceipt, "verify">;
export interface FundResponse {
    reward: string;
    target: string;
    quantity: string;
    id: string;
}
export interface WithdrawalResponse {
    tx_id: string;
    requested: number;
    fee: number;
    final: number;
}
export type CreateAndUploadOptions = DataItemCreateOptions & {
    upload?: UploadOptions;
};
export interface UploadOptions {
    getReceiptSignature?: boolean;
}
export type BundlrTransactionCreateOptions = DataItemCreateOptions & {
    dataIsRawTransaction?: boolean;
};
