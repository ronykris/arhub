"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jwkTopem = exports.verifySignature = void 0;
/**
 * @see https://github.com/ArweaveTeam/arweave-js/blob/0e9a8eeca5edc449360c25dee257dd89b15c7dc2/src/common/lib/crypto/node-driver.ts#L61
 * Utilities to verify signature generated by private key via public key
 */
const asn = __importStar(require("asn1.js"));
const crypto_1 = require("crypto");
function verifySignature(publicModulus, data, signature) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, _) => {
            const publicKey = {
                kty: 'RSA',
                e: 'AQAB',
                n: publicModulus,
            };
            const pem = jwkTopem(publicKey);
            resolve((0, crypto_1.createVerify)('sha256').update(data).verify({
                key: pem,
                padding: crypto_1.constants.RSA_PKCS1_PSS_PADDING,
            }, signature));
        });
    });
}
exports.verifySignature = verifySignature;
function base64url2bn(str) {
    return new asn.bignum(Buffer.from(str, 'base64'));
}
function string2bn(str) {
    if (/^[0-9]+$/.test(str)) {
        return new asn.bignum(str, 10);
    }
    return base64url2bn(str);
}
function parse(jwk) {
    return {
        n: string2bn(jwk.n),
        e: string2bn(jwk.e),
        d: jwk.d && string2bn(jwk.d),
        p: jwk.p && string2bn(jwk.p),
        q: jwk.q && string2bn(jwk.q),
        dp: jwk.dp && string2bn(jwk.dp),
        dq: jwk.dq && string2bn(jwk.dq),
        qi: jwk.qi && string2bn(jwk.qi),
    };
}
const Version = asn.define('Version', function () {
    this.int({
        0: 'two-prime',
        1: 'multi',
    });
});
const OtherPrimeInfos = asn.define('OtherPrimeInfos', function () {
    this.seq().obj(this.key('ri').int(), this.key('di').int(), this.key('ti').int());
});
const RSAPrivateKey = asn.define('RSAPrivateKey', function () {
    this.seq().obj(this.key('version').use(Version), this.key('n').int(), this.key('e').int(), this.key('d').int(), this.key('p').int(), this.key('q').int(), this.key('dp').int(), this.key('dq').int(), this.key('qi').int(), this.key('other').optional().use(OtherPrimeInfos));
});
const RSAPublicKey = asn.define('RSAPublicKey', function () {
    this.seq().obj(this.key('n').int(), this.key('e').int());
});
function jwkTopem(json) {
    const jwk = parse(json);
    const isPrivate = !!jwk.d;
    const t = isPrivate ? 'PRIVATE' : 'PUBLIC';
    const header = '-----BEGIN RSA ' + t + ' KEY-----\n';
    const footer = '\n-----END RSA ' + t + ' KEY-----\n';
    let data = Buffer.alloc(0);
    if (isPrivate) {
        jwk.version = 'two-prime';
        data = RSAPrivateKey.encode(jwk, 'der');
    }
    else {
        data = RSAPublicKey.encode(jwk, 'der');
    }
    const body = data
        .toString('base64')
        .match(/.{1,64}/g)
        .join('\n');
    return header + body + footer;
}
exports.jwkTopem = jwkTopem;
//# sourceMappingURL=key.js.map