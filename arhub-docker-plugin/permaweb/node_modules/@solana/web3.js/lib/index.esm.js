import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import { Buffer } from 'buffer';
import { ed25519 } from '@noble/curves/ed25519';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import BN from 'bn.js';
import bs58 from 'bs58';
import { sha256 } from '@noble/hashes/sha256';
import { serialize, deserialize, deserializeUnchecked } from 'borsh';
import * as BufferLayout from '@solana/buffer-layout';
import { blob } from '@solana/buffer-layout';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { toBigIntLE, toBufferLE } from 'bigint-buffer';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _typeof from '@babel/runtime/helpers/typeof';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import require$$0$1 from 'tty';
import require$$0 from 'util';
import require$$0$2 from 'path';
import require$$0$3 from 'http';
import require$$0$4, { Agent as Agent$1 } from 'https';
import { coerce, instance, string, tuple, literal, unknown, type, number, array, nullable, optional, boolean, record, union, create, any, assert as assert$1 } from 'superstruct';
import RpcClient from 'jayson/lib/client/browser';
import _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';
import * as nodeFetch from 'node-fetch';
import _get from '@babel/runtime/helpers/get';
import RpcWebSocketCommonClient from 'rpc-websockets/dist/lib/client';
import WebsocketFactory from 'rpc-websockets/dist/lib/client/websocket';
import { keccak_256 } from '@noble/hashes/sha3';
import { secp256k1 } from '@noble/curves/secp256k1';

/**
 * A 64 byte secret key, the first 32 bytes of which is the
 * private scalar and the last 32 bytes is the public key.
 * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
 */

/**
 * Ed25519 Keypair
 */

var generatePrivateKey = ed25519.utils.randomPrivateKey;
var generateKeypair = function generateKeypair() {
  var privateScalar = ed25519.utils.randomPrivateKey();
  var publicKey = getPublicKey(privateScalar);
  var secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey: publicKey,
    secretKey: secretKey
  };
};
var getPublicKey = ed25519.getPublicKey;
function isOnCurve(publicKey) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey);
    return true;
  } catch (_unused) {
    return false;
  }
}
var sign = function sign(message, secretKey) {
  return ed25519.sign(message, secretKey.slice(0, 32));
};
var verify = ed25519.verify;

var toBuffer = function toBuffer(arr) {
  if (Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return Buffer.from(arr);
  }
};

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Class wrapping a plain object
var Struct = /*#__PURE__*/function () {
  function Struct(properties) {
    _classCallCheck(this, Struct);
    Object.assign(this, properties);
  }
  _createClass(Struct, [{
    key: "encode",
    value: function encode() {
      return Buffer.from(serialize(SOLANA_SCHEMA, this));
    }
  }], [{
    key: "decode",
    value: function decode(data) {
      return deserialize(SOLANA_SCHEMA, this, data);
    }
  }, {
    key: "decodeUnchecked",
    value: function decodeUnchecked(data) {
      return deserializeUnchecked(SOLANA_SCHEMA, this, data);
    }
  }]);
  return Struct;
}();

// Class representing a Rust-compatible enum, since enums are only strings or
// numbers in pure JS
var Enum = /*#__PURE__*/function (_Struct) {
  _inherits(Enum, _Struct);
  var _super = _createSuper$4(Enum);
  function Enum(properties) {
    var _this;
    _classCallCheck(this, Enum);
    _this = _super.call(this, properties);
    _this["enum"] = '';
    if (Object.keys(properties).length !== 1) {
      throw new Error('Enum can only take single value');
    }
    Object.keys(properties).map(function (key) {
      _this["enum"] = key;
    });
    return _this;
  }
  return _createClass(Enum);
}(Struct);
var SOLANA_SCHEMA = new Map();

var _Symbol$toStringTag;
function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Maximum length of derived pubkey seed
 */
var MAX_SEED_LENGTH = 32;

/**
 * Size of public key in bytes
 */
var PUBLIC_KEY_LENGTH = 32;

/**
 * Value to be converted into public key
 */

/**
 * JSON object representation of PublicKey class
 */

function isPublicKeyData(value) {
  return value._bn !== undefined;
}

// local counter used by PublicKey.unique()
var uniquePublicKeyCounter = 1;

/**
 * A public key
 */
_Symbol$toStringTag = Symbol.toStringTag;
var PublicKey = /*#__PURE__*/function (_Struct) {
  _inherits(PublicKey, _Struct);
  var _super = _createSuper$3(PublicKey);
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  function PublicKey(value) {
    var _this;
    _classCallCheck(this, PublicKey);
    _this = _super.call(this, {});
    /** @internal */
    _this._bn = void 0;
    if (isPublicKeyData(value)) {
      _this._bn = value._bn;
    } else {
      if (typeof value === 'string') {
        // assume base 58 encoding by default
        var decoded = bs58.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error("Invalid public key input");
        }
        _this._bn = new BN(decoded);
      } else {
        _this._bn = new BN(value);
      }
      if (_this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error("Invalid public key input");
      }
    }
    return _this;
  }

  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  _createClass(PublicKey, [{
    key: "equals",
    value:
    /**
     * Checks if two publicKeys are equal
     */
    function equals(publicKey) {
      return this._bn.eq(publicKey._bn);
    }

    /**
     * Return the base-58 representation of the public key
     */
  }, {
    key: "toBase58",
    value: function toBase58() {
      return bs58.encode(this.toBytes());
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toBase58();
    }

    /**
     * Return the byte array representation of the public key in big endian
     */
  }, {
    key: "toBytes",
    value: function toBytes() {
      var buf = this.toBuffer();
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }

    /**
     * Return the Buffer representation of the public key in big endian
     */
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      var b = this._bn.toArrayLike(Buffer);
      if (b.length === PUBLIC_KEY_LENGTH) {
        return b;
      }
      var zeroPad = Buffer.alloc(32);
      b.copy(zeroPad, 32 - b.length);
      return zeroPad;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "PublicKey(".concat(this.toString(), ")");
    }

    /**
     * Return the base-58 representation of the public key
     */
  }, {
    key: "toString",
    value: function toString() {
      return this.toBase58();
    }

    /**
     * Derive a public key from another key, a seed, and a program ID.
     * The program ID will also serve as the owner of the public key, giving
     * it permission to write data to the account.
     */
    /* eslint-disable require-await */
  }], [{
    key: "unique",
    value: function unique() {
      var key = new PublicKey(uniquePublicKeyCounter);
      uniquePublicKeyCounter += 1;
      return new PublicKey(key.toBuffer());
    }

    /**
     * Default public key value. The base58-encoded string representation is all ones (as seen below)
     * The underlying BN number is 32 bytes that are all zeros
     */
  }, {
    key: "createWithSeed",
    value: function () {
      var _createWithSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fromPublicKey, seed, programId) {
        var buffer, publicKeyBytes;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);
              publicKeyBytes = sha256(buffer);
              return _context.abrupt("return", new PublicKey(publicKeyBytes));
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function createWithSeed(_x, _x2, _x3) {
        return _createWithSeed.apply(this, arguments);
      }
      return createWithSeed;
    }()
    /**
     * Derive a program address from seeds and a program ID.
     */
    /* eslint-disable require-await */
  }, {
    key: "createProgramAddressSync",
    value: function createProgramAddressSync(seeds, programId) {
      var buffer = Buffer.alloc(0);
      seeds.forEach(function (seed) {
        if (seed.length > MAX_SEED_LENGTH) {
          throw new TypeError("Max seed length exceeded");
        }
        buffer = Buffer.concat([buffer, toBuffer(seed)]);
      });
      buffer = Buffer.concat([buffer, programId.toBuffer(), Buffer.from('ProgramDerivedAddress')]);
      var publicKeyBytes = sha256(buffer);
      if (isOnCurve(publicKeyBytes)) {
        throw new Error("Invalid seeds, address must fall off the curve");
      }
      return new PublicKey(publicKeyBytes);
    }

    /**
     * Async version of createProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link createProgramAddressSync} instead
     */
    /* eslint-disable require-await */
  }, {
    key: "createProgramAddress",
    value: function () {
      var _createProgramAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(seeds, programId) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.createProgramAddressSync(seeds, programId));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function createProgramAddress(_x4, _x5) {
        return _createProgramAddress.apply(this, arguments);
      }
      return createProgramAddress;
    }()
    /**
     * Find a valid program address
     *
     * Valid program addresses must fall off the ed25519 curve.  This function
     * iterates a nonce until it finds one that when combined with the seeds
     * results in a valid program address.
     */
  }, {
    key: "findProgramAddressSync",
    value: function findProgramAddressSync(seeds, programId) {
      var nonce = 255;
      var address;
      while (nonce != 0) {
        try {
          var seedsWithNonce = seeds.concat(Buffer.from([nonce]));
          address = this.createProgramAddressSync(seedsWithNonce, programId);
        } catch (err) {
          if (err instanceof TypeError) {
            throw err;
          }
          nonce--;
          continue;
        }
        return [address, nonce];
      }
      throw new Error("Unable to find a viable program address nonce");
    }

    /**
     * Async version of findProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link findProgramAddressSync} instead
     */
  }, {
    key: "findProgramAddress",
    value: function () {
      var _findProgramAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(seeds, programId) {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.findProgramAddressSync(seeds, programId));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function findProgramAddress(_x6, _x7) {
        return _findProgramAddress.apply(this, arguments);
      }
      return findProgramAddress;
    }()
    /**
     * Check that a pubkey is on the ed25519 curve.
     */
  }, {
    key: "isOnCurve",
    value: function isOnCurve$1(pubkeyData) {
      var pubkey = new PublicKey(pubkeyData);
      return isOnCurve(pubkey.toBytes());
    }
  }]);
  return PublicKey;
}(Struct);
PublicKey["default"] = new PublicKey('11111111111111111111111111111111');
SOLANA_SCHEMA.set(PublicKey, {
  kind: 'struct',
  fields: [['_bn', 'u256']]
});

/**
 * An account key pair (public and secret keys).
 *
 * @deprecated since v1.10.0, please use {@link Keypair} instead.
 */
var Account = /*#__PURE__*/function () {
  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */
  function Account(secretKey) {
    _classCallCheck(this, Account);
    /** @internal */
    this._publicKey = void 0;
    /** @internal */
    this._secretKey = void 0;
    if (secretKey) {
      var secretKeyBuffer = toBuffer(secretKey);
      if (secretKey.length !== 64) {
        throw new Error('bad secret key size');
      }
      this._publicKey = secretKeyBuffer.slice(32, 64);
      this._secretKey = secretKeyBuffer.slice(0, 32);
    } else {
      this._secretKey = toBuffer(generatePrivateKey());
      this._publicKey = toBuffer(getPublicKey(this._secretKey));
    }
  }

  /**
   * The public key for this account
   */
  _createClass(Account, [{
    key: "publicKey",
    get: function get() {
      return new PublicKey(this._publicKey);
    }

    /**
     * The **unencrypted** secret key for this account. The first 32 bytes
     * is the private scalar and the last 32 bytes is the public key.
     * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
     */
  }, {
    key: "secretKey",
    get: function get() {
      return Buffer.concat([this._secretKey, this._publicKey], 64);
    }
  }]);
  return Account;
}();

var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');

/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 0x7f;
var SIGNATURE_LENGTH_IN_BYTES = 64;

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var TransactionExpiredBlockheightExceededError = /*#__PURE__*/function (_Error) {
  _inherits(TransactionExpiredBlockheightExceededError, _Error);
  var _super = _createSuper$2(TransactionExpiredBlockheightExceededError);
  function TransactionExpiredBlockheightExceededError(signature) {
    var _this;
    _classCallCheck(this, TransactionExpiredBlockheightExceededError);
    _this = _super.call(this, "Signature ".concat(signature, " has expired: block height exceeded."));
    _this.signature = void 0;
    _this.signature = signature;
    return _this;
  }
  return _createClass(TransactionExpiredBlockheightExceededError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError'
});
var TransactionExpiredTimeoutError = /*#__PURE__*/function (_Error2) {
  _inherits(TransactionExpiredTimeoutError, _Error2);
  var _super2 = _createSuper$2(TransactionExpiredTimeoutError);
  function TransactionExpiredTimeoutError(signature, timeoutSeconds) {
    var _this2;
    _classCallCheck(this, TransactionExpiredTimeoutError);
    _this2 = _super2.call(this, "Transaction was not confirmed in ".concat(timeoutSeconds.toFixed(2), " seconds. It is ") + 'unknown if it succeeded or failed. Check signature ' + "".concat(signature, " using the Solana Explorer or CLI tools."));
    _this2.signature = void 0;
    _this2.signature = signature;
    return _this2;
  }
  return _createClass(TransactionExpiredTimeoutError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
Object.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {
  value: 'TransactionExpiredTimeoutError'
});
var TransactionExpiredNonceInvalidError = /*#__PURE__*/function (_Error3) {
  _inherits(TransactionExpiredNonceInvalidError, _Error3);
  var _super3 = _createSuper$2(TransactionExpiredNonceInvalidError);
  function TransactionExpiredNonceInvalidError(signature) {
    var _this3;
    _classCallCheck(this, TransactionExpiredNonceInvalidError);
    _this3 = _super3.call(this, "Signature ".concat(signature, " has expired: the nonce is no longer valid."));
    _this3.signature = void 0;
    _this3.signature = signature;
    return _this3;
  }
  return _createClass(TransactionExpiredNonceInvalidError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {
  value: 'TransactionExpiredNonceInvalidError'
});

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }
function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var MessageAccountKeys = /*#__PURE__*/function () {
  function MessageAccountKeys(staticAccountKeys, accountKeysFromLookups) {
    _classCallCheck(this, MessageAccountKeys);
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  _createClass(MessageAccountKeys, [{
    key: "keySegments",
    value: function keySegments() {
      var keySegments = [this.staticAccountKeys];
      if (this.accountKeysFromLookups) {
        keySegments.push(this.accountKeysFromLookups.writable);
        keySegments.push(this.accountKeysFromLookups.readonly);
      }
      return keySegments;
    }
  }, {
    key: "get",
    value: function get(index) {
      var _iterator = _createForOfIteratorHelper$5(this.keySegments()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var keySegment = _step.value;
          if (index < keySegment.length) {
            return keySegment[index];
          } else {
            index -= keySegment.length;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return;
    }
  }, {
    key: "length",
    get: function get() {
      return this.keySegments().flat().length;
    }
  }, {
    key: "compileInstructions",
    value: function compileInstructions(instructions) {
      // Bail early if any account indexes would overflow a u8
      var U8_MAX = 255;
      if (this.length > U8_MAX + 1) {
        throw new Error('Account index overflow encountered during compilation');
      }
      var keyIndexMap = new Map();
      this.keySegments().flat().forEach(function (key, index) {
        keyIndexMap.set(key.toBase58(), index);
      });
      var findKeyIndex = function findKeyIndex(key) {
        var keyIndex = keyIndexMap.get(key.toBase58());
        if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');
        return keyIndex;
      };
      return instructions.map(function (instruction) {
        return {
          programIdIndex: findKeyIndex(instruction.programId),
          accountKeyIndexes: instruction.keys.map(function (meta) {
            return findKeyIndex(meta.pubkey);
          }),
          data: instruction.data
        };
      });
    }
  }]);
  return MessageAccountKeys;
}();

/**
 * Layout for a public key
 */
var publicKey = function publicKey() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';
  return BufferLayout.blob(32, property);
};

/**
 * Layout for a signature
 */
var signature = function signature() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'signature';
  return BufferLayout.blob(64, property);
};
/**
 * Layout for a Rust String type
 */
var rustString = function rustString() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'string';
  var rsl = BufferLayout.struct([BufferLayout.u32('length'), BufferLayout.u32('lengthPadding'), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars')], property);
  var _decode = rsl.decode.bind(rsl);
  var _encode = rsl.encode.bind(rsl);
  var rslShim = rsl;
  rslShim.decode = function (b, offset) {
    var data = _decode(b, offset);
    return data['chars'].toString();
  };
  rslShim.encode = function (str, b, offset) {
    var data = {
      chars: Buffer.from(str, 'utf8')
    };
    return _encode(data, b, offset);
  };
  rslShim.alloc = function (str) {
    return BufferLayout.u32().span + BufferLayout.u32().span + Buffer.from(str, 'utf8').length;
  };
  return rslShim;
};

/**
 * Layout for an Authorized object
 */
var authorized = function authorized() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'authorized';
  return BufferLayout.struct([publicKey('staker'), publicKey('withdrawer')], property);
};

/**
 * Layout for a Lockup object
 */
var lockup = function lockup() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lockup';
  return BufferLayout.struct([BufferLayout.ns64('unixTimestamp'), BufferLayout.ns64('epoch'), publicKey('custodian')], property);
};

/**
 *  Layout for a VoteInit object
 */
var voteInit = function voteInit() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteInit';
  return BufferLayout.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), BufferLayout.u8('commission')], property);
};

/**
 *  Layout for a VoteAuthorizeWithSeedArgs object
 */
var voteAuthorizeWithSeedArgs = function voteAuthorizeWithSeedArgs() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteAuthorizeWithSeedArgs';
  return BufferLayout.struct([BufferLayout.u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);
};
function getAlloc(type, fields) {
  var getItemAlloc = function getItemAlloc(item) {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === 'function') {
      return item.alloc(fields[item.property]);
    } else if ('count' in item && 'elementLayout' in item) {
      var field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ('fields' in item) {
      // This is a `Structure` whose size needs to be recursively measured.
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    // Couldn't determine allocated size of layout
    return 0;
  };
  var alloc = 0;
  type.layout.fields.forEach(function (item) {
    alloc += getItemAlloc(item);
  });
  return alloc;
}

function decodeLength(bytes) {
  var len = 0;
  var size = 0;
  for (;;) {
    var elem = bytes.shift();
    len |= (elem & 0x7f) << size * 7;
    size += 1;
    if ((elem & 0x80) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes, len) {
  var rem_len = len;
  for (;;) {
    var elem = rem_len & 0x7f;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 0x80;
      bytes.push(elem);
    }
  }
}

function assert (condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }
function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var CompiledKeys = /*#__PURE__*/function () {
  function CompiledKeys(payer, keyMetaMap) {
    _classCallCheck(this, CompiledKeys);
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  _createClass(CompiledKeys, [{
    key: "getMessageComponents",
    value: function getMessageComponents() {
      var mapEntries = _toConsumableArray(this.keyMetaMap.entries());
      assert(mapEntries.length <= 256, 'Max static account keys length exceeded');
      var writableSigners = mapEntries.filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          meta = _ref2[1];
        return meta.isSigner && meta.isWritable;
      });
      var readonlySigners = mapEntries.filter(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          meta = _ref4[1];
        return meta.isSigner && !meta.isWritable;
      });
      var writableNonSigners = mapEntries.filter(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
          meta = _ref6[1];
        return !meta.isSigner && meta.isWritable;
      });
      var readonlyNonSigners = mapEntries.filter(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
          meta = _ref8[1];
        return !meta.isSigner && !meta.isWritable;
      });
      var header = {
        numRequiredSignatures: writableSigners.length + readonlySigners.length,
        numReadonlySignedAccounts: readonlySigners.length,
        numReadonlyUnsignedAccounts: readonlyNonSigners.length
      };

      // sanity checks
      {
        assert(writableSigners.length > 0, 'Expected at least one writable signer key');
        var _writableSigners$ = _slicedToArray(writableSigners[0], 1),
          payerAddress = _writableSigners$[0];
        assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
      }
      var staticAccountKeys = [].concat(_toConsumableArray(writableSigners.map(function (_ref9) {
        var _ref10 = _slicedToArray(_ref9, 1),
          address = _ref10[0];
        return new PublicKey(address);
      })), _toConsumableArray(readonlySigners.map(function (_ref11) {
        var _ref12 = _slicedToArray(_ref11, 1),
          address = _ref12[0];
        return new PublicKey(address);
      })), _toConsumableArray(writableNonSigners.map(function (_ref13) {
        var _ref14 = _slicedToArray(_ref13, 1),
          address = _ref14[0];
        return new PublicKey(address);
      })), _toConsumableArray(readonlyNonSigners.map(function (_ref15) {
        var _ref16 = _slicedToArray(_ref15, 1),
          address = _ref16[0];
        return new PublicKey(address);
      })));
      return [header, staticAccountKeys];
    }
  }, {
    key: "extractTableLookup",
    value: function extractTableLookup(lookupTable) {
      var _this$drainKeysFoundI = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {
          return !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable;
        }),
        _this$drainKeysFoundI2 = _slicedToArray(_this$drainKeysFoundI, 2),
        writableIndexes = _this$drainKeysFoundI2[0],
        drainedWritableKeys = _this$drainKeysFoundI2[1];
      var _this$drainKeysFoundI3 = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {
          return !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable;
        }),
        _this$drainKeysFoundI4 = _slicedToArray(_this$drainKeysFoundI3, 2),
        readonlyIndexes = _this$drainKeysFoundI4[0],
        drainedReadonlyKeys = _this$drainKeysFoundI4[1];

      // Don't extract lookup if no keys were found
      if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
        return;
      }
      return [{
        accountKey: lookupTable.key,
        writableIndexes: writableIndexes,
        readonlyIndexes: readonlyIndexes
      }, {
        writable: drainedWritableKeys,
        readonly: drainedReadonlyKeys
      }];
    }

    /** @internal */
  }, {
    key: "drainKeysFoundInLookupTable",
    value: function drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
      var _this = this;
      var lookupTableIndexes = new Array();
      var drainedKeys = new Array();
      var _iterator = _createForOfIteratorHelper$4(this.keyMetaMap.entries()),
        _step;
      try {
        var _loop = function _loop() {
          var _step$value = _slicedToArray(_step.value, 2),
            address = _step$value[0],
            keyMeta = _step$value[1];
          if (keyMetaFilter(keyMeta)) {
            var key = new PublicKey(address);
            var lookupTableIndex = lookupTableEntries.findIndex(function (entry) {
              return entry.equals(key);
            });
            if (lookupTableIndex >= 0) {
              assert(lookupTableIndex < 256, 'Max lookup table index exceeded');
              lookupTableIndexes.push(lookupTableIndex);
              drainedKeys.push(key);
              _this.keyMetaMap["delete"](address);
            }
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return [lookupTableIndexes, drainedKeys];
    }
  }], [{
    key: "compile",
    value: function compile(instructions, payer) {
      var keyMetaMap = new Map();
      var getOrInsertDefault = function getOrInsertDefault(pubkey) {
        var address = pubkey.toBase58();
        var keyMeta = keyMetaMap.get(address);
        if (keyMeta === undefined) {
          keyMeta = {
            isSigner: false,
            isWritable: false,
            isInvoked: false
          };
          keyMetaMap.set(address, keyMeta);
        }
        return keyMeta;
      };
      var payerKeyMeta = getOrInsertDefault(payer);
      payerKeyMeta.isSigner = true;
      payerKeyMeta.isWritable = true;
      var _iterator2 = _createForOfIteratorHelper$4(instructions),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ix = _step2.value;
          getOrInsertDefault(ix.programId).isInvoked = true;
          var _iterator3 = _createForOfIteratorHelper$4(ix.keys),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var accountMeta = _step3.value;
              var _keyMeta = getOrInsertDefault(accountMeta.pubkey);
              _keyMeta.isSigner || (_keyMeta.isSigner = accountMeta.isSigner);
              _keyMeta.isWritable || (_keyMeta.isWritable = accountMeta.isWritable);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return new CompiledKeys(payer, keyMetaMap);
    }
  }]);
  return CompiledKeys;
}();

/**
 * An instruction to execute by a program
 *
 * @property {number} programIdIndex
 * @property {number[]} accounts
 * @property {string} data
 */

/**
 * Message constructor arguments
 */

/**
 * List of instructions to be processed atomically
 */
var Message = /*#__PURE__*/function () {
  function Message(args) {
    var _this = this;
    _classCallCheck(this, Message);
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map(function (account) {
      return new PublicKey(account);
    });
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach(function (ix) {
      return _this.indexToProgramIds.set(ix.programIdIndex, _this.accountKeys[ix.programIdIndex]);
    });
  }
  _createClass(Message, [{
    key: "version",
    get: function get() {
      return 'legacy';
    }
  }, {
    key: "staticAccountKeys",
    get: function get() {
      return this.accountKeys;
    }
  }, {
    key: "compiledInstructions",
    get: function get() {
      return this.instructions.map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: bs58.decode(ix.data)
        };
      });
    }
  }, {
    key: "addressTableLookups",
    get: function get() {
      return [];
    }
  }, {
    key: "getAccountKeys",
    value: function getAccountKeys() {
      return new MessageAccountKeys(this.staticAccountKeys);
    }
  }, {
    key: "isAccountSigner",
    value: function isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
  }, {
    key: "isAccountWritable",
    value: function isAccountWritable(index) {
      var numSignedAccounts = this.header.numRequiredSignatures;
      if (index >= this.header.numRequiredSignatures) {
        var unsignedAccountIndex = index - numSignedAccounts;
        var numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
        var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
  }, {
    key: "isProgramId",
    value: function isProgramId(index) {
      return this.indexToProgramIds.has(index);
    }
  }, {
    key: "programIds",
    value: function programIds() {
      return _toConsumableArray(this.indexToProgramIds.values());
    }
  }, {
    key: "nonProgramIds",
    value: function nonProgramIds() {
      var _this2 = this;
      return this.accountKeys.filter(function (_, index) {
        return !_this2.isProgramId(index);
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var numKeys = this.accountKeys.length;
      var keyCount = [];
      encodeLength(keyCount, numKeys);
      var instructions = this.instructions.map(function (instruction) {
        var accounts = instruction.accounts,
          programIdIndex = instruction.programIdIndex;
        var data = Array.from(bs58.decode(instruction.data));
        var keyIndicesCount = [];
        encodeLength(keyIndicesCount, accounts.length);
        var dataCount = [];
        encodeLength(dataCount, data.length);
        return {
          programIdIndex: programIdIndex,
          keyIndicesCount: Buffer.from(keyIndicesCount),
          keyIndices: accounts,
          dataLength: Buffer.from(dataCount),
          data: data
        };
      });
      var instructionCount = [];
      encodeLength(instructionCount, instructions.length);
      var instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);
      Buffer.from(instructionCount).copy(instructionBuffer);
      var instructionBufferLength = instructionCount.length;
      instructions.forEach(function (instruction) {
        var instructionLayout = BufferLayout.struct([BufferLayout.u8('programIdIndex'), BufferLayout.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), BufferLayout.seq(BufferLayout.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), BufferLayout.blob(instruction.dataLength.length, 'dataLength'), BufferLayout.seq(BufferLayout.u8('userdatum'), instruction.data.length, 'data')]);
        var length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
        instructionBufferLength += length;
      });
      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
      var signDataLayout = BufferLayout.struct([BufferLayout.blob(1, 'numRequiredSignatures'), BufferLayout.blob(1, 'numReadonlySignedAccounts'), BufferLayout.blob(1, 'numReadonlyUnsignedAccounts'), BufferLayout.blob(keyCount.length, 'keyCount'), BufferLayout.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);
      var transaction = {
        numRequiredSignatures: Buffer.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: Buffer.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: Buffer.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: Buffer.from(keyCount),
        keys: this.accountKeys.map(function (key) {
          return toBuffer(key.toBytes());
        }),
        recentBlockhash: bs58.decode(this.recentBlockhash)
      };
      var signData = Buffer.alloc(2048);
      var length = signDataLayout.encode(transaction, signData);
      instructionBuffer.copy(signData, length);
      return signData.slice(0, length + instructionBuffer.length);
    }

    /**
     * Decode a compiled message into a Message object.
     */
  }], [{
    key: "compile",
    value: function compile(args) {
      var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
      var _compiledKeys$getMess = compiledKeys.getMessageComponents(),
        _compiledKeys$getMess2 = _slicedToArray(_compiledKeys$getMess, 2),
        header = _compiledKeys$getMess2[0],
        staticAccountKeys = _compiledKeys$getMess2[1];
      var accountKeys = new MessageAccountKeys(staticAccountKeys);
      var instructions = accountKeys.compileInstructions(args.instructions).map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accounts: ix.accountKeyIndexes,
          data: bs58.encode(ix.data)
        };
      });
      return new Message({
        header: header,
        accountKeys: staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        instructions: instructions
      });
    }
  }, {
    key: "from",
    value: function from(buffer) {
      // Slice up wire data
      var byteArray = _toConsumableArray(buffer);
      var numRequiredSignatures = byteArray.shift();
      if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
        throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');
      }
      var numReadonlySignedAccounts = byteArray.shift();
      var numReadonlyUnsignedAccounts = byteArray.shift();
      var accountCount = decodeLength(byteArray);
      var accountKeys = [];
      for (var i = 0; i < accountCount; i++) {
        var account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
        accountKeys.push(new PublicKey(Buffer.from(account)));
      }
      var recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      var instructionCount = decodeLength(byteArray);
      var instructions = [];
      for (var _i = 0; _i < instructionCount; _i++) {
        var programIdIndex = byteArray.shift();
        var _accountCount = decodeLength(byteArray);
        var accounts = byteArray.slice(0, _accountCount);
        byteArray = byteArray.slice(_accountCount);
        var dataLength = decodeLength(byteArray);
        var dataSlice = byteArray.slice(0, dataLength);
        var data = bs58.encode(Buffer.from(dataSlice));
        byteArray = byteArray.slice(dataLength);
        instructions.push({
          programIdIndex: programIdIndex,
          accounts: accounts,
          data: data
        });
      }
      var messageArgs = {
        header: {
          numRequiredSignatures: numRequiredSignatures,
          numReadonlySignedAccounts: numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts
        },
        recentBlockhash: bs58.encode(Buffer.from(recentBlockhash)),
        accountKeys: accountKeys,
        instructions: instructions
      };
      return new Message(messageArgs);
    }
  }]);
  return Message;
}();

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }
function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

/**
 * Message constructor arguments
 */

var MessageV0 = /*#__PURE__*/function () {
  function MessageV0(args) {
    _classCallCheck(this, MessageV0);
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  _createClass(MessageV0, [{
    key: "version",
    get: function get() {
      return 0;
    }
  }, {
    key: "numAccountKeysFromLookups",
    get: function get() {
      var count = 0;
      var _iterator = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var lookup = _step.value;
          count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return count;
    }
  }, {
    key: "getAccountKeys",
    value: function getAccountKeys(args) {
      var accountKeysFromLookups;
      if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {
        if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
          throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');
        }
        accountKeysFromLookups = args.accountKeysFromLookups;
      } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {
        accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
      } else if (this.addressTableLookups.length > 0) {
        throw new Error('Failed to get account keys because address table lookups were not resolved');
      }
      return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
    }
  }, {
    key: "isAccountSigner",
    value: function isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
  }, {
    key: "isAccountWritable",
    value: function isAccountWritable(index) {
      var numSignedAccounts = this.header.numRequiredSignatures;
      var numStaticAccountKeys = this.staticAccountKeys.length;
      if (index >= numStaticAccountKeys) {
        var lookupAccountKeysIndex = index - numStaticAccountKeys;
        var numWritableLookupAccountKeys = this.addressTableLookups.reduce(function (count, lookup) {
          return count + lookup.writableIndexes.length;
        }, 0);
        return lookupAccountKeysIndex < numWritableLookupAccountKeys;
      } else if (index >= this.header.numRequiredSignatures) {
        var unsignedAccountIndex = index - numSignedAccounts;
        var numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
        var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
  }, {
    key: "resolveAddressTableLookups",
    value: function resolveAddressTableLookups(addressLookupTableAccounts) {
      var accountKeysFromLookups = {
        writable: [],
        readonly: []
      };
      var _iterator2 = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step2;
      try {
        var _loop = function _loop() {
          var tableLookup = _step2.value;
          var tableAccount = addressLookupTableAccounts.find(function (account) {
            return account.key.equals(tableLookup.accountKey);
          });
          if (!tableAccount) {
            throw new Error("Failed to find address lookup table account for table key ".concat(tableLookup.accountKey.toBase58()));
          }
          var _iterator3 = _createForOfIteratorHelper$3(tableLookup.writableIndexes),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var index = _step3.value;
              if (index < tableAccount.state.addresses.length) {
                accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
              } else {
                throw new Error("Failed to find address for index ".concat(index, " in address lookup table ").concat(tableLookup.accountKey.toBase58()));
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          var _iterator4 = _createForOfIteratorHelper$3(tableLookup.readonlyIndexes),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _index = _step4.value;
              if (_index < tableAccount.state.addresses.length) {
                accountKeysFromLookups.readonly.push(tableAccount.state.addresses[_index]);
              } else {
                throw new Error("Failed to find address for index ".concat(_index, " in address lookup table ").concat(tableLookup.accountKey.toBase58()));
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        };
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return accountKeysFromLookups;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var encodedStaticAccountKeysLength = Array();
      encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
      var serializedInstructions = this.serializeInstructions();
      var encodedInstructionsLength = Array();
      encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
      var serializedAddressTableLookups = this.serializeAddressTableLookups();
      var encodedAddressTableLookupsLength = Array();
      encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
      var messageLayout = BufferLayout.struct([BufferLayout.u8('prefix'), BufferLayout.struct([BufferLayout.u8('numRequiredSignatures'), BufferLayout.u8('numReadonlySignedAccounts'), BufferLayout.u8('numReadonlyUnsignedAccounts')], 'header'), BufferLayout.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), BufferLayout.seq(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), BufferLayout.blob(encodedInstructionsLength.length, 'instructionsLength'), BufferLayout.blob(serializedInstructions.length, 'serializedInstructions'), BufferLayout.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), BufferLayout.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);
      var serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
      var MESSAGE_VERSION_0_PREFIX = 1 << 7;
      var serializedMessageLength = messageLayout.encode({
        prefix: MESSAGE_VERSION_0_PREFIX,
        header: this.header,
        staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
        staticAccountKeys: this.staticAccountKeys.map(function (key) {
          return key.toBytes();
        }),
        recentBlockhash: bs58.decode(this.recentBlockhash),
        instructionsLength: new Uint8Array(encodedInstructionsLength),
        serializedInstructions: serializedInstructions,
        addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
        serializedAddressTableLookups: serializedAddressTableLookups
      }, serializedMessage);
      return serializedMessage.slice(0, serializedMessageLength);
    }
  }, {
    key: "serializeInstructions",
    value: function serializeInstructions() {
      var serializedLength = 0;
      var serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
      var _iterator5 = _createForOfIteratorHelper$3(this.compiledInstructions),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var instruction = _step5.value;
          var encodedAccountKeyIndexesLength = Array();
          encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
          var encodedDataLength = Array();
          encodeLength(encodedDataLength, instruction.data.length);
          var instructionLayout = BufferLayout.struct([BufferLayout.u8('programIdIndex'), BufferLayout.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), BufferLayout.blob(encodedDataLength.length, 'encodedDataLength'), BufferLayout.blob(instruction.data.length, 'data')]);
          serializedLength += instructionLayout.encode({
            programIdIndex: instruction.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
            accountKeyIndexes: instruction.accountKeyIndexes,
            encodedDataLength: new Uint8Array(encodedDataLength),
            data: instruction.data
          }, serializedInstructions, serializedLength);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return serializedInstructions.slice(0, serializedLength);
    }
  }, {
    key: "serializeAddressTableLookups",
    value: function serializeAddressTableLookups() {
      var serializedLength = 0;
      var serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
      var _iterator6 = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var lookup = _step6.value;
          var encodedWritableIndexesLength = Array();
          encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
          var encodedReadonlyIndexesLength = Array();
          encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
          var addressTableLookupLayout = BufferLayout.struct([publicKey('accountKey'), BufferLayout.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), BufferLayout.seq(BufferLayout.u8(), lookup.writableIndexes.length, 'writableIndexes'), BufferLayout.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), BufferLayout.seq(BufferLayout.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);
          serializedLength += addressTableLookupLayout.encode({
            accountKey: lookup.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
            writableIndexes: lookup.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
            readonlyIndexes: lookup.readonlyIndexes
          }, serializedAddressTableLookups, serializedLength);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return serializedAddressTableLookups.slice(0, serializedLength);
    }
  }], [{
    key: "compile",
    value: function compile(args) {
      var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
      var addressTableLookups = new Array();
      var accountKeysFromLookups = {
        writable: new Array(),
        readonly: new Array()
      };
      var lookupTableAccounts = args.addressLookupTableAccounts || [];
      var _iterator7 = _createForOfIteratorHelper$3(lookupTableAccounts),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var lookupTable = _step7.value;
          var extractResult = compiledKeys.extractTableLookup(lookupTable);
          if (extractResult !== undefined) {
            var _accountKeysFromLooku, _accountKeysFromLooku2;
            var _extractResult = _slicedToArray(extractResult, 2),
              addressTableLookup = _extractResult[0],
              _extractResult$ = _extractResult[1],
              writable = _extractResult$.writable,
              readonly = _extractResult$.readonly;
            addressTableLookups.push(addressTableLookup);
            (_accountKeysFromLooku = accountKeysFromLookups.writable).push.apply(_accountKeysFromLooku, _toConsumableArray(writable));
            (_accountKeysFromLooku2 = accountKeysFromLookups.readonly).push.apply(_accountKeysFromLooku2, _toConsumableArray(readonly));
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      var _compiledKeys$getMess = compiledKeys.getMessageComponents(),
        _compiledKeys$getMess2 = _slicedToArray(_compiledKeys$getMess, 2),
        header = _compiledKeys$getMess2[0],
        staticAccountKeys = _compiledKeys$getMess2[1];
      var accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
      var compiledInstructions = accountKeys.compileInstructions(args.instructions);
      return new MessageV0({
        header: header,
        staticAccountKeys: staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        compiledInstructions: compiledInstructions,
        addressTableLookups: addressTableLookups
      });
    }
  }, {
    key: "deserialize",
    value: function deserialize(serializedMessage) {
      var byteArray = _toConsumableArray(serializedMessage);
      var prefix = byteArray.shift();
      var maskedPrefix = prefix & VERSION_PREFIX_MASK;
      assert(prefix !== maskedPrefix, "Expected versioned message but received legacy message");
      var version = maskedPrefix;
      assert(version === 0, "Expected versioned message with version 0 but found version ".concat(version));
      var header = {
        numRequiredSignatures: byteArray.shift(),
        numReadonlySignedAccounts: byteArray.shift(),
        numReadonlyUnsignedAccounts: byteArray.shift()
      };
      var staticAccountKeys = [];
      var staticAccountKeysLength = decodeLength(byteArray);
      for (var i = 0; i < staticAccountKeysLength; i++) {
        staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
      }
      var recentBlockhash = bs58.encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
      var instructionCount = decodeLength(byteArray);
      var compiledInstructions = [];
      for (var _i = 0; _i < instructionCount; _i++) {
        var programIdIndex = byteArray.shift();
        var accountKeyIndexesLength = decodeLength(byteArray);
        var accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
        var dataLength = decodeLength(byteArray);
        var data = new Uint8Array(byteArray.splice(0, dataLength));
        compiledInstructions.push({
          programIdIndex: programIdIndex,
          accountKeyIndexes: accountKeyIndexes,
          data: data
        });
      }
      var addressTableLookupsCount = decodeLength(byteArray);
      var addressTableLookups = [];
      for (var _i2 = 0; _i2 < addressTableLookupsCount; _i2++) {
        var accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
        var writableIndexesLength = decodeLength(byteArray);
        var writableIndexes = byteArray.splice(0, writableIndexesLength);
        var readonlyIndexesLength = decodeLength(byteArray);
        var readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
        addressTableLookups.push({
          accountKey: accountKey,
          writableIndexes: writableIndexes,
          readonlyIndexes: readonlyIndexes
        });
      }
      return new MessageV0({
        header: header,
        staticAccountKeys: staticAccountKeys,
        recentBlockhash: recentBlockhash,
        compiledInstructions: compiledInstructions,
        addressTableLookups: addressTableLookups
      });
    }
  }]);
  return MessageV0;
}();

// eslint-disable-next-line no-redeclare
var VersionedMessage = {
  deserializeMessageVersion: function deserializeMessageVersion(serializedMessage) {
    var prefix = serializedMessage[0];
    var maskedPrefix = prefix & VERSION_PREFIX_MASK;

    // if the highest bit of the prefix is not set, the message is not versioned
    if (maskedPrefix === prefix) {
      return 'legacy';
    }

    // the lower 7 bits of the prefix indicate the message version
    return maskedPrefix;
  },
  deserialize: function deserialize(serializedMessage) {
    var version = VersionedMessage.deserializeMessageVersion(serializedMessage);
    if (version === 'legacy') {
      return Message.from(serializedMessage);
    }
    if (version === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error("Transaction message version ".concat(version, " deserialization is not supported"));
    }
  }
};

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }
function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Transaction signature as base-58 encoded string
 */

var TransactionStatus = /*#__PURE__*/function (TransactionStatus) {
  TransactionStatus[TransactionStatus["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus[TransactionStatus["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus[TransactionStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus[TransactionStatus["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus;
}({});

/**
 * Default (empty) signature
 */
var DEFAULT_SIGNATURE = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);

/**
 * Account metadata used to define instructions
 */

/**
 * List of TransactionInstruction object fields that may be initialized at construction
 */

/**
 * Configuration object for Transaction.serialize()
 */

/**
 * @internal
 */

/**
 * Transaction Instruction class
 */
var TransactionInstruction = /*#__PURE__*/function () {
  function TransactionInstruction(opts) {
    _classCallCheck(this, TransactionInstruction);
    /**
     * Public keys to include in this transaction
     * Boolean represents whether this pubkey needs to sign the transaction
     */
    this.keys = void 0;
    /**
     * Program Id to execute
     */
    this.programId = void 0;
    /**
     * Program input
     */
    this.data = Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }

  /**
   * @internal
   */
  _createClass(TransactionInstruction, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        keys: this.keys.map(function (_ref) {
          var pubkey = _ref.pubkey,
            isSigner = _ref.isSigner,
            isWritable = _ref.isWritable;
          return {
            pubkey: pubkey.toJSON(),
            isSigner: isSigner,
            isWritable: isWritable
          };
        }),
        programId: this.programId.toJSON(),
        data: _toConsumableArray(this.data)
      };
    }
  }]);
  return TransactionInstruction;
}();

/**
 * Pair of signature and corresponding public key
 */

/**
 * List of Transaction object fields that may be initialized at construction
 */

// For backward compatibility; an unfortunate consequence of being
// forced to over-export types by the documentation generator.
// See https://github.com/solana-labs/solana/pull/25820
/**
 * Blockhash-based transactions have a lifetime that are defined by
 * the blockhash they include. Any transaction whose blockhash is
 * too old will be rejected.
 */
/**
 * Use these options to construct a durable nonce transaction.
 */
/**
 * Nonce information to be used to build an offline Transaction.
 */
/**
 * @internal
 */
/**
 * Transaction class
 */
var Transaction = /*#__PURE__*/function () {
  /**
   * Construct an empty Transaction
   */
  function Transaction(opts) {
    _classCallCheck(this, Transaction);
    /**
     * Signatures for the transaction.  Typically created by invoking the
     * `sign()` method
     */
    this.signatures = [];
    /**
     * The transaction fee payer
     */
    this.feePayer = void 0;
    /**
     * The instructions to atomically execute
     */
    this.instructions = [];
    /**
     * A recent transaction id. Must be populated by the caller
     */
    this.recentBlockhash = void 0;
    /**
     * the last block chain can advance to before tx is declared expired
     * */
    this.lastValidBlockHeight = void 0;
    /**
     * Optional Nonce information. If populated, transaction will use a durable
     * Nonce hash instead of a recentBlockhash. Must be populated by the caller
     */
    this.nonceInfo = void 0;
    /**
     * If this is a nonce transaction this represents the minimum slot from which
     * to evaluate if the nonce has advanced when attempting to confirm the
     * transaction. This protects against a case where the transaction confirmation
     * logic loads the nonce account from an old slot and assumes the mismatch in
     * nonce value implies that the nonce has been advanced.
     */
    this.minNonceContextSlot = void 0;
    /**
     * @internal
     */
    this._message = void 0;
    /**
     * @internal
     */
    this._json = void 0;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {
      var _ref2 = opts,
        minContextSlot = _ref2.minContextSlot,
        nonceInfo = _ref2.nonceInfo;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {
      var _ref3 = opts,
        blockhash = _ref3.blockhash,
        lastValidBlockHeight = _ref3.lastValidBlockHeight;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      var _ref4 = opts,
        recentBlockhash = _ref4.recentBlockhash,
        _nonceInfo = _ref4.nonceInfo;
      if (_nonceInfo) {
        this.nonceInfo = _nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }

  /**
   * @internal
   */
  _createClass(Transaction, [{
    key: "signature",
    get:
    /**
     * The first (payer) Transaction signature
     *
     * @returns {Buffer | null} Buffer of payer's signature
     */
    function get() {
      if (this.signatures.length > 0) {
        return this.signatures[0].signature;
      }
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo ? {
          nonce: this.nonceInfo.nonce,
          nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
        } : null,
        instructions: this.instructions.map(function (instruction) {
          return instruction.toJSON();
        }),
        signers: this.signatures.map(function (_ref5) {
          var publicKey = _ref5.publicKey;
          return publicKey.toJSON();
        })
      };
    }

    /**
     * Add one or more instructions to this Transaction
     *
     * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
     */
  }, {
    key: "add",
    value: function add() {
      var _this = this;
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }
      if (items.length === 0) {
        throw new Error('No instructions');
      }
      items.forEach(function (item) {
        if ('instructions' in item) {
          _this.instructions = _this.instructions.concat(item.instructions);
        } else if ('data' in item && 'programId' in item && 'keys' in item) {
          _this.instructions.push(item);
        } else {
          _this.instructions.push(new TransactionInstruction(item));
        }
      });
      return this;
    }

    /**
     * Compile transaction data
     */
  }, {
    key: "compileMessage",
    value: function compileMessage() {
      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
        return this._message;
      }
      var recentBlockhash;
      var instructions;
      if (this.nonceInfo) {
        recentBlockhash = this.nonceInfo.nonce;
        if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
          instructions = [this.nonceInfo.nonceInstruction].concat(_toConsumableArray(this.instructions));
        } else {
          instructions = this.instructions;
        }
      } else {
        recentBlockhash = this.recentBlockhash;
        instructions = this.instructions;
      }
      if (!recentBlockhash) {
        throw new Error('Transaction recentBlockhash required');
      }
      if (instructions.length < 1) {
        console.warn('No instructions provided');
      }
      var feePayer;
      if (this.feePayer) {
        feePayer = this.feePayer;
      } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
        // Use implicit fee payer
        feePayer = this.signatures[0].publicKey;
      } else {
        throw new Error('Transaction fee payer required');
      }
      for (var i = 0; i < instructions.length; i++) {
        if (instructions[i].programId === undefined) {
          throw new Error("Transaction instruction index ".concat(i, " has undefined program id"));
        }
      }
      var programIds = [];
      var accountMetas = [];
      instructions.forEach(function (instruction) {
        instruction.keys.forEach(function (accountMeta) {
          accountMetas.push(_objectSpread$2({}, accountMeta));
        });
        var programId = instruction.programId.toString();
        if (!programIds.includes(programId)) {
          programIds.push(programId);
        }
      });

      // Append programID account metas
      programIds.forEach(function (programId) {
        accountMetas.push({
          pubkey: new PublicKey(programId),
          isSigner: false,
          isWritable: false
        });
      });

      // Cull duplicate account metas
      var uniqueMetas = [];
      accountMetas.forEach(function (accountMeta) {
        var pubkeyString = accountMeta.pubkey.toString();
        var uniqueIndex = uniqueMetas.findIndex(function (x) {
          return x.pubkey.toString() === pubkeyString;
        });
        if (uniqueIndex > -1) {
          uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
          uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
        } else {
          uniqueMetas.push(accountMeta);
        }
      });

      // Sort. Prioritizing first by signer, then by writable
      uniqueMetas.sort(function (x, y) {
        if (x.isSigner !== y.isSigner) {
          // Signers always come before non-signers
          return x.isSigner ? -1 : 1;
        }
        if (x.isWritable !== y.isWritable) {
          // Writable accounts always come before read-only accounts
          return x.isWritable ? -1 : 1;
        }
        // Otherwise, sort by pubkey, stringwise.
        var options = {
          localeMatcher: 'best fit',
          usage: 'sort',
          sensitivity: 'variant',
          ignorePunctuation: false,
          numeric: false,
          caseFirst: 'lower'
        };
        return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), 'en', options);
      });

      // Move fee payer to the front
      var feePayerIndex = uniqueMetas.findIndex(function (x) {
        return x.pubkey.equals(feePayer);
      });
      if (feePayerIndex > -1) {
        var _uniqueMetas$splice = uniqueMetas.splice(feePayerIndex, 1),
          _uniqueMetas$splice2 = _slicedToArray(_uniqueMetas$splice, 1),
          payerMeta = _uniqueMetas$splice2[0];
        payerMeta.isSigner = true;
        payerMeta.isWritable = true;
        uniqueMetas.unshift(payerMeta);
      } else {
        uniqueMetas.unshift({
          pubkey: feePayer,
          isSigner: true,
          isWritable: true
        });
      }

      // Disallow unknown signers
      var _iterator = _createForOfIteratorHelper$2(this.signatures),
        _step;
      try {
        var _loop = function _loop() {
          var signature = _step.value;
          var uniqueIndex = uniqueMetas.findIndex(function (x) {
            return x.pubkey.equals(signature.publicKey);
          });
          if (uniqueIndex > -1) {
            if (!uniqueMetas[uniqueIndex].isSigner) {
              uniqueMetas[uniqueIndex].isSigner = true;
              console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
            }
          } else {
            throw new Error("unknown signer: ".concat(signature.publicKey.toString()));
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var numRequiredSignatures = 0;
      var numReadonlySignedAccounts = 0;
      var numReadonlyUnsignedAccounts = 0;

      // Split out signing from non-signing keys and count header values
      var signedKeys = [];
      var unsignedKeys = [];
      uniqueMetas.forEach(function (_ref6) {
        var pubkey = _ref6.pubkey,
          isSigner = _ref6.isSigner,
          isWritable = _ref6.isWritable;
        if (isSigner) {
          signedKeys.push(pubkey.toString());
          numRequiredSignatures += 1;
          if (!isWritable) {
            numReadonlySignedAccounts += 1;
          }
        } else {
          unsignedKeys.push(pubkey.toString());
          if (!isWritable) {
            numReadonlyUnsignedAccounts += 1;
          }
        }
      });
      var accountKeys = signedKeys.concat(unsignedKeys);
      var compiledInstructions = instructions.map(function (instruction) {
        var data = instruction.data,
          programId = instruction.programId;
        return {
          programIdIndex: accountKeys.indexOf(programId.toString()),
          accounts: instruction.keys.map(function (meta) {
            return accountKeys.indexOf(meta.pubkey.toString());
          }),
          data: bs58.encode(data)
        };
      });
      compiledInstructions.forEach(function (instruction) {
        assert(instruction.programIdIndex >= 0);
        instruction.accounts.forEach(function (keyIndex) {
          return assert(keyIndex >= 0);
        });
      });
      return new Message({
        header: {
          numRequiredSignatures: numRequiredSignatures,
          numReadonlySignedAccounts: numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts
        },
        accountKeys: accountKeys,
        recentBlockhash: recentBlockhash,
        instructions: compiledInstructions
      });
    }

    /**
     * @internal
     */
  }, {
    key: "_compile",
    value: function _compile() {
      var message = this.compileMessage();
      var signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
      if (this.signatures.length === signedKeys.length) {
        var valid = this.signatures.every(function (pair, index) {
          return signedKeys[index].equals(pair.publicKey);
        });
        if (valid) return message;
      }
      this.signatures = signedKeys.map(function (publicKey) {
        return {
          signature: null,
          publicKey: publicKey
        };
      });
      return message;
    }

    /**
     * Get a buffer of the Transaction data that need to be covered by signatures
     */
  }, {
    key: "serializeMessage",
    value: function serializeMessage() {
      return this._compile().serialize();
    }

    /**
     * Get the estimated fee associated with a transaction
     *
     * @param {Connection} connection Connection to RPC Endpoint.
     *
     * @returns {Promise<number | null>} The estimated fee for the transaction
     */
  }, {
    key: "getEstimatedFee",
    value: function () {
      var _getEstimatedFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getFeeForMessage(this.compileMessage());
            case 2:
              return _context.abrupt("return", _context.sent.value);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getEstimatedFee(_x) {
        return _getEstimatedFee.apply(this, arguments);
      }
      return getEstimatedFee;
    }()
    /**
     * Specify the public keys which will be used to sign the Transaction.
     * The first signer will be used as the transaction fee payer account.
     *
     * Signatures can be added with either `partialSign` or `addSignature`
     *
     * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
     * specified and it can be set in the Transaction constructor or with the
     * `feePayer` property.
     */
  }, {
    key: "setSigners",
    value: function setSigners() {
      for (var _len2 = arguments.length, signers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        signers[_key2] = arguments[_key2];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }
      var seen = new Set();
      this.signatures = signers.filter(function (publicKey) {
        var key = publicKey.toString();
        if (seen.has(key)) {
          return false;
        } else {
          seen.add(key);
          return true;
        }
      }).map(function (publicKey) {
        return {
          signature: null,
          publicKey: publicKey
        };
      });
    }

    /**
     * Sign the Transaction with the specified signers. Multiple signatures may
     * be applied to a Transaction. The first signature is considered "primary"
     * and is used identify and confirm transactions.
     *
     * If the Transaction `feePayer` is not set, the first signer will be used
     * as the transaction fee payer account.
     *
     * Transaction fields should not be modified after the first call to `sign`,
     * as doing so may invalidate the signature and cause the Transaction to be
     * rejected.
     *
     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
     *
     * @param {Array<Signer>} signers Array of signers that will sign the transaction
     */
  }, {
    key: "sign",
    value: function sign() {
      for (var _len3 = arguments.length, signers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        signers[_key3] = arguments[_key3];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }

      // Dedupe signers
      var seen = new Set();
      var uniqueSigners = [];
      for (var _i = 0, _signers = signers; _i < _signers.length; _i++) {
        var signer = _signers[_i];
        var key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      this.signatures = uniqueSigners.map(function (signer) {
        return {
          signature: null,
          publicKey: signer.publicKey
        };
      });
      var message = this._compile();
      this._partialSign.apply(this, [message].concat(uniqueSigners));
    }

    /**
     * Partially sign a transaction with the specified accounts. All accounts must
     * correspond to either the fee payer or a signer account in the transaction
     * instructions.
     *
     * All the caveats from the `sign` method apply to `partialSign`
     *
     * @param {Array<Signer>} signers Array of signers that will sign the transaction
     */
  }, {
    key: "partialSign",
    value: function partialSign() {
      for (var _len4 = arguments.length, signers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        signers[_key4] = arguments[_key4];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }

      // Dedupe signers
      var seen = new Set();
      var uniqueSigners = [];
      for (var _i2 = 0, _signers2 = signers; _i2 < _signers2.length; _i2++) {
        var signer = _signers2[_i2];
        var key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      var message = this._compile();
      this._partialSign.apply(this, [message].concat(uniqueSigners));
    }

    /**
     * @internal
     */
  }, {
    key: "_partialSign",
    value: function _partialSign(message) {
      var _this2 = this;
      var signData = message.serialize();
      for (var _len5 = arguments.length, signers = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        signers[_key5 - 1] = arguments[_key5];
      }
      signers.forEach(function (signer) {
        var signature = sign(signData, signer.secretKey);
        _this2._addSignature(signer.publicKey, toBuffer(signature));
      });
    }

    /**
     * Add an externally created signature to a transaction. The public key
     * must correspond to either the fee payer or a signer account in the transaction
     * instructions.
     *
     * @param {PublicKey} pubkey Public key that will be added to the transaction.
     * @param {Buffer} signature An externally created signature to add to the transaction.
     */
  }, {
    key: "addSignature",
    value: function addSignature(pubkey, signature) {
      this._compile(); // Ensure signatures array is populated
      this._addSignature(pubkey, signature);
    }

    /**
     * @internal
     */
  }, {
    key: "_addSignature",
    value: function _addSignature(pubkey, signature) {
      assert(signature.length === 64);
      var index = this.signatures.findIndex(function (sigpair) {
        return pubkey.equals(sigpair.publicKey);
      });
      if (index < 0) {
        throw new Error("unknown signer: ".concat(pubkey.toString()));
      }
      this.signatures[index].signature = Buffer.from(signature);
    }

    /**
     * Verify signatures of a Transaction
     * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
     * If no boolean is provided, we expect a fully signed Transaction by default.
     *
     * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
     */
  }, {
    key: "verifySignatures",
    value: function verifySignatures(requireAllSignatures) {
      return this._verifySignatures(this.serializeMessage(), requireAllSignatures === undefined ? true : requireAllSignatures);
    }

    /**
     * @internal
     */
  }, {
    key: "_verifySignatures",
    value: function _verifySignatures(signData, requireAllSignatures) {
      var _iterator2 = _createForOfIteratorHelper$2(this.signatures),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _step2.value,
            signature = _step2$value.signature,
            publicKey = _step2$value.publicKey;
          if (signature === null) {
            if (requireAllSignatures) {
              return false;
            }
          } else {
            if (!verify(signature, signData, publicKey.toBytes())) {
              return false;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return true;
    }

    /**
     * Serialize the Transaction in the wire format.
     *
     * @param {Buffer} [config] Config of transaction.
     *
     * @returns {Buffer} Signature of transaction in wire format.
     */
  }, {
    key: "serialize",
    value: function serialize(config) {
      var _Object$assign = Object.assign({
          requireAllSignatures: true,
          verifySignatures: true
        }, config),
        requireAllSignatures = _Object$assign.requireAllSignatures,
        verifySignatures = _Object$assign.verifySignatures;
      var signData = this.serializeMessage();
      if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
        throw new Error('Signature verification failed');
      }
      return this._serialize(signData);
    }

    /**
     * @internal
     */
  }, {
    key: "_serialize",
    value: function _serialize(signData) {
      var signatures = this.signatures;
      var signatureCount = [];
      encodeLength(signatureCount, signatures.length);
      var transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
      var wireTransaction = Buffer.alloc(transactionLength);
      assert(signatures.length < 256);
      Buffer.from(signatureCount).copy(wireTransaction, 0);
      signatures.forEach(function (_ref7, index) {
        var signature = _ref7.signature;
        if (signature !== null) {
          assert(signature.length === 64, "signature has invalid length");
          Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
        }
      });
      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
      assert(wireTransaction.length <= PACKET_DATA_SIZE, "Transaction too large: ".concat(wireTransaction.length, " > ").concat(PACKET_DATA_SIZE));
      return wireTransaction;
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "keys",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].keys.map(function (keyObj) {
        return keyObj.pubkey;
      });
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "programId",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].programId;
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "data",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].data;
    }

    /**
     * Parse a wire transaction into a Transaction object.
     *
     * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
     *
     * @returns {Transaction} Transaction associated with the signature
     */
  }], [{
    key: "from",
    value: function from(buffer) {
      // Slice up wire data
      var byteArray = _toConsumableArray(buffer);
      var signatureCount = decodeLength(byteArray);
      var signatures = [];
      for (var i = 0; i < signatureCount; i++) {
        var signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
        byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
        signatures.push(bs58.encode(Buffer.from(signature)));
      }
      return Transaction.populate(Message.from(byteArray), signatures);
    }

    /**
     * Populate Transaction object from message and signatures
     *
     * @param {Message} message Message of transaction
     * @param {Array<string>} signatures List of signatures to assign to the transaction
     *
     * @returns {Transaction} The populated Transaction
     */
  }, {
    key: "populate",
    value: function populate(message) {
      var signatures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var transaction = new Transaction();
      transaction.recentBlockhash = message.recentBlockhash;
      if (message.header.numRequiredSignatures > 0) {
        transaction.feePayer = message.accountKeys[0];
      }
      signatures.forEach(function (signature, index) {
        var sigPubkeyPair = {
          signature: signature == bs58.encode(DEFAULT_SIGNATURE) ? null : bs58.decode(signature),
          publicKey: message.accountKeys[index]
        };
        transaction.signatures.push(sigPubkeyPair);
      });
      message.instructions.forEach(function (instruction) {
        var keys = instruction.accounts.map(function (account) {
          var pubkey = message.accountKeys[account];
          return {
            pubkey: pubkey,
            isSigner: transaction.signatures.some(function (keyObj) {
              return keyObj.publicKey.toString() === pubkey.toString();
            }) || message.isAccountSigner(account),
            isWritable: message.isAccountWritable(account)
          };
        });
        transaction.instructions.push(new TransactionInstruction({
          keys: keys,
          programId: message.accountKeys[instruction.programIdIndex],
          data: bs58.decode(instruction.data)
        }));
      });
      transaction._message = message;
      transaction._json = transaction.toJSON();
      return transaction;
    }
  }]);
  return Transaction;
}();

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var TransactionMessage = /*#__PURE__*/function () {
  function TransactionMessage(args) {
    _classCallCheck(this, TransactionMessage);
    this.payerKey = void 0;
    this.instructions = void 0;
    this.recentBlockhash = void 0;
    this.payerKey = args.payerKey;
    this.instructions = args.instructions;
    this.recentBlockhash = args.recentBlockhash;
  }
  _createClass(TransactionMessage, [{
    key: "compileToLegacyMessage",
    value: function compileToLegacyMessage() {
      return Message.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions
      });
    }
  }, {
    key: "compileToV0Message",
    value: function compileToV0Message(addressLookupTableAccounts) {
      return MessageV0.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
        addressLookupTableAccounts: addressLookupTableAccounts
      });
    }
  }], [{
    key: "decompile",
    value: function decompile(message, args) {
      var header = message.header,
        compiledInstructions = message.compiledInstructions,
        recentBlockhash = message.recentBlockhash;
      var numRequiredSignatures = header.numRequiredSignatures,
        numReadonlySignedAccounts = header.numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts = header.numReadonlyUnsignedAccounts;
      var numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
      assert(numWritableSignedAccounts > 0, 'Message header is invalid');
      var numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
      assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');
      var accountKeys = message.getAccountKeys(args);
      var payerKey = accountKeys.get(0);
      if (payerKey === undefined) {
        throw new Error('Failed to decompile message because no account keys were found');
      }
      var instructions = [];
      var _iterator = _createForOfIteratorHelper$1(compiledInstructions),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var compiledIx = _step.value;
          var keys = [];
          var _iterator2 = _createForOfIteratorHelper$1(compiledIx.accountKeyIndexes),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var keyIndex = _step2.value;
              var pubkey = accountKeys.get(keyIndex);
              if (pubkey === undefined) {
                throw new Error("Failed to find key for account key index ".concat(keyIndex));
              }
              var isSigner = keyIndex < numRequiredSignatures;
              var isWritable = void 0;
              if (isSigner) {
                isWritable = keyIndex < numWritableSignedAccounts;
              } else if (keyIndex < accountKeys.staticAccountKeys.length) {
                isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
              } else {
                isWritable = keyIndex - accountKeys.staticAccountKeys.length <
                // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
                accountKeys.accountKeysFromLookups.writable.length;
              }
              keys.push({
                pubkey: pubkey,
                isSigner: keyIndex < header.numRequiredSignatures,
                isWritable: isWritable
              });
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          var programId = accountKeys.get(compiledIx.programIdIndex);
          if (programId === undefined) {
            throw new Error("Failed to find program id for program id index ".concat(compiledIx.programIdIndex));
          }
          instructions.push(new TransactionInstruction({
            programId: programId,
            data: toBuffer(compiledIx.data),
            keys: keys
          }));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return new TransactionMessage({
        payerKey: payerKey,
        instructions: instructions,
        recentBlockhash: recentBlockhash
      });
    }
  }]);
  return TransactionMessage;
}();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * Versioned transaction class
 */
var VersionedTransaction = /*#__PURE__*/function () {
  function VersionedTransaction(message, signatures) {
    _classCallCheck(this, VersionedTransaction);
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== undefined) {
      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');
      this.signatures = signatures;
    } else {
      var defaultSignatures = [];
      for (var i = 0; i < message.header.numRequiredSignatures; i++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message;
  }
  _createClass(VersionedTransaction, [{
    key: "version",
    get: function get() {
      return this.message.version;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serializedMessage = this.message.serialize();
      var encodedSignaturesLength = Array();
      encodeLength(encodedSignaturesLength, this.signatures.length);
      var transactionLayout = BufferLayout.struct([BufferLayout.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'), BufferLayout.seq(signature(), this.signatures.length, 'signatures'), BufferLayout.blob(serializedMessage.length, 'serializedMessage')]);
      var serializedTransaction = new Uint8Array(2048);
      var serializedTransactionLength = transactionLayout.encode({
        encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
        signatures: this.signatures,
        serializedMessage: serializedMessage
      }, serializedTransaction);
      return serializedTransaction.slice(0, serializedTransactionLength);
    }
  }, {
    key: "sign",
    value: function sign$1(signers) {
      var _this = this;
      var messageData = this.message.serialize();
      var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      var _iterator = _createForOfIteratorHelper(signers),
        _step;
      try {
        var _loop = function _loop() {
          var signer = _step.value;
          var signerIndex = signerPubkeys.findIndex(function (pubkey) {
            return pubkey.equals(signer.publicKey);
          });
          assert(signerIndex >= 0, "Cannot sign with non signer key ".concat(signer.publicKey.toBase58()));
          _this.signatures[signerIndex] = sign(messageData, signer.secretKey);
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "addSignature",
    value: function addSignature(publicKey, signature) {
      assert(signature.byteLength === 64, 'Signature must be 64 bytes long');
      var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      var signerIndex = signerPubkeys.findIndex(function (pubkey) {
        return pubkey.equals(publicKey);
      });
      assert(signerIndex >= 0, "Can not add signature; `".concat(publicKey.toBase58(), "` is not required to sign this transaction"));
      this.signatures[signerIndex] = signature;
    }
  }], [{
    key: "deserialize",
    value: function deserialize(serializedTransaction) {
      var byteArray = _toConsumableArray(serializedTransaction);
      var signatures = [];
      var signaturesLength = decodeLength(byteArray);
      for (var i = 0; i < signaturesLength; i++) {
        signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
      }
      var message = VersionedMessage.deserialize(new Uint8Array(byteArray));
      return new VersionedTransaction(message, signatures);
    }
  }]);
  return VersionedTransaction;
}();

// TODO: These constants should be removed in favor of reading them out of a
// Syscall account

/**
 * @internal
 */
var NUM_TICKS_PER_SECOND = 160;

/**
 * @internal
 */
var DEFAULT_TICKS_PER_SLOT = 64;

/**
 * @internal
 */
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;

/**
 * @internal
 */
var MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;

var SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
var SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
var SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');

/**
 * Sign, send and confirm a transaction.
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Transaction} transaction
 * @param {Array<Signer>} signers
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */
function sendAndConfirmTransaction(_x, _x2, _x3, _x4) {
  return _sendAndConfirmTransaction.apply(this, arguments);
}
function _sendAndConfirmTransaction() {
  _sendAndConfirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, transaction, signers, options) {
    var sendOptions, signature, status, nonceInstruction, nonceAccountPubkey;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          sendOptions = options && {
            skipPreflight: options.skipPreflight,
            preflightCommitment: options.preflightCommitment || options.commitment,
            maxRetries: options.maxRetries,
            minContextSlot: options.minContextSlot
          };
          _context.next = 3;
          return connection.sendTransaction(transaction, signers, sendOptions);
        case 3:
          signature = _context.sent;
          if (!(transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null)) {
            _context.next = 10;
            break;
          }
          _context.next = 7;
          return connection.confirmTransaction({
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            signature: signature,
            blockhash: transaction.recentBlockhash,
            lastValidBlockHeight: transaction.lastValidBlockHeight
          }, options && options.commitment);
        case 7:
          status = _context.sent.value;
          _context.next = 22;
          break;
        case 10:
          if (!(transaction.minNonceContextSlot != null && transaction.nonceInfo != null)) {
            _context.next = 18;
            break;
          }
          nonceInstruction = transaction.nonceInfo.nonceInstruction;
          nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
          _context.next = 15;
          return connection.confirmTransaction({
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            minContextSlot: transaction.minNonceContextSlot,
            nonceAccountPubkey: nonceAccountPubkey,
            nonceValue: transaction.nonceInfo.nonce,
            signature: signature
          }, options && options.commitment);
        case 15:
          status = _context.sent.value;
          _context.next = 22;
          break;
        case 18:
          if ((options === null || options === void 0 ? void 0 : options.abortSignal) != null) {
            console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');
          }
          _context.next = 21;
          return connection.confirmTransaction(signature, options && options.commitment);
        case 21:
          status = _context.sent.value;
        case 22:
          if (!status.err) {
            _context.next = 24;
            break;
          }
          throw new Error("Transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));
        case 24:
          return _context.abrupt("return", signature);
        case 25:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _sendAndConfirmTransaction.apply(this, arguments);
}

// zzz
function sleep(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}

/**
 * @internal
 */

/**
 * Populate a buffer of instruction data using an InstructionType
 * @internal
 */
function encodeData(type, fields) {
  var allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
  var data = Buffer.alloc(allocLength);
  var layoutFields = Object.assign({
    instruction: type.index
  }, fields);
  type.layout.encode(layoutFields, data);
  return data;
}

/**
 * Decode instruction data buffer using an InstructionType
 * @internal
 */
function decodeData$1(type, buffer) {
  var data;
  try {
    data = type.layout.decode(buffer);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }
  if (data.instruction !== type.index) {
    throw new Error("invalid instruction; instruction index mismatch ".concat(data.instruction, " != ").concat(type.index));
  }
  return data;
}

/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 *
 * @internal
 */
var FeeCalculatorLayout = BufferLayout.nu64('lamportsPerSignature');

/**
 * Calculator for transaction fees.
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
 *
 * @internal
 */
var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32('version'), BufferLayout.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), BufferLayout.struct([FeeCalculatorLayout], 'feeCalculator')]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;

/**
 * A durable nonce is a 32 byte value encoded as a base58 string.
 */

/**
 * NonceAccount class
 */
var NonceAccount = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function NonceAccount(args) {
    _classCallCheck(this, NonceAccount);
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }

  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  _createClass(NonceAccount, null, [{
    key: "fromAccountData",
    value: function fromAccountData(buffer) {
      var nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
      return new NonceAccount({
        authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
        nonce: new PublicKey(nonceAccount.nonce).toString(),
        feeCalculator: nonceAccount.feeCalculator
      });
    }
  }]);
  return NonceAccount;
}();

var encodeDecode = function encodeDecode(layout) {
  var decode = layout.decode.bind(layout);
  var encode = layout.encode.bind(layout);
  return {
    decode: decode,
    encode: encode
  };
};
var bigInt = function bigInt(length) {
  return function (property) {
    var layout = blob(length, property);
    var _encodeDecode = encodeDecode(layout),
      encode = _encodeDecode.encode,
      decode = _encodeDecode.decode;
    var bigIntLayout = layout;
    bigIntLayout.decode = function (buffer, offset) {
      var src = decode(buffer, offset);
      return toBigIntLE(Buffer.from(src));
    };
    bigIntLayout.encode = function (bigInt, buffer, offset) {
      var src = toBufferLE(bigInt, length);
      return encode(src, buffer, offset);
    };
    return bigIntLayout;
  };
};
var u64 = bigInt(8);

/**
 * Create account system transaction params
 */

/**
 * Transfer system transaction params
 */

/**
 * Assign system transaction params
 */

/**
 * Create account with seed system transaction params
 */

/**
 * Create nonce account system transaction params
 */

/**
 * Create nonce account with seed system transaction params
 */

/**
 * Initialize nonce account system instruction params
 */

/**
 * Advance nonce account system instruction params
 */

/**
 * Withdraw nonce account system transaction params
 */

/**
 * Authorize nonce account system transaction params
 */

/**
 * Allocate account system transaction params
 */

/**
 * Allocate account with seed system transaction params
 */

/**
 * Assign account with seed system transaction params
 */

/**
 * Transfer with seed system transaction params
 */

/** Decoded transfer system transaction instruction */

/** Decoded transferWithSeed system transaction instruction */

/**
 * System Instruction class
 */
var SystemInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SystemInstruction() {
    _classCallCheck(this, SystemInstruction);
  }

  /**
   * Decode a system instruction and retrieve the instruction type.
   */
  _createClass(SystemInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = BufferLayout.u32('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(SYSTEM_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a SystemInstruction');
      }
      return type;
    }

    /**
     * Decode a create account system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeCreateAccount",
    value: function decodeCreateAccount(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data),
        lamports = _decodeData.lamports,
        space = _decodeData.space,
        programId = _decodeData.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        lamports: lamports,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a transfer system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeTransfer",
    value: function decodeTransfer(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData2 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data),
        lamports = _decodeData2.lamports;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        lamports: lamports
      };
    }

    /**
     * Decode a transfer with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeTransferWithSeed",
    value: function decodeTransferWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData3 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data),
        lamports = _decodeData3.lamports,
        seed = _decodeData3.seed,
        programId = _decodeData3.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        basePubkey: instruction.keys[1].pubkey,
        toPubkey: instruction.keys[2].pubkey,
        lamports: lamports,
        seed: seed,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an allocate system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAllocate",
    value: function decodeAllocate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData4 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data),
        space = _decodeData4.space;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        space: space
      };
    }

    /**
     * Decode an allocate with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAllocateWithSeed",
    value: function decodeAllocateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData5 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data),
        base = _decodeData5.base,
        seed = _decodeData5.seed,
        space = _decodeData5.space,
        programId = _decodeData5.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an assign system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAssign",
    value: function decodeAssign(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData6 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data),
        programId = _decodeData6.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an assign with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAssignWithSeed",
    value: function decodeAssignWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData7 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data),
        base = _decodeData7.base,
        seed = _decodeData7.seed,
        programId = _decodeData7.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a create account with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeCreateWithSeed",
    value: function decodeCreateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData8 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data),
        base = _decodeData8.base,
        seed = _decodeData8.seed,
        lamports = _decodeData8.lamports,
        space = _decodeData8.space,
        programId = _decodeData8.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        lamports: lamports,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a nonce initialize system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceInitialize",
    value: function decodeNonceInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData9 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data),
        authorized = _decodeData9.authorized;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: new PublicKey(authorized)
      };
    }

    /**
     * Decode a nonce advance system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceAdvance",
    value: function decodeNonceAdvance(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }

    /**
     * Decode a nonce withdraw system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceWithdraw",
    value: function decodeNonceWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);
      var _decodeData10 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data),
        lamports = _decodeData10.lamports;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports: lamports
      };
    }

    /**
     * Decode a nonce authorize system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceAuthorize",
    value: function decodeNonceAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData11 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data),
        authorized = _decodeData11.authorized;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[1].pubkey,
        newAuthorizedPubkey: new PublicKey(authorized)
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(SystemProgram.programId)) {
        throw new Error('invalid instruction; programId is not SystemProgram');
      }
    }

    /**
     * @internal
     */
  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return SystemInstruction;
}();

/**
 * An enumeration of valid SystemInstructionType's
 */

/**
 * An enumeration of valid system InstructionType's
 * @internal
 */
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('programId')])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), u64('lamports')])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout.ns64('lamports'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('authorized')])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('authorized')])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('space')])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  }
});

/**
 * Factory class for transactions to interact with the System program
 */
var SystemProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SystemProgram() {
    _classCallCheck(this, SystemProgram);
  }

  /**
   * Public key that identifies the System program
   */
  _createClass(SystemProgram, null, [{
    key: "createAccount",
    value:
    /**
     * Generate a transaction instruction that creates a new account
     */
    function createAccount(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
      var data = encodeData(type, {
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: true,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that transfers lamports from one account to another
     */
  }, {
    key: "transfer",
    value: function transfer(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
        data = encodeData(type, {
          lamports: BigInt(params.lamports),
          seed: params.seed,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      } else {
        var _type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
        data = encodeData(_type, {
          lamports: BigInt(params.lamports)
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that assigns an account to a program
     */
  }, {
    key: "assign",
    value: function assign(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
        data = encodeData(type, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        var _type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
        data = encodeData(_type2, {
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that creates a new account at
     *   an address generated with `from`, a seed, and programId
     */
  }, {
    key: "createAccountWithSeed",
    value: function createAccountWithSeed(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
      var data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      var keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: false,
        isWritable: true
      }];
      if (params.basePubkey != params.fromPubkey) {
        keys.push({
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction that creates a new Nonce account
     */
  }, {
    key: "createNonceAccount",
    value: function createNonceAccount(params) {
      var transaction = new Transaction();
      if ('basePubkey' in params && 'seed' in params) {
        transaction.add(SystemProgram.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH,
          programId: this.programId
        }));
      } else {
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH,
          programId: this.programId
        }));
      }
      var initParams = {
        noncePubkey: params.noncePubkey,
        authorizedPubkey: params.authorizedPubkey
      };
      transaction.add(this.nonceInitialize(initParams));
      return transaction;
    }

    /**
     * Generate an instruction to initialize a Nonce account
     */
  }, {
    key: "nonceInitialize",
    value: function nonceInitialize(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
      var data = encodeData(type, {
        authorized: toBuffer(params.authorizedPubkey.toBuffer())
      });
      var instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate an instruction to advance the nonce in a Nonce account
     */
  }, {
    key: "nonceAdvance",
    value: function nonceAdvance(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
      var data = encodeData(type);
      var instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate a transaction instruction that withdraws lamports from a Nonce account
     */
  }, {
    key: "nonceWithdraw",
    value: function nonceWithdraw(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
      var data = encodeData(type, {
        lamports: params.lamports
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that authorizes a new PublicKey as the authority
     * on a Nonce account.
     */
  }, {
    key: "nonceAuthorize",
    value: function nonceAuthorize(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
      var data = encodeData(type, {
        authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that allocates space in an account without funding
     */
  }, {
    key: "allocate",
    value: function allocate(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
        data = encodeData(type, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        var _type3 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
        data = encodeData(_type3, {
          space: params.space
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }
  }]);
  return SystemProgram;
}();
SystemProgram.programId = new PublicKey('11111111111111111111111111111111');

// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
// rest of the Transaction fields
//
// TODO: replace 300 with a proper constant for the size of the other
// Transaction fields
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;

/**
 * Program loader interface
 */
var Loader = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Loader() {
    _classCallCheck(this, Loader);
  }

  /**
   * Amount of program data placed in each load Transaction
   */
  _createClass(Loader, null, [{
    key: "getMinNumSignatures",
    value:
    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    function getMinNumSignatures(dataLength) {
      return 2 * (
      // Every transaction requires two signatures (payer + program)
      Math.ceil(dataLength / Loader.chunkSize) + 1 +
      // Add one for Create transaction
      1) // Add one for Finalize transaction
      ;
    }

    /**
     * Loads a generic program
     *
     * @param connection The connection to use
     * @param payer System account that pays to load the program
     * @param program Account to load the program into
     * @param programId Public key that identifies the loader
     * @param data Program octets
     * @return true if program was loaded successfully, false if program was already loaded
     */
  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, payer, program, programId, data) {
        var balanceNeeded, programInfo, transaction, dataLayout, chunkSize, offset, array, transactions, bytes, _data, _transaction, REQUESTS_PER_SECOND, _dataLayout, _data2, _transaction2, deployCommitment, finalizeSignature, _yield$connection$con, context, value, currentSlot;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getMinimumBalanceForRentExemption(data.length);
            case 2:
              balanceNeeded = _context.sent;
              _context.next = 5;
              return connection.getAccountInfo(program.publicKey, 'confirmed');
            case 5:
              programInfo = _context.sent;
              transaction = null;
              if (!(programInfo !== null)) {
                _context.next = 16;
                break;
              }
              if (!programInfo.executable) {
                _context.next = 11;
                break;
              }
              console.error('Program load failed, account is already executable');
              return _context.abrupt("return", false);
            case 11:
              if (programInfo.data.length !== data.length) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.allocate({
                  accountPubkey: program.publicKey,
                  space: data.length
                }));
              }
              if (!programInfo.owner.equals(programId)) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.assign({
                  accountPubkey: program.publicKey,
                  programId: programId
                }));
              }
              if (programInfo.lamports < balanceNeeded) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.transfer({
                  fromPubkey: payer.publicKey,
                  toPubkey: program.publicKey,
                  lamports: balanceNeeded - programInfo.lamports
                }));
              }
              _context.next = 17;
              break;
            case 16:
              transaction = new Transaction().add(SystemProgram.createAccount({
                fromPubkey: payer.publicKey,
                newAccountPubkey: program.publicKey,
                lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                space: data.length,
                programId: programId
              }));
            case 17:
              if (!(transaction !== null)) {
                _context.next = 20;
                break;
              }
              _context.next = 20;
              return sendAndConfirmTransaction(connection, transaction, [payer, program], {
                commitment: 'confirmed'
              });
            case 20:
              dataLayout = BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.u32('offset'), BufferLayout.u32('bytesLength'), BufferLayout.u32('bytesLengthPadding'), BufferLayout.seq(BufferLayout.u8('byte'), BufferLayout.offset(BufferLayout.u32(), -8), 'bytes')]);
              chunkSize = Loader.chunkSize;
              offset = 0;
              array = data;
              transactions = [];
            case 25:
              if (!(array.length > 0)) {
                _context.next = 39;
                break;
              }
              bytes = array.slice(0, chunkSize);
              _data = Buffer.alloc(chunkSize + 16);
              dataLayout.encode({
                instruction: 0,
                // Load instruction
                offset: offset,
                bytes: bytes,
                bytesLength: 0,
                bytesLengthPadding: 0
              }, _data);
              _transaction = new Transaction().add({
                keys: [{
                  pubkey: program.publicKey,
                  isSigner: true,
                  isWritable: true
                }],
                programId: programId,
                data: _data
              });
              transactions.push(sendAndConfirmTransaction(connection, _transaction, [payer, program], {
                commitment: 'confirmed'
              }));

              // Delay between sends in an attempt to reduce rate limit errors
              if (!connection._rpcEndpoint.includes('solana.com')) {
                _context.next = 35;
                break;
              }
              REQUESTS_PER_SECOND = 4;
              _context.next = 35;
              return sleep(1000 / REQUESTS_PER_SECOND);
            case 35:
              offset += chunkSize;
              array = array.slice(chunkSize);
              _context.next = 25;
              break;
            case 39:
              _context.next = 41;
              return Promise.all(transactions);
            case 41:
              _dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);
              _data2 = Buffer.alloc(_dataLayout.span);
              _dataLayout.encode({
                instruction: 1 // Finalize instruction
              }, _data2);
              _transaction2 = new Transaction().add({
                keys: [{
                  pubkey: program.publicKey,
                  isSigner: true,
                  isWritable: true
                }, {
                  pubkey: SYSVAR_RENT_PUBKEY,
                  isSigner: false,
                  isWritable: false
                }],
                programId: programId,
                data: _data2
              });
              deployCommitment = 'processed';
              _context.next = 48;
              return connection.sendTransaction(_transaction2, [payer, program], {
                preflightCommitment: deployCommitment
              });
            case 48:
              finalizeSignature = _context.sent;
              _context.next = 51;
              return connection.confirmTransaction({
                signature: finalizeSignature,
                lastValidBlockHeight: _transaction2.lastValidBlockHeight,
                blockhash: _transaction2.recentBlockhash
              }, deployCommitment);
            case 51:
              _yield$connection$con = _context.sent;
              context = _yield$connection$con.context;
              value = _yield$connection$con.value;
              if (!value.err) {
                _context.next = 56;
                break;
              }
              throw new Error("Transaction ".concat(finalizeSignature, " failed (").concat(JSON.stringify(value), ")"));
            case 56:
              _context.prev = 57;
              _context.next = 60;
              return connection.getSlot({
                commitment: deployCommitment
              });
            case 60:
              currentSlot = _context.sent;
              if (!(currentSlot > context.slot)) {
                _context.next = 63;
                break;
              }
              return _context.abrupt("break", 71);
            case 63:
              _context.next = 67;
              break;
            case 65:
              _context.prev = 65;
              _context.t0 = _context["catch"](57);
            case 67:
              _context.next = 69;
              return new Promise(function (resolve) {
                return setTimeout(resolve, Math.round(MS_PER_SLOT / 2));
              });
            case 69:
              _context.next = 56;
              break;
            case 71:
              return _context.abrupt("return", true);
            case 72:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[57, 65]]);
      }));
      function load(_x, _x2, _x3, _x4, _x5) {
        return _load.apply(this, arguments);
      }
      return load;
    }()
  }]);
  return Loader;
}();
Loader.chunkSize = CHUNK_SIZE;

var BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');

/**
 * Factory class for transactions to interact with a program loader
 */
var BpfLoader = /*#__PURE__*/function () {
  function BpfLoader() {
    _classCallCheck(this, BpfLoader);
  }
  _createClass(BpfLoader, null, [{
    key: "getMinNumSignatures",
    value:
    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    function getMinNumSignatures(dataLength) {
      return Loader.getMinNumSignatures(dataLength);
    }

    /**
     * Load a SBF program
     *
     * @param connection The connection to use
     * @param payer Account that will pay program loading fees
     * @param program Account to load the program into
     * @param elf The entire ELF containing the SBF program
     * @param loaderProgramId The program id of the BPF loader to use
     * @return true if program was loaded successfully, false if program was already loaded
     */
  }, {
    key: "load",
    value: function load(connection, payer, program, elf, loaderProgramId) {
      return Loader.load(connection, payer, program, loaderProgramId, elf);
    }
  }]);
  return BpfLoader;
}();

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var agentkeepalive = {exports: {}};

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$3 = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/*!
 * humanize-ms - index.js
 * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var util = require$$0;
var ms$2 = ms$3;

var humanizeMs = function (t) {
  if (typeof t === 'number') return t;
  var r = ms$2(t);
  if (r === undefined) {
    var err = new Error(util.format('humanize-ms(%j) result undefined', t));
    console.warn(err.stack);
  }
  return r;
};

var src = {exports: {}};

var browser$1 = {exports: {}};

/**
 * Helpers.
 */

var ms$1;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms$1;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms$1 = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms$1;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			let i;
			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
			const len = split.length;

			for (i = 0; i < len; i++) {
				if (!split[i]) {
					// ignore empty strings
					continue;
				}

				namespaces = split[i].replace(/\*/g, '.*?');

				if (namespaces[0] === '-') {
					createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
				} else {
					createDebug.names.push(new RegExp('^' + namespaces + '$'));
				}
			}
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names.map(toNamespace),
				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === '*') {
				return true;
			}

			let i;
			let len;

			for (i = 0, len = createDebug.skips.length; i < len; i++) {
				if (createDebug.skips[i].test(name)) {
					return false;
				}
			}

			for (i = 0, len = createDebug.names.length; i < len; i++) {
				if (createDebug.names[i].test(name)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString()
				.substring(2, regexp.toString().length - 2)
				.replace(/\.\*\?$/, '*');
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser$1;

function requireBrowser$1 () {
	if (hasRequiredBrowser$1) return browser$1.exports;
	hasRequiredBrowser$1 = 1;
	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug');
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser$1, browser$1.exports));
	return browser$1.exports;
}

var node = {exports: {}};

/* eslint-env browser */

var browser;
var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser;
	hasRequiredBrowser = 1;

	function getChromeVersion() {
		const matches = /(Chrome|Chromium)\/(?<chromeVersion>\d+)\./.exec(navigator.userAgent);

		if (!matches) {
			return;
		}

		return Number.parseInt(matches.groups.chromeVersion, 10);
	}

	const colorSupport = getChromeVersion() >= 69 ? {
		level: 1,
		hasBasic: true,
		has256: false,
		has16m: false
	} : false;

	browser = {
		stdout: colorSupport,
		stderr: colorSupport
	};
	return browser;
}

/**
 * Module dependencies.
 */

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node.exports;
	hasRequiredNode = 1;
	(function (module, exports) {
		const tty = require$$0$1;
		const util = require$$0;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireBrowser();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.format()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.format(...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node, node.exports));
	return node.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	src.exports = requireBrowser$1();
} else {
	src.exports = requireNode();
}

var srcExports = src.exports;

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var relative = require$$0$2.relative;

/**
 * Module exports.
 */

var depd_1 = depd;

/**
 * Get the path to base files on.
 */

var basePath = process.cwd();

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace (str, namespace) {
  var vals = str.split(/[ ,]+/);
  var ns = String(namespace).toLowerCase();

  for (var i = 0; i < vals.length; i++) {
    var val = vals[i];

    // namespace contained
    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true
    }
  }

  return false
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor (obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  var value = descriptor.value;

  descriptor.get = function getter () { return value };

  if (descriptor.writable) {
    descriptor.set = function setter (val) { return (value = val) };
  }

  delete descriptor.value;
  delete descriptor.writable;

  Object.defineProperty(obj, prop, descriptor);

  return descriptor
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString (arity) {
  var str = '';

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i;
  }

  return str.substr(2)
}

/**
 * Create stack string from stack.
 */

function createStackString (stack) {
  var str = this.name + ': ' + this.namespace;

  if (this.message) {
    str += ' deprecated ' + this.message;
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + stack[i].toString();
  }

  return str
}

/**
 * Create deprecate for namespace in caller.
 */

function depd (namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required')
  }

  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  var file = site[0];

  function deprecate (message) {
    // call to self as log
    log.call(deprecate, message);
  }

  deprecate._file = file;
  deprecate._ignored = isignored(namespace);
  deprecate._namespace = namespace;
  deprecate._traced = istraced(namespace);
  deprecate._warned = Object.create(null);

  deprecate.function = wrapfunction;
  deprecate.property = wrapproperty;

  return deprecate
}

/**
 * Determine if event emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function eehaslisteners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type);

  return count > 0
}

/**
 * Determine if namespace is ignored.
 */

function isignored (namespace) {
  if (process.noDeprecation) {
    // --no-deprecation support
    return true
  }

  var str = process.env.NO_DEPRECATION || '';

  // namespace ignored
  return containsNamespace(str, namespace)
}

/**
 * Determine if namespace is traced.
 */

function istraced (namespace) {
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true
  }

  var str = process.env.TRACE_DEPRECATION || '';

  // namespace traced
  return containsNamespace(str, namespace)
}

/**
 * Display deprecation message.
 */

function log (message, site) {
  var haslisteners = eehaslisteners(process, 'deprecation');

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return
  }

  var caller;
  var callFile;
  var callSite;
  var depSite;
  var i = 0;
  var seen = false;
  var stack = getStack();
  var file = this._file;

  if (site) {
    // provided site
    depSite = site;
    callSite = callSiteLocation(stack[1]);
    callSite.name = depSite.name;
    file = callSite[0];
  } else {
    // get call site
    i = 2;
    depSite = callSiteLocation(stack[i]);
    callSite = depSite;
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i]);
    callFile = caller[0];

    if (callFile === file) {
      seen = true;
    } else if (callFile === this._file) {
      file = this._file;
    } else if (seen) {
      break
    }
  }

  var key = caller
    ? depSite.join(':') + '__' + caller.join(':')
    : undefined;

  if (key !== undefined && key in this._warned) {
    // already warned
    return
  }

  this._warned[key] = true;

  // generate automatic message from call site
  var msg = message;
  if (!msg) {
    msg = callSite === depSite || !callSite.name
      ? defaultMessage(depSite)
      : defaultMessage(callSite);
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i));
    process.emit('deprecation', err);
    return
  }

  // format and write message
  var format = process.stderr.isTTY
    ? formatColor
    : formatPlain;
  var output = format.call(this, msg, caller, stack.slice(i));
  process.stderr.write(output + '\n', 'utf8');
}

/**
 * Get call site location as array.
 */

function callSiteLocation (callSite) {
  var file = callSite.getFileName() || '<anonymous>';
  var line = callSite.getLineNumber();
  var colm = callSite.getColumnNumber();

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file;
  }

  var site = [file, line, colm];

  site.callSite = callSite;
  site.name = callSite.getFunctionName();

  return site
}

/**
 * Generate a default message from the site.
 */

function defaultMessage (site) {
  var callSite = site.callSite;
  var funcName = site.name;

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation(site) + '>';
  }

  var context = callSite.getThis();
  var typeName = context && callSite.getTypeName();

  // ignore useless type name
  if (typeName === 'Object') {
    typeName = undefined;
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = context.name || typeName;
  }

  return typeName && callSite.getMethodName()
    ? typeName + '.' + funcName
    : funcName
}

/**
 * Format deprecation message without color.
 */

function formatPlain (msg, caller, stack) {
  var timestamp = new Date().toUTCString();

  var formatted = timestamp +
    ' ' + this._namespace +
    ' deprecated ' + msg;

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + stack[i].toString();
    }

    return formatted
  }

  if (caller) {
    formatted += ' at ' + formatLocation(caller);
  }

  return formatted
}

/**
 * Format deprecation message with color.
 */

function formatColor (msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m'; // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m'; // cyan
    }

    return formatted
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m'; // cyan
  }

  return formatted
}

/**
 * Format call site location.
 */

function formatLocation (callSite) {
  return relative(basePath, callSite[0]) +
    ':' + callSite[1] +
    ':' + callSite[2]
}

/**
 * Get the stack as array of call sites.
 */

function getStack () {
  var limit = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;

  Error.prepareStackTrace = prepareObjectStackTrace;
  Error.stackTraceLimit = Math.max(10, limit);

  // capture the stack
  Error.captureStackTrace(obj);

  // slice this function off the top
  var stack = obj.stack.slice(1);

  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit;

  return stack
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace (obj, stack) {
  return stack
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction (fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function')
  }

  var args = createArgumentsString(fn.length);
  var stack = getStack();
  var site = callSiteLocation(stack[1]);

  site.name = fn.name;

  // eslint-disable-next-line no-new-func
  var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site',
    '"use strict"\n' +
    'return function (' + args + ') {' +
    'log.call(deprecate, message, site)\n' +
    'return fn.apply(this, arguments)\n' +
    '}')(fn, log, this, message, site);

  return deprecatedfn
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty (obj, prop, message) {
  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
    throw new TypeError('argument obj must be object')
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

  if (!descriptor) {
    throw new TypeError('must call property on owner object')
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable')
  }

  var deprecate = this;
  var stack = getStack();
  var site = callSiteLocation(stack[1]);

  // set site name
  site.name = prop;

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop);
  }

  var get = descriptor.get;
  var set = descriptor.set;

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter () {
      log.call(deprecate, message, site);
      return get.apply(this, arguments)
    };
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter () {
      log.call(deprecate, message, site);
      return set.apply(this, arguments)
    };
  }

  Object.defineProperty(obj, prop, descriptor);
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError (namespace, message, stack) {
  var error = new Error();
  var stackString;

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError
  });

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  });

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  });

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  });

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString
      }

      // prepare stack trace
      return (stackString = createStackString.call(this, stack))
    },
    set: function setter (val) {
      stackString = val;
    }
  });

  return error
}

var constants = {
  // agent
  CURRENT_ID: Symbol('agentkeepalive#currentId'),
  CREATE_ID: Symbol('agentkeepalive#createId'),
  INIT_SOCKET: Symbol('agentkeepalive#initSocket'),
  CREATE_HTTPS_CONNECTION: Symbol('agentkeepalive#createHttpsConnection'),
  // socket
  SOCKET_CREATED_TIME: Symbol('agentkeepalive#socketCreatedTime'),
  SOCKET_NAME: Symbol('agentkeepalive#socketName'),
  SOCKET_REQUEST_COUNT: Symbol('agentkeepalive#socketRequestCount'),
  SOCKET_REQUEST_FINISHED_COUNT: Symbol('agentkeepalive#socketRequestFinishedCount'),
};

const OriginalAgent = require$$0$3.Agent;
const ms = humanizeMs;
const debug = srcExports('agentkeepalive');
const deprecate = depd_1('agentkeepalive');
const {
  INIT_SOCKET: INIT_SOCKET$1,
  CURRENT_ID,
  CREATE_ID,
  SOCKET_CREATED_TIME,
  SOCKET_NAME,
  SOCKET_REQUEST_COUNT,
  SOCKET_REQUEST_FINISHED_COUNT,
} = constants;

// OriginalAgent come from
// - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js
// - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js

// node <= 10
let defaultTimeoutListenerCount = 1;
const majorVersion = parseInt(process.version.split('.', 1)[0].substring(1));
if (majorVersion >= 11 && majorVersion <= 12) {
  defaultTimeoutListenerCount = 2;
} else if (majorVersion >= 13) {
  defaultTimeoutListenerCount = 3;
}

class Agent extends OriginalAgent {
  constructor(options) {
    options = options || {};
    options.keepAlive = options.keepAlive !== false;
    // default is keep-alive and 4s free socket timeout
    // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83
    if (options.freeSocketTimeout === undefined) {
      options.freeSocketTimeout = 4000;
    }
    // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`
    if (options.keepAliveTimeout) {
      deprecate('options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');
      options.freeSocketTimeout = options.keepAliveTimeout;
      delete options.keepAliveTimeout;
    }
    // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`
    if (options.freeSocketKeepAliveTimeout) {
      deprecate('options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');
      options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
      delete options.freeSocketKeepAliveTimeout;
    }

    // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.
    // By default is double free socket timeout.
    if (options.timeout === undefined) {
      // make sure socket default inactivity timeout >= 8s
      options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);
    }

    // support humanize format
    options.timeout = ms(options.timeout);
    options.freeSocketTimeout = ms(options.freeSocketTimeout);
    options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;

    super(options);

    this[CURRENT_ID] = 0;

    // create socket success counter
    this.createSocketCount = 0;
    this.createSocketCountLastCheck = 0;

    this.createSocketErrorCount = 0;
    this.createSocketErrorCountLastCheck = 0;

    this.closeSocketCount = 0;
    this.closeSocketCountLastCheck = 0;

    // socket error event count
    this.errorSocketCount = 0;
    this.errorSocketCountLastCheck = 0;

    // request finished counter
    this.requestCount = 0;
    this.requestCountLastCheck = 0;

    // including free socket timeout counter
    this.timeoutSocketCount = 0;
    this.timeoutSocketCountLastCheck = 0;

    this.on('free', socket => {
      // https://github.com/nodejs/node/pull/32000
      // Node.js native agent will check socket timeout eqs agent.options.timeout.
      // Use the ttl or freeSocketTimeout to overwrite.
      const timeout = this.calcSocketTimeout(socket);
      if (timeout > 0 && socket.timeout !== timeout) {
        socket.setTimeout(timeout);
      }
    });
  }

  get freeSocketKeepAliveTimeout() {
    deprecate('agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead');
    return this.options.freeSocketTimeout;
  }

  get timeout() {
    deprecate('agent.timeout is deprecated, please use agent.options.timeout instead');
    return this.options.timeout;
  }

  get socketActiveTTL() {
    deprecate('agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead');
    return this.options.socketActiveTTL;
  }

  calcSocketTimeout(socket) {
    /**
     * return <= 0: should free socket
     * return > 0: should update socket timeout
     * return undefined: not find custom timeout
     */
    let freeSocketTimeout = this.options.freeSocketTimeout;
    const socketActiveTTL = this.options.socketActiveTTL;
    if (socketActiveTTL) {
      // check socketActiveTTL
      const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
      const diff = socketActiveTTL - aliveTime;
      if (diff <= 0) {
        return diff;
      }
      if (freeSocketTimeout && diff < freeSocketTimeout) {
        freeSocketTimeout = diff;
      }
    }
    // set freeSocketTimeout
    if (freeSocketTimeout) {
      // set free keepalive timer
      // try to use socket custom freeSocketTimeout first, support headers['keep-alive']
      // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498
      const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
      return customFreeSocketTimeout || freeSocketTimeout;
    }
  }

  keepSocketAlive(socket) {
    const result = super.keepSocketAlive(socket);
    // should not keepAlive, do nothing
    if (!result) return result;

    const customTimeout = this.calcSocketTimeout(socket);
    if (typeof customTimeout === 'undefined') {
      return true;
    }
    if (customTimeout <= 0) {
      debug('%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s',
        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);
      return false;
    }
    if (socket.timeout !== customTimeout) {
      socket.setTimeout(customTimeout);
    }
    return true;
  }

  // only call on addRequest
  reuseSocket(...args) {
    // reuseSocket(socket, req)
    super.reuseSocket(...args);
    const socket = args[0];
    const req = args[1];
    req.reusedSocket = true;
    const agentTimeout = this.options.timeout;
    if (getSocketTimeout(socket) !== agentTimeout) {
      // reset timeout before use
      socket.setTimeout(agentTimeout);
      debug('%s reset timeout to %sms', socket[SOCKET_NAME], agentTimeout);
    }
    socket[SOCKET_REQUEST_COUNT]++;
    debug('%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms',
      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],
      getSocketTimeout(socket));
  }

  [CREATE_ID]() {
    const id = this[CURRENT_ID]++;
    if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;
    return id;
  }

  [INIT_SOCKET$1](socket, options) {
    // bugfix here.
    // https on node 8, 10 won't set agent.options.timeout by default
    // TODO: need to fix on node itself
    if (options.timeout) {
      const timeout = getSocketTimeout(socket);
      if (!timeout) {
        socket.setTimeout(options.timeout);
      }
    }

    if (this.options.keepAlive) {
      // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/
      // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html
      socket.setNoDelay(true);
    }
    this.createSocketCount++;
    if (this.options.socketActiveTTL) {
      socket[SOCKET_CREATED_TIME] = Date.now();
    }
    // don't show the hole '-----BEGIN CERTIFICATE----' key string
    socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split('-----BEGIN', 1)[0];
    socket[SOCKET_REQUEST_COUNT] = 1;
    socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
    installListeners(this, socket, options);
  }

  createConnection(options, oncreate) {
    let called = false;
    const onNewCreate = (err, socket) => {
      if (called) return;
      called = true;

      if (err) {
        this.createSocketErrorCount++;
        return oncreate(err);
      }
      this[INIT_SOCKET$1](socket, options);
      oncreate(err, socket);
    };

    const newSocket = super.createConnection(options, onNewCreate);
    if (newSocket) onNewCreate(null, newSocket);
  }

  get statusChanged() {
    const changed = this.createSocketCount !== this.createSocketCountLastCheck ||
      this.createSocketErrorCount !== this.createSocketErrorCountLastCheck ||
      this.closeSocketCount !== this.closeSocketCountLastCheck ||
      this.errorSocketCount !== this.errorSocketCountLastCheck ||
      this.timeoutSocketCount !== this.timeoutSocketCountLastCheck ||
      this.requestCount !== this.requestCountLastCheck;
    if (changed) {
      this.createSocketCountLastCheck = this.createSocketCount;
      this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
      this.closeSocketCountLastCheck = this.closeSocketCount;
      this.errorSocketCountLastCheck = this.errorSocketCount;
      this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
      this.requestCountLastCheck = this.requestCount;
    }
    return changed;
  }

  getCurrentStatus() {
    return {
      createSocketCount: this.createSocketCount,
      createSocketErrorCount: this.createSocketErrorCount,
      closeSocketCount: this.closeSocketCount,
      errorSocketCount: this.errorSocketCount,
      timeoutSocketCount: this.timeoutSocketCount,
      requestCount: this.requestCount,
      freeSockets: inspect(this.freeSockets),
      sockets: inspect(this.sockets),
      requests: inspect(this.requests),
    };
  }
}

// node 8 don't has timeout attribute on socket
// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408
function getSocketTimeout(socket) {
  return socket.timeout || socket._idleTimeout;
}

function installListeners(agent, socket, options) {
  debug('%s create, timeout %sms', socket[SOCKET_NAME], getSocketTimeout(socket));

  // listener socket events: close, timeout, error, free
  function onFree() {
    // create and socket.emit('free') logic
    // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311
    // no req on the socket, it should be the new socket
    if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;

    socket[SOCKET_REQUEST_FINISHED_COUNT]++;
    agent.requestCount++;
    debug('%s(requests: %s, finished: %s) free',
      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);

    // should reuse on pedding requests?
    const name = agent.getName(options);
    if (socket.writable && agent.requests[name] && agent.requests[name].length) {
      // will be reuse on agent free listener
      socket[SOCKET_REQUEST_COUNT]++;
      debug('%s(requests: %s, finished: %s) will be reuse on agent free event',
        socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
    }
  }
  socket.on('free', onFree);

  function onClose(isError) {
    debug('%s(requests: %s, finished: %s) close, isError: %s',
      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);
    agent.closeSocketCount++;
  }
  socket.on('close', onClose);

  // start socket timeout handler
  function onTimeout() {
    // onTimeout and emitRequestTimeout(_http_client.js)
    // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711
    const listenerCount = socket.listeners('timeout').length;
    // node <= 10, default listenerCount is 1, onTimeout
    // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout
    // node >= 13, default listenerCount is 3, onTimeout,
    //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)
    //   and emitRequestTimeout
    const timeout = getSocketTimeout(socket);
    const req = socket._httpMessage;
    const reqTimeoutListenerCount = req && req.listeners('timeout').length || 0;
    debug('%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s',
      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],
      timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);
    if (debug.enabled) {
      debug('timeout listeners: %s', socket.listeners('timeout').map(f => f.name).join(', '));
    }
    agent.timeoutSocketCount++;
    const name = agent.getName(options);
    if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
      // free socket timeout, destroy quietly
      socket.destroy();
      // Remove it from freeSockets list immediately to prevent new requests
      // from being sent through this socket.
      agent.removeSocket(socket, options);
      debug('%s is free, destroy quietly', socket[SOCKET_NAME]);
    } else {
      // if there is no any request socket timeout handler,
      // agent need to handle socket timeout itself.
      //
      // custom request socket timeout handle logic must follow these rules:
      //  1. Destroy socket first
      //  2. Must emit socket 'agentRemove' event tell agent remove socket
      //     from freeSockets list immediately.
      //     Otherise you may be get 'socket hang up' error when reuse
      //     free socket and timeout happen in the same time.
      if (reqTimeoutListenerCount === 0) {
        const error = new Error('Socket timeout');
        error.code = 'ERR_SOCKET_TIMEOUT';
        error.timeout = timeout;
        // must manually call socket.end() or socket.destroy() to end the connection.
        // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback
        socket.destroy(error);
        agent.removeSocket(socket, options);
        debug('%s destroy with timeout error', socket[SOCKET_NAME]);
      }
    }
  }
  socket.on('timeout', onTimeout);

  function onError(err) {
    const listenerCount = socket.listeners('error').length;
    debug('%s(requests: %s, finished: %s) error: %s, listenerCount: %s',
      socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT],
      err, listenerCount);
    agent.errorSocketCount++;
    if (listenerCount === 1) {
      // if socket don't contain error event handler, don't catch it, emit it again
      debug('%s emit uncaught error event', socket[SOCKET_NAME]);
      socket.removeListener('error', onError);
      socket.emit('error', err);
    }
  }
  socket.on('error', onError);

  function onRemove() {
    debug('%s(requests: %s, finished: %s) agentRemove',
      socket[SOCKET_NAME],
      socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
    // We need this function for cases like HTTP 'upgrade'
    // (defined by WebSockets) where we need to remove a socket from the
    // pool because it'll be locked up indefinitely
    socket.removeListener('close', onClose);
    socket.removeListener('error', onError);
    socket.removeListener('free', onFree);
    socket.removeListener('timeout', onTimeout);
    socket.removeListener('agentRemove', onRemove);
  }
  socket.on('agentRemove', onRemove);
}

var agent = Agent;

function inspect(obj) {
  const res = {};
  for (const key in obj) {
    res[key] = obj[key].length;
  }
  return res;
}

const OriginalHttpsAgent = require$$0$4.Agent;
const HttpAgent = agent;
const {
  INIT_SOCKET,
  CREATE_HTTPS_CONNECTION,
} = constants;

let HttpsAgent$1 = class HttpsAgent extends HttpAgent {
  constructor(options) {
    super(options);

    this.defaultPort = 443;
    this.protocol = 'https:';
    this.maxCachedSessions = this.options.maxCachedSessions;
    /* istanbul ignore next */
    if (this.maxCachedSessions === undefined) {
      this.maxCachedSessions = 100;
    }

    this._sessionCache = {
      map: {},
      list: [],
    };
  }

  createConnection(options) {
    const socket = this[CREATE_HTTPS_CONNECTION](options);
    this[INIT_SOCKET](socket, options);
    return socket;
  }
};

// https://github.com/nodejs/node/blob/master/lib/https.js#L89
HttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;

[
  'getName',
  '_getSession',
  '_cacheSession',
  // https://github.com/nodejs/node/pull/4982
  '_evictSession',
].forEach(function(method) {
  /* istanbul ignore next */
  if (typeof OriginalHttpsAgent.prototype[method] === 'function') {
    HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method];
  }
});

var https_agent = HttpsAgent$1;

agentkeepalive.exports = agent;
var HttpsAgent = agentkeepalive.exports.HttpsAgent = https_agent;
agentkeepalive.exports.constants = constants;

var agentkeepaliveExports = agentkeepalive.exports;
var HttpKeepAliveAgent = /*@__PURE__*/getDefaultExportFromCjs(agentkeepaliveExports);

var objToString = Object.prototype.toString;
var objKeys = Object.keys || function(obj) {
		var keys = [];
		for (var name in obj) {
			keys.push(name);
		}
		return keys;
	};

function stringify(val, isArrayProp) {
	var i, max, str, keys, key, propVal, toStr;
	if (val === true) {
		return "true";
	}
	if (val === false) {
		return "false";
	}
	switch (typeof val) {
		case "object":
			if (val === null) {
				return null;
			} else if (val.toJSON && typeof val.toJSON === "function") {
				return stringify(val.toJSON(), isArrayProp);
			} else {
				toStr = objToString.call(val);
				if (toStr === "[object Array]") {
					str = '[';
					max = val.length - 1;
					for(i = 0; i < max; i++) {
						str += stringify(val[i], true) + ',';
					}
					if (max > -1) {
						str += stringify(val[i], true);
					}
					return str + ']';
				} else if (toStr === "[object Object]") {
					// only object is left
					keys = objKeys(val).sort();
					max = keys.length;
					str = "";
					i = 0;
					while (i < max) {
						key = keys[i];
						propVal = stringify(val[key], false);
						if (propVal !== undefined) {
							if (str) {
								str += ',';
							}
							str += JSON.stringify(key) + ':' + propVal;
						}
						i++;
					}
					return '{' + str + '}';
				} else {
					return JSON.stringify(val);
				}
			}
		case "function":
		case "undefined":
			return isArrayProp ? null : undefined;
		case "string":
			return JSON.stringify(val);
		default:
			return isFinite(val) ? val : null;
	}
}

var fastStableStringify = function(val) {
	var returnVal = stringify(val, false);
	if (returnVal !== undefined) {
		return ''+ returnVal;
	}
};

var fastStableStringify$1 = /*@__PURE__*/getDefaultExportFromCjs(fastStableStringify);

var MINIMUM_SLOT_PER_EPOCH = 32;

// Returns the number of trailing zeros in the binary representation of self.
function trailingZeros(n) {
  var trailingZeros = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros++;
  }
  return trailingZeros;
}

// Returns the smallest power of two greater than or equal to n
function nextPowerOfTwo(n) {
  if (n === 0) return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}

/**
 * Epoch schedule
 * (see https://docs.solana.com/terminology#epoch)
 * Can be retrieved with the {@link Connection.getEpochSchedule} method
 */
var EpochSchedule = /*#__PURE__*/function () {
  function EpochSchedule(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    _classCallCheck(this, EpochSchedule);
    /** The maximum number of slots in each epoch */
    this.slotsPerEpoch = void 0;
    /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */
    this.leaderScheduleSlotOffset = void 0;
    /** Indicates whether epochs start short and grow */
    this.warmup = void 0;
    /** The first epoch with `slotsPerEpoch` slots */
    this.firstNormalEpoch = void 0;
    /** The first slot of `firstNormalEpoch` */
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  _createClass(EpochSchedule, [{
    key: "getEpoch",
    value: function getEpoch(slot) {
      return this.getEpochAndSlotIndex(slot)[0];
    }
  }, {
    key: "getEpochAndSlotIndex",
    value: function getEpochAndSlotIndex(slot) {
      if (slot < this.firstNormalSlot) {
        var epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
        var epochLen = this.getSlotsInEpoch(epoch);
        var slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
        return [epoch, slotIndex];
      } else {
        var normalSlotIndex = slot - this.firstNormalSlot;
        var normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
        var _epoch = this.firstNormalEpoch + normalEpochIndex;
        var _slotIndex = normalSlotIndex % this.slotsPerEpoch;
        return [_epoch, _slotIndex];
      }
    }
  }, {
    key: "getFirstSlotInEpoch",
    value: function getFirstSlotInEpoch(epoch) {
      if (epoch <= this.firstNormalEpoch) {
        return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
      } else {
        return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
      }
    }
  }, {
    key: "getLastSlotInEpoch",
    value: function getLastSlotInEpoch(epoch) {
      return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
    }
  }, {
    key: "getSlotsInEpoch",
    value: function getSlotsInEpoch(epoch) {
      if (epoch < this.firstNormalEpoch) {
        return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
      } else {
        return this.slotsPerEpoch;
      }
    }
  }]);
  return EpochSchedule;
}();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var SendTransactionError = /*#__PURE__*/function (_Error) {
  _inherits(SendTransactionError, _Error);
  var _super = _createSuper$1(SendTransactionError);
  function SendTransactionError(message, logs) {
    var _this;
    _classCallCheck(this, SendTransactionError);
    _this = _super.call(this, message);
    _this.logs = void 0;
    _this.logs = logs;
    return _this;
  }
  return _createClass(SendTransactionError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

// Keep in sync with client/src/rpc_custom_errors.rs
// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
var SolanaJSONRPCErrorCode = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
var SolanaJSONRPCError = /*#__PURE__*/function (_Error2) {
  _inherits(SolanaJSONRPCError, _Error2);
  var _super2 = _createSuper$1(SolanaJSONRPCError);
  function SolanaJSONRPCError(_ref, customMessage) {
    var _this2;
    var code = _ref.code,
      message = _ref.message,
      data = _ref.data;
    _classCallCheck(this, SolanaJSONRPCError);
    _this2 = _super2.call(this, customMessage != null ? "".concat(customMessage, ": ").concat(message) : message);
    _this2.code = void 0;
    _this2.data = void 0;
    _this2.code = code;
    _this2.data = data;
    _this2.name = 'SolanaJSONRPCError';
    return _this2;
  }
  return _createClass(SolanaJSONRPCError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

var fetchImpl = typeof globalThis.fetch === 'function' ?
// The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.
globalThis.fetch :
/*#__PURE__*/
// Otherwise use the polyfill.
function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input, init) {
    var processedInput;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          processedInput = typeof input === 'string' && input.slice(0, 2) === '//' ? 'https:' + input : input;
          _context.next = 3;
          return nodeFetch["default"](processedInput, init);
        case 3:
          return _context.abrupt("return", _context.sent);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var RpcWebSocketClient = /*#__PURE__*/function (_RpcWebSocketCommonCl) {
  _inherits(RpcWebSocketClient, _RpcWebSocketCommonCl);
  var _super = _createSuper(RpcWebSocketClient);
  function RpcWebSocketClient(address, options, generate_request_id) {
    var _this;
    _classCallCheck(this, RpcWebSocketClient);
    var webSocketFactory = function webSocketFactory(url) {
      var rpc = WebsocketFactory(url, _objectSpread$1({
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1000
      }, options));
      if ('socket' in rpc) {
        _this.underlyingSocket = rpc.socket;
      } else {
        _this.underlyingSocket = rpc;
      }
      return rpc;
    };
    _this = _super.call(this, webSocketFactory, address, options, generate_request_id);
    _this.underlyingSocket = void 0;
    return _this;
  }
  _createClass(RpcWebSocketClient, [{
    key: "call",
    value: function call() {
      var _this$underlyingSocke;
      var readyState = (_this$underlyingSocke = this.underlyingSocket) === null || _this$underlyingSocke === void 0 ? void 0 : _this$underlyingSocke.readyState;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (readyState === 1 /* WebSocket.OPEN */) {
        var _get2;
        return (_get2 = _get(_getPrototypeOf(RpcWebSocketClient.prototype), "call", this)).call.apply(_get2, [this].concat(args));
      }
      return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
    }
  }, {
    key: "notify",
    value: function notify() {
      var _this$underlyingSocke2;
      var readyState = (_this$underlyingSocke2 = this.underlyingSocket) === null || _this$underlyingSocke2 === void 0 ? void 0 : _this$underlyingSocke2.readyState;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      if (readyState === 1 /* WebSocket.OPEN */) {
        var _get3;
        return (_get3 = _get(_getPrototypeOf(RpcWebSocketClient.prototype), "notify", this)).call.apply(_get3, [this].concat(args));
      }
      return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
    }
  }]);
  return RpcWebSocketClient;
}(RpcWebSocketCommonClient);

/**
 * @internal
 */

/**
 * Decode account data buffer using an AccountType
 * @internal
 */
function decodeData(type, data) {
  var decoded;
  try {
    decoded = type.layout.decode(data);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }
  if (decoded.typeIndex !== type.index) {
    throw new Error("invalid account data; account type mismatch ".concat(decoded.typeIndex, " != ").concat(type.index));
  }
  return decoded;
}

/// The serialized size of lookup table metadata
var LOOKUP_TABLE_META_SIZE = 56;
var AddressLookupTableAccount = /*#__PURE__*/function () {
  function AddressLookupTableAccount(args) {
    _classCallCheck(this, AddressLookupTableAccount);
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }
  _createClass(AddressLookupTableAccount, [{
    key: "isActive",
    value: function isActive() {
      var U64_MAX = BigInt('0xffffffffffffffff');
      return this.state.deactivationSlot === U64_MAX;
    }
  }], [{
    key: "deserialize",
    value: function deserialize(accountData) {
      var meta = decodeData(LookupTableMetaLayout, accountData);
      var serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
      assert(serializedAddressesLen >= 0, 'lookup table is invalid');
      assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');
      var numSerializedAddresses = serializedAddressesLen / 32;
      var _BufferLayout$struct$ = BufferLayout.struct([BufferLayout.seq(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE)),
        addresses = _BufferLayout$struct$.addresses;
      return {
        deactivationSlot: meta.deactivationSlot,
        lastExtendedSlot: meta.lastExtendedSlot,
        lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
        authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
        addresses: addresses.map(function (address) {
          return new PublicKey(address);
        })
      };
    }
  }]);
  return AddressLookupTableAccount;
}();
var LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout.struct([BufferLayout.u32('typeIndex'), u64('deactivationSlot'), BufferLayout.nu64('lastExtendedSlot'), BufferLayout.u8('lastExtendedStartIndex'), BufferLayout.u8(),
  // option
  BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), 'authority')])
};

var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint) {
  var matches = endpoint.match(URL_RE);
  if (matches == null) {
    throw TypeError("Failed to validate endpoint URL `".concat(endpoint, "`"));
  }
  var _matches = _slicedToArray(matches, 4);
    _matches[0];
    var // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish = _matches[1],
    portWithColon = _matches[2],
    rest = _matches[3];
  var protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';
  var startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  var websocketPort =
  // Only shift the port by +1 as a convention for ws(s) only if given endpoint
  // is explictly specifying the endpoint port (HTTP-based RPC), assuming
  // we're directly trying to connect to solana-validator's ws listening port.
  // When the endpoint omits the port, we're connecting to the protocol
  // default ports: http(80) or https(443) and it's assumed we're behind a reverse
  // proxy which manages WebSocket upgrade and backend port redirection.
  startPort == null ? '' : ":".concat(startPort + 1);
  return "".concat(protocol, "//").concat(hostish).concat(websocketPort).concat(rest);
}

var _process$env$npm_pack;
var _excluded = ["commitment"],
  _excluded2 = ["encoding"],
  _excluded3 = ["commitment"],
  _excluded4 = ["commitment"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var PublicKeyFromString = coerce(instance(PublicKey), string(), function (value) {
  return new PublicKey(value);
});
var RawAccountDataResult = tuple([string(), literal('base64')]);
var BufferFromRawAccountData = coerce(instance(Buffer), RawAccountDataResult, function (value) {
  return Buffer.from(value[0], 'base64');
});

/**
 * Attempt to use a recent blockhash for up to 30 seconds
 * @internal
 */
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;

/**
 * HACK.
 * Copied from rpc-websockets/dist/lib/client.
 * Otherwise, `yarn build` fails with:
 * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
 */

/** @internal */
/** @internal */
/** @internal */
/** @internal */

/** @internal */
/**
 * @internal
 * Every subscription contains the args used to open the subscription with
 * the server, and a list of callers interested in notifications.
 */

/**
 * @internal
 * A subscription may be in various states of connectedness. Only when it is
 * fully connected will it have a server subscription id associated with it.
 * This id can be returned to the server to unsubscribe the client entirely.
 */

/**
 * A type that encapsulates a subscription's RPC method
 * names and notification (callback) signature.
 */

/**
 * @internal
 * Utility type that keeps tagged unions intact while omitting properties.
 */

/**
 * @internal
 * This type represents a single subscribable 'topic.' It's made up of:
 *
 * - The args used to open the subscription with the server,
 * - The state of the subscription, in terms of its connectedness, and
 * - The set of callbacks to call when the server publishes notifications
 *
 * This record gets indexed by `SubscriptionConfigHash` and is used to
 * set up subscriptions, fan out notifications, and track subscription state.
 */

/**
 * @internal
 */

/**
 * Extra contextual information for RPC responses
 */

/**
 * Options for sending transactions
 */

/**
 * Options for confirming transactions
 */

/**
 * Options for getConfirmedSignaturesForAddress2
 */

/**
 * Options for getSignaturesForAddress
 */

/**
 * RPC Response with extra contextual information
 */

/**
 * A strategy for confirming transactions that uses the last valid
 * block height for a given blockhash to check for transaction expiration.
 */

/**
 * A strategy for confirming durable nonce transactions.
 */

/**
 * Properties shared by all transaction confirmation strategies
 */

/**
 * This type represents all transaction confirmation strategies
 */

/* @internal */
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  }
  return putativeUrl;
}

/** @internal */
function extractCommitmentFromConfig(commitmentOrConfig) {
  var commitment;
  var config;
  if (typeof commitmentOrConfig === 'string') {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    var specifiedCommitment = commitmentOrConfig.commitment,
      specifiedConfig = _objectWithoutProperties(commitmentOrConfig, _excluded);
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment: commitment,
    config: config
  };
}

/**
 * @internal
 */
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal('2.0'),
    id: string(),
    result: result
  }), type({
    jsonrpc: literal('2.0'),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult = createRpcResult(unknown());

/**
 * @internal
 */
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, function (value) {
    if ('error' in value) {
      return value;
    } else {
      return _objectSpread(_objectSpread({}, value), {}, {
        result: create(value.result, schema)
      });
    }
  });
}

/**
 * @internal
 */
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value: value
  }));
}

/**
 * @internal
 */
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number()
    }),
    value: value
  });
}

/**
 * @internal
 */
function versionedMessageFromResponse(version, response) {
  if (version === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map(function (accountKey) {
        return new PublicKey(accountKey);
      }),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: bs58.decode(ix.data)
        };
      }),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}

/**
 * The level of commitment desired when querying state
 * <pre>
 *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */

// Deprecated as of v1.5.5
/**
 * A subset of Commitment levels, which are at least optimistically confirmed
 * <pre>
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */
/**
 * Filter for largest accounts query
 * <pre>
 *   'circulating':    Return the largest accounts that are part of the circulating supply
 *   'nonCirculating': Return the largest accounts that are not part of the circulating supply
 * </pre>
 */
/**
 * Configuration object for changing `getAccountInfo` query behavior
 */
/**
 * Configuration object for changing `getBalance` query behavior
 */
/**
 * Configuration object for changing `getBlock` query behavior
 */
/**
 * Configuration object for changing `getBlock` query behavior
 */
/**
 * Configuration object for changing `getStakeMinimumDelegation` query behavior
 */
/**
 * Configuration object for changing `getBlockHeight` query behavior
 */
/**
 * Configuration object for changing `getEpochInfo` query behavior
 */
/**
 * Configuration object for changing `getInflationReward` query behavior
 */
/**
 * Configuration object for changing `getLatestBlockhash` query behavior
 */
/**
 * Configuration object for changing `isBlockhashValid` query behavior
 */
/**
 * Configuration object for changing `getSlot` query behavior
 */
/**
 * Configuration object for changing `getSlotLeader` query behavior
 */
/**
 * Configuration object for changing `getTransaction` query behavior
 */
/**
 * Configuration object for changing `getTransaction` query behavior
 */
/**
 * Configuration object for changing `getLargestAccounts` query behavior
 */
/**
 * Configuration object for changing `getSupply` request behavior
 */
/**
 * Configuration object for changing query behavior
 */
/**
 * Information describing a cluster node
 */
/**
 * Information describing a vote account
 */
/**
 * A collection of cluster vote accounts
 */
/**
 * Network Inflation
 * (see https://docs.solana.com/implemented-proposals/ed_overview)
 */
var GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});

/**
 * The inflation reward for an epoch
 */

/**
 * Expected JSON RPC response for the "getInflationReward" message
 */
var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));

/**
 * Configuration object for changing `getRecentPrioritizationFees` query behavior
 */

/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */
var GetRecentPrioritizationFeesResult = array(type({
  slot: number(),
  prioritizationFee: number()
}));
/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
var GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
});

/**
 * Information about the current epoch
 */

var GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
var GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});

/**
 * Leader schedule
 * (see https://docs.solana.com/terminology#leader-schedule)
 */

var GetLeaderScheduleResult = record(string(), array(number()));

/**
 * Transaction error or null
 */
var TransactionErrorResult = nullable(union([type({}), string()]));

/**
 * Signature status for a transaction
 */
var SignatureStatusResult = type({
  err: TransactionErrorResult
});

/**
 * Transaction signature received notification
 */
var SignatureReceivedResult = literal('receivedSignature');

/**
 * Version info for a node
 */

var VersionResult = type({
  'solana-core': string(),
  'feature-set': optional(number())
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal('base64')])
  })))
}));

/**
 * Metadata for a parsed confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.
 */

/**
 * Collection of addresses loaded by a transaction using address table lookups
 */

/**
 * Metadata for a parsed transaction on the ledger
 */

/**
 * Metadata for a confirmed transaction on the ledger
 */

/**
 * A processed transaction from the RPC API
 */

/**
 * A processed transaction from the RPC API
 */

/**
 * A processed transaction message from the RPC API
 */

/**
 * A confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * A partially decoded transaction instruction
 */

/**
 * A parsed transaction message account
 */

/**
 * A parsed transaction instruction
 */

/**
 * A parsed address table lookup
 */

/**
 * A parsed transaction message
 */

/**
 * A parsed transaction
 */

/**
 * A parsed and confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.
 */

/**
 * A parsed transaction on the ledger with meta
 */

/**
 * A processed block fetched from the RPC API
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`
 */

/**
 * A block with parsed transactions
 */

/**
 * A block with parsed transactions where the `transactionDetails` mode is `accounts`
 */

/**
 * A block with parsed transactions where the `transactionDetails` mode is `none`
 */

/**
 * A processed block fetched from the RPC API
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`
 */

/**
 * A confirmed block on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * A Block on the ledger with signatures only
 */

/**
 * recent block production information
 */

/**
 * Expected JSON RPC response for the "getBlockProduction" message
 */
var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));

/**
 * A performance sample
 */

function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  var fetch = customFetch ? customFetch : fetchImpl;
  var agent;
  {
    if (httpAgent == null) {
      {
        var agentOptions = {
          // One second fewer than the Solana RPC's keepalive timeout.
          // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889
          freeSocketTimeout: 19000,
          keepAlive: true,
          maxSockets: 25
        };
        if (url.startsWith('https:')) {
          agent = new HttpsAgent(agentOptions);
        } else {
          agent = new HttpKeepAliveAgent(agentOptions);
        }
      }
    } else {
      if (httpAgent !== false) {
        var isHttps = url.startsWith('https:');
        if (isHttps && !(httpAgent instanceof Agent$1)) {
          throw new Error('The endpoint `' + url + '` can only be paired with an `https.Agent`. You have, instead, supplied an ' + '`http.Agent` through `httpAgent`.');
        } else if (!isHttps && httpAgent instanceof Agent$1) {
          throw new Error('The endpoint `' + url + '` can only be paired with an `http.Agent`. You have, instead, supplied an ' + '`https.Agent` through `httpAgent`.');
        }
        agent = httpAgent;
      }
    }
  }
  var fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(info, init) {
        var modifiedFetchArgs;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return new Promise(function (resolve, reject) {
                try {
                  fetchMiddleware(info, init, function (modifiedInfo, modifiedInit) {
                    return resolve([modifiedInfo, modifiedInit]);
                  });
                } catch (error) {
                  reject(error);
                }
              });
            case 2:
              modifiedFetchArgs = _context.sent;
              _context.next = 5;
              return fetch.apply(void 0, _toConsumableArray(modifiedFetchArgs));
            case 5:
              return _context.abrupt("return", _context.sent);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function fetchWithMiddleware(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();
  }
  var clientBrowser = new RpcClient( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request, callback) {
      var options, too_many_requests_retries, res, waitTime, text;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            options = {
              method: 'POST',
              body: request,
              agent: agent,
              headers: Object.assign({
                'Content-Type': 'application/json'
              }, httpHeaders || {}, COMMON_HTTP_HEADERS)
            };
            _context2.prev = 1;
            too_many_requests_retries = 5;
            waitTime = 500;
          case 4:
            if (!fetchWithMiddleware) {
              _context2.next = 10;
              break;
            }
            _context2.next = 7;
            return fetchWithMiddleware(url, options);
          case 7:
            res = _context2.sent;
            _context2.next = 13;
            break;
          case 10:
            _context2.next = 12;
            return fetch(url, options);
          case 12:
            res = _context2.sent;
          case 13:
            if (!(res.status !== 429 /* Too many requests */)) {
              _context2.next = 15;
              break;
            }
            return _context2.abrupt("break", 26);
          case 15:
            if (!(disableRetryOnRateLimit === true)) {
              _context2.next = 17;
              break;
            }
            return _context2.abrupt("break", 26);
          case 17:
            too_many_requests_retries -= 1;
            if (!(too_many_requests_retries === 0)) {
              _context2.next = 20;
              break;
            }
            return _context2.abrupt("break", 26);
          case 20:
            console.log("Server responded with ".concat(res.status, " ").concat(res.statusText, ".  Retrying after ").concat(waitTime, "ms delay..."));
            _context2.next = 23;
            return sleep(waitTime);
          case 23:
            waitTime *= 2;
          case 24:
            _context2.next = 4;
            break;
          case 26:
            _context2.next = 28;
            return res.text();
          case 28:
            text = _context2.sent;
            if (res.ok) {
              callback(null, text);
            } else {
              callback(new Error("".concat(res.status, " ").concat(res.statusText, ": ").concat(text)));
            }
            _context2.next = 35;
            break;
          case 32:
            _context2.prev = 32;
            _context2.t0 = _context2["catch"](1);
            if (_context2.t0 instanceof Error) callback(_context2.t0);
          case 35:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[1, 32]]);
    }));
    return function (_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }(), {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return function (method, args) {
    return new Promise(function (resolve, reject) {
      client.request(method, args, function (err, response) {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return function (requests) {
    return new Promise(function (resolve, reject) {
      // Do nothing if requests is empty
      if (requests.length === 0) resolve([]);
      var batch = requests.map(function (params) {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, function (err, response) {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}

/**
 * Expected JSON RPC response for the "getInflationGovernor" message
 */
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);

/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);

/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);

/**
 * Expected JSON RPC response for the "getEpochInfo" message
 */
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);

/**
 * Expected JSON RPC response for the "getEpochSchedule" message
 */
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);

/**
 * Expected JSON RPC response for the "getLeaderSchedule" message
 */
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);

/**
 * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
 */
var SlotRpcResult = jsonRpcResult(number());

/**
 * Supply
 */

/**
 * Expected JSON RPC response for the "getSupply" message
 */
var GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));

/**
 * Token amount object which returns a token amount in different formats
 * for various client use cases.
 */

/**
 * Expected JSON RPC structure for token amounts
 */
var TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});

/**
 * Token address and balance.
 */

/**
 * Expected JSON RPC response for the "getTokenLargestAccounts" message
 */
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));

/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message
 */
var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
})));
var ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
});

/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
 */
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
})));

/**
 * Pair of an account address and its balance
 */

/**
 * Expected JSON RPC response for the "getLargestAccounts" message
 */
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
})));

/**
 * @internal
 */
var AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
});

/**
 * @internal
 */
var KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = coerce(union([instance(Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), function (value) {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});

/**
 * @internal
 */
var ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
});
var KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});

/**
 * @internal
 */
var StakeActivationResult = type({
  state: union([literal('active'), literal('inactive'), literal('activating'), literal('deactivating')]),
  active: number(),
  inactive: number()
});

/**
 * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
 */

var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));

/**
 * Expected JSON RPC response for the "getSignaturesForAddress" message
 */
var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));

/***
 * Expected JSON RPC response for the "accountNotification" message
 */
var AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
});

/**
 * @internal
 */
var ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});

/***
 * Expected JSON RPC response for the "programNotification" message
 */
var ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});

/**
 * @internal
 */
var SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
});

/**
 * Expected JSON RPC response for the "slotNotification" message
 */
var SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
});

/**
 * Slot updates which can be used for tracking the live progress of a cluster.
 * - `"firstShredReceived"`: connected node received the first shred of a block.
 * Indicates that a new block that is being produced.
 * - `"completed"`: connected node has received all shreds of a block. Indicates
 * a block was recently produced.
 * - `"optimisticConfirmation"`: block was optimistically confirmed by the
 * cluster. It is not guaranteed that an optimistic confirmation notification
 * will be sent for every finalized blocks.
 * - `"root"`: the connected node rooted this block.
 * - `"createdBank"`: the connected node has started validating this block.
 * - `"frozen"`: the connected node has validated this block.
 * - `"dead"`: the connected node failed to validate this block.
 */

/**
 * @internal
 */
var SlotUpdateResult = union([type({
  type: union([literal('firstShredReceived'), literal('completed'), literal('optimisticConfirmation'), literal('root')]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal('createdBank'),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal('frozen'),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal('dead'),
  slot: number(),
  timestamp: number(),
  err: string()
})]);

/**
 * Expected JSON RPC response for the "slotsUpdatesNotification" message
 */
var SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
});

/**
 * Expected JSON RPC response for the "signatureNotification" message
 */
var SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});

/**
 * Expected JSON RPC response for the "rootNotification" message
 */
var RootNotificationResult = type({
  subscription: number(),
  result: number()
});
var ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});

/**
 * Expected JSON RPC response for the "getVoteAccounts" message
 */
var GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
var ConfirmationStatus = union([literal('processed'), literal('confirmed'), literal('finalized')]);
var SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});

/**
 * Expected JSON RPC response for the "getSignatureStatuses" message
 */
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));

/**
 * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
 */
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
var AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
});
var ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal('transaction'), literal('lookupTable')]))
});
var ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
var ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
var RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, function (value) {
  if ('accounts' in value) {
    return create(value, RawInstructionResult);
  } else {
    return create(value, ParsedInstructionResult);
  }
});

/**
 * @internal
 */
var ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});

/**
 * @internal
 */
var ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});

/**
 * @internal
 */
var ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});
var TransactionVersionStruct = union([literal(0), literal('legacy')]);

/** @internal */
var RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});

/**
 * Expected JSON RPC response for the "getBlock" message
 */
var GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `none`
 */
var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `accounts`
 */
var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message
 */
var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `accounts`
 */
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `none`
 */
var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.
 */
var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getBlock" message
 */
var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));

/**
 * Expected JSON RPC response for the "getTransaction" message
 */
var GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));

/**
 * Expected parsed JSON RPC response for the "getTransaction" message
 */
var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
})));

/**
 * Expected JSON RPC response for the "getRecentBlockhash" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.
 */
var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  feeCalculator: type({
    lamportsPerSignature: number()
  })
}));

/**
 * Expected JSON RPC response for the "getLatestBlockhash" message
 */
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));

/**
 * Expected JSON RPC response for the "isBlockhashValid" message
 */
var IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
var PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});

/*
 * Expected JSON RPC response for "getRecentPerformanceSamples" message
 */
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));

/**
 * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
 */
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));

/**
 * Expected JSON RPC response for the "requestAirdrop" message
 */
var RequestAirdropRpcResult = jsonRpcResult(string());

/**
 * Expected JSON RPC response for the "sendTransaction" message
 */
var SendTransactionRpcResult = jsonRpcResult(string());

/**
 * Information about the latest slot being processed by a node
 */

/**
 * Parsed account data
 */

/**
 * Stake Activation data
 */

/**
 * Data slice argument for getProgramAccounts
 */

/**
 * Memory comparison filter for getProgramAccounts
 */

/**
 * Data size comparison filter for getProgramAccounts
 */

/**
 * A filter object for getProgramAccounts
 */

/**
 * Configuration object for getProgramAccounts requests
 */

/**
 * Configuration object for getParsedProgramAccounts
 */

/**
 * Configuration object for getMultipleAccounts
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getNonce`
 */

/**
 * Configuration object for `getNonceAndContext`
 */

/**
 * Information describing an account
 */

/**
 * Account information identified by pubkey
 */

/**
 * Callback function for account change notifications
 */

/**
 * Callback function for program account change notifications
 */

/**
 * Callback function for slot change notifications
 */

/**
 * Callback function for slot update notifications
 */

/**
 * Callback function for signature status notifications
 */

/**
 * Signature status notification with transaction result
 */

/**
 * Signature received notification
 */

/**
 * Callback function for signature notifications
 */

/**
 * Signature subscription options
 */

/**
 * Callback function for root change notifications
 */

/**
 * @internal
 */
var LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});

/**
 * Logs result.
 */

/**
 * Expected JSON RPC response for the "logsNotification" message.
 */
var LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
});

/**
 * Filter for log subscriptions.
 */

/**
 * Callback function for log notifications.
 */

/**
 * Signature result
 */

/**
 * Transaction error
 */

/**
 * Transaction confirmation status
 * <pre>
 *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node
 *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster
 *   'finalized': Transaction landed in a block which has been finalized by the cluster
 * </pre>
 */

/**
 * Signature status
 */

/**
 * A confirmed signature with its status
 */

/**
 * An object defining headers to be passed to the RPC server
 */

/**
 * The type of the JavaScript `fetch()` API
 */

/**
 * A callback used to augment the outgoing HTTP request
 */

/**
 * Configuration for instantiating a Connection
 */

/** @internal */
var COMMON_HTTP_HEADERS = {
  'solana-client': "js/".concat((_process$env$npm_pack = "0.0.0-development") !== null && _process$env$npm_pack !== void 0 ? _process$env$npm_pack : 'UNKNOWN')
};

/**
 * A connection to a fullnode JSON RPC endpoint
 */
var Connection = /*#__PURE__*/function () {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  function Connection(endpoint, _commitmentOrConfig) {
    var _this = this;
    _classCallCheck(this, Connection);
    /** @internal */
    this._commitment = void 0;
    /** @internal */
    this._confirmTransactionInitialTimeout = void 0;
    /** @internal */
    this._rpcEndpoint = void 0;
    /** @internal */
    this._rpcWsEndpoint = void 0;
    /** @internal */
    this._rpcClient = void 0;
    /** @internal */
    this._rpcRequest = void 0;
    /** @internal */
    this._rpcBatchRequest = void 0;
    /** @internal */
    this._rpcWebSocket = void 0;
    /** @internal */
    this._rpcWebSocketConnected = false;
    /** @internal */
    this._rpcWebSocketHeartbeat = null;
    /** @internal */
    this._rpcWebSocketIdleTimeout = null;
    /** @internal
     * A number that we increment every time an active connection closes.
     * Used to determine whether the same socket connection that was open
     * when an async operation started is the same one that's active when
     * its continuation fires.
     *
     */
    this._rpcWebSocketGeneration = 0;
    /** @internal */
    this._disableBlockhashCaching = false;
    /** @internal */
    this._pollingBlockhash = false;
    /** @internal */
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    /** @internal */
    this._nextClientSubscriptionId = 0;
    /** @internal */
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    /** @internal */
    this._subscriptionHashByClientSubscriptionId = {};
    /** @internal */
    this._subscriptionStateChangeCallbacksByHash = {};
    /** @internal */
    this._subscriptionCallbacksByServerSubscriptionId = {};
    /** @internal */
    this._subscriptionsByHash = {};
    /**
     * Special case.
     * After a signature is processed, RPCs automatically dispose of the
     * subscription on the server side. We need to track which of these
     * subscriptions have been disposed in such a way, so that we know
     * whether the client is dealing with a not-yet-processed signature
     * (in which case we must tear down the server subscription) or an
     * already-processed signature (in which case the client can simply
     * clear out the subscription locally without telling the server).
     *
     * NOTE: There is a proposal to eliminate this special case, here:
     * https://github.com/solana-labs/solana/issues/18892
     */
    /** @internal */
    this._subscriptionsAutoDisposedByRpc = new Set();
    /*
     * Returns the current block height of the node
     */
    this.getBlockHeight = function () {
      var requestPromises = {};
      return /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(commitmentOrConfig) {
          var _requestPromises$requ;
          var _extractCommitmentFro, commitment, config, args, requestHash;
          return _regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _extractCommitmentFro = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro.commitment, config = _extractCommitmentFro.config;
                args = _this._buildArgs([], commitment, undefined /* encoding */, config);
                requestHash = fastStableStringify$1(args);
                requestPromises[requestHash] = (_requestPromises$requ = requestPromises[requestHash]) !== null && _requestPromises$requ !== void 0 ? _requestPromises$requ : _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
                  var unsafeRes, res;
                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.prev = 0;
                        _context3.next = 3;
                        return _this._rpcRequest('getBlockHeight', args);
                      case 3:
                        unsafeRes = _context3.sent;
                        res = create(unsafeRes, jsonRpcResult(number()));
                        if (!('error' in res)) {
                          _context3.next = 7;
                          break;
                        }
                        throw new SolanaJSONRPCError(res.error, 'failed to get block height information');
                      case 7:
                        return _context3.abrupt("return", res.result);
                      case 8:
                        _context3.prev = 8;
                        delete requestPromises[requestHash];
                        return _context3.finish(8);
                      case 11:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, null, [[0,, 8, 11]]);
                }))();
                _context4.next = 6;
                return requestPromises[requestHash];
              case 6:
                return _context4.abrupt("return", _context4.sent);
              case 7:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        return function (_x5) {
          return _ref3.apply(this, arguments);
        };
      }();
    }();
    var wsEndpoint;
    var httpHeaders;
    var fetch;
    var fetchMiddleware;
    var disableRetryOnRateLimit;
    var httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));
    this._rpcWebSocket.on('error', this._wsOnError.bind(this));
    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));
    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
  }

  /**
   * The default commitment used for requests
   */
  _createClass(Connection, [{
    key: "commitment",
    get: function get() {
      return this._commitment;
    }

    /**
     * The RPC endpoint
     */
  }, {
    key: "rpcEndpoint",
    get: function get() {
      return this._rpcEndpoint;
    }

    /**
     * Fetch the balance for the specified public key, return with context
     */
  }, {
    key: "getBalanceAndContext",
    value: function () {
      var _getBalanceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(publicKey, commitmentOrConfig) {
        var _extractCommitmentFro2, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              /** @internal */
              _extractCommitmentFro2 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro2.commitment, config = _extractCommitmentFro2.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, config);
              _context5.next = 4;
              return this._rpcRequest('getBalance', args);
            case 4:
              unsafeRes = _context5.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(number()));
              if (!('error' in res)) {
                _context5.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get balance for ".concat(publicKey.toBase58()));
            case 8:
              return _context5.abrupt("return", res.result);
            case 9:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getBalanceAndContext(_x6, _x7) {
        return _getBalanceAndContext.apply(this, arguments);
      }
      return getBalanceAndContext;
    }()
    /**
     * Fetch the balance for the specified public key
     */
  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(publicKey, commitmentOrConfig) {
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.getBalanceAndContext(publicKey, commitmentOrConfig).then(function (x) {
                return x.value;
              })["catch"](function (e) {
                throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);
              });
            case 2:
              return _context6.abrupt("return", _context6.sent);
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getBalance(_x8, _x9) {
        return _getBalance.apply(this, arguments);
      }
      return getBalance;
    }()
    /**
     * Fetch the estimated production time of a block
     */
  }, {
    key: "getBlockTime",
    value: function () {
      var _getBlockTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(slot) {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this._rpcRequest('getBlockTime', [slot]);
            case 2:
              unsafeRes = _context7.sent;
              res = create(unsafeRes, jsonRpcResult(nullable(number())));
              if (!('error' in res)) {
                _context7.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get block time for slot ".concat(slot));
            case 6:
              return _context7.abrupt("return", res.result);
            case 7:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getBlockTime(_x10) {
        return _getBlockTime.apply(this, arguments);
      }
      return getBlockTime;
    }()
    /**
     * Fetch the lowest slot that the node has information about in its ledger.
     * This value may increase over time if the node is configured to purge older ledger data
     */
  }, {
    key: "getMinimumLedgerSlot",
    value: function () {
      var _getMinimumLedgerSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this._rpcRequest('minimumLedgerSlot', []);
            case 2:
              unsafeRes = _context8.sent;
              res = create(unsafeRes, jsonRpcResult(number()));
              if (!('error' in res)) {
                _context8.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');
            case 6:
              return _context8.abrupt("return", res.result);
            case 7:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getMinimumLedgerSlot() {
        return _getMinimumLedgerSlot.apply(this, arguments);
      }
      return getMinimumLedgerSlot;
    }()
    /**
     * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
     */
  }, {
    key: "getFirstAvailableBlock",
    value: function () {
      var _getFirstAvailableBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this._rpcRequest('getFirstAvailableBlock', []);
            case 2:
              unsafeRes = _context9.sent;
              res = create(unsafeRes, SlotRpcResult);
              if (!('error' in res)) {
                _context9.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get first available block');
            case 6:
              return _context9.abrupt("return", res.result);
            case 7:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function getFirstAvailableBlock() {
        return _getFirstAvailableBlock.apply(this, arguments);
      }
      return getFirstAvailableBlock;
    }()
    /**
     * Fetch information about the current supply
     */
  }, {
    key: "getSupply",
    value: function () {
      var _getSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(config) {
        var configArg, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              configArg = {};
              if (typeof config === 'string') {
                configArg = {
                  commitment: config
                };
              } else if (config) {
                configArg = _objectSpread(_objectSpread({}, config), {}, {
                  commitment: config && config.commitment || this.commitment
                });
              } else {
                configArg = {
                  commitment: this.commitment
                };
              }
              _context10.next = 4;
              return this._rpcRequest('getSupply', [configArg]);
            case 4:
              unsafeRes = _context10.sent;
              res = create(unsafeRes, GetSupplyRpcResult);
              if (!('error' in res)) {
                _context10.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get supply');
            case 8:
              return _context10.abrupt("return", res.result);
            case 9:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getSupply(_x11) {
        return _getSupply.apply(this, arguments);
      }
      return getSupply;
    }()
    /**
     * Fetch the current supply of a token mint
     */
  }, {
    key: "getTokenSupply",
    value: function () {
      var _getTokenSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(tokenMintAddress, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
              _context11.next = 3;
              return this._rpcRequest('getTokenSupply', args);
            case 3:
              unsafeRes = _context11.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
              if (!('error' in res)) {
                _context11.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get token supply');
            case 7:
              return _context11.abrupt("return", res.result);
            case 8:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function getTokenSupply(_x12, _x13) {
        return _getTokenSupply.apply(this, arguments);
      }
      return getTokenSupply;
    }()
    /**
     * Fetch the current balance of a token account
     */
  }, {
    key: "getTokenAccountBalance",
    value: function () {
      var _getTokenAccountBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(tokenAddress, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              args = this._buildArgs([tokenAddress.toBase58()], commitment);
              _context12.next = 3;
              return this._rpcRequest('getTokenAccountBalance', args);
            case 3:
              unsafeRes = _context12.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
              if (!('error' in res)) {
                _context12.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');
            case 7:
              return _context12.abrupt("return", res.result);
            case 8:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function getTokenAccountBalance(_x14, _x15) {
        return _getTokenAccountBalance.apply(this, arguments);
      }
      return getTokenAccountBalance;
    }()
    /**
     * Fetch all the token accounts owned by the specified account
     *
     * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
     */
  }, {
    key: "getTokenAccountsByOwner",
    value: function () {
      var _getTokenAccountsByOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(ownerAddress, filter, commitmentOrConfig) {
        var _extractCommitmentFro3, commitment, config, _args, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _extractCommitmentFro3 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro3.commitment, config = _extractCommitmentFro3.config;
              _args = [ownerAddress.toBase58()];
              if ('mint' in filter) {
                _args.push({
                  mint: filter.mint.toBase58()
                });
              } else {
                _args.push({
                  programId: filter.programId.toBase58()
                });
              }
              args = this._buildArgs(_args, commitment, 'base64', config);
              _context13.next = 6;
              return this._rpcRequest('getTokenAccountsByOwner', args);
            case 6:
              unsafeRes = _context13.sent;
              res = create(unsafeRes, GetTokenAccountsByOwner);
              if (!('error' in res)) {
                _context13.next = 10;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get token accounts owned by account ".concat(ownerAddress.toBase58()));
            case 10:
              return _context13.abrupt("return", res.result);
            case 11:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getTokenAccountsByOwner(_x16, _x17, _x18) {
        return _getTokenAccountsByOwner.apply(this, arguments);
      }
      return getTokenAccountsByOwner;
    }()
    /**
     * Fetch parsed token accounts owned by the specified account
     *
     * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
     */
  }, {
    key: "getParsedTokenAccountsByOwner",
    value: function () {
      var _getParsedTokenAccountsByOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(ownerAddress, filter, commitment) {
        var _args, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _args = [ownerAddress.toBase58()];
              if ('mint' in filter) {
                _args.push({
                  mint: filter.mint.toBase58()
                });
              } else {
                _args.push({
                  programId: filter.programId.toBase58()
                });
              }
              args = this._buildArgs(_args, commitment, 'jsonParsed');
              _context14.next = 5;
              return this._rpcRequest('getTokenAccountsByOwner', args);
            case 5:
              unsafeRes = _context14.sent;
              res = create(unsafeRes, GetParsedTokenAccountsByOwner);
              if (!('error' in res)) {
                _context14.next = 9;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get token accounts owned by account ".concat(ownerAddress.toBase58()));
            case 9:
              return _context14.abrupt("return", res.result);
            case 10:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function getParsedTokenAccountsByOwner(_x19, _x20, _x21) {
        return _getParsedTokenAccountsByOwner.apply(this, arguments);
      }
      return getParsedTokenAccountsByOwner;
    }()
    /**
     * Fetch the 20 largest accounts with their current balances
     */
  }, {
    key: "getLargestAccounts",
    value: function () {
      var _getLargestAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(config) {
        var arg, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              arg = _objectSpread(_objectSpread({}, config), {}, {
                commitment: config && config.commitment || this.commitment
              });
              args = arg.filter || arg.commitment ? [arg] : [];
              _context15.next = 4;
              return this._rpcRequest('getLargestAccounts', args);
            case 4:
              unsafeRes = _context15.sent;
              res = create(unsafeRes, GetLargestAccountsRpcResult);
              if (!('error' in res)) {
                _context15.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');
            case 8:
              return _context15.abrupt("return", res.result);
            case 9:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function getLargestAccounts(_x22) {
        return _getLargestAccounts.apply(this, arguments);
      }
      return getLargestAccounts;
    }()
    /**
     * Fetch the 20 largest token accounts with their current balances
     * for a given mint.
     */
  }, {
    key: "getTokenLargestAccounts",
    value: function () {
      var _getTokenLargestAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(mintAddress, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              args = this._buildArgs([mintAddress.toBase58()], commitment);
              _context16.next = 3;
              return this._rpcRequest('getTokenLargestAccounts', args);
            case 3:
              unsafeRes = _context16.sent;
              res = create(unsafeRes, GetTokenLargestAccountsResult);
              if (!('error' in res)) {
                _context16.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');
            case 7:
              return _context16.abrupt("return", res.result);
            case 8:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function getTokenLargestAccounts(_x23, _x24) {
        return _getTokenLargestAccounts.apply(this, arguments);
      }
      return getTokenLargestAccounts;
    }()
    /**
     * Fetch all the account info for the specified public key, return with context
     */
  }, {
    key: "getAccountInfoAndContext",
    value: function () {
      var _getAccountInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(publicKey, commitmentOrConfig) {
        var _extractCommitmentFro4, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _extractCommitmentFro4 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro4.commitment, config = _extractCommitmentFro4.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);
              _context17.next = 4;
              return this._rpcRequest('getAccountInfo', args);
            case 4:
              unsafeRes = _context17.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
              if (!('error' in res)) {
                _context17.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get info about account ".concat(publicKey.toBase58()));
            case 8:
              return _context17.abrupt("return", res.result);
            case 9:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function getAccountInfoAndContext(_x25, _x26) {
        return _getAccountInfoAndContext.apply(this, arguments);
      }
      return getAccountInfoAndContext;
    }()
    /**
     * Fetch parsed account info for the specified public key
     */
  }, {
    key: "getParsedAccountInfo",
    value: function () {
      var _getParsedAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(publicKey, commitmentOrConfig) {
        var _extractCommitmentFro5, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _extractCommitmentFro5 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro5.commitment, config = _extractCommitmentFro5.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);
              _context18.next = 4;
              return this._rpcRequest('getAccountInfo', args);
            case 4:
              unsafeRes = _context18.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
              if (!('error' in res)) {
                _context18.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get info about account ".concat(publicKey.toBase58()));
            case 8:
              return _context18.abrupt("return", res.result);
            case 9:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function getParsedAccountInfo(_x27, _x28) {
        return _getParsedAccountInfo.apply(this, arguments);
      }
      return getParsedAccountInfo;
    }()
    /**
     * Fetch all the account info for the specified public key
     */
  }, {
    key: "getAccountInfo",
    value: function () {
      var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(publicKey, commitmentOrConfig) {
        var res;
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.prev = 0;
              _context19.next = 3;
              return this.getAccountInfoAndContext(publicKey, commitmentOrConfig);
            case 3:
              res = _context19.sent;
              return _context19.abrupt("return", res.value);
            case 7:
              _context19.prev = 7;
              _context19.t0 = _context19["catch"](0);
              throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + _context19.t0);
            case 10:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this, [[0, 7]]);
      }));
      function getAccountInfo(_x29, _x30) {
        return _getAccountInfo.apply(this, arguments);
      }
      return getAccountInfo;
    }()
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
     */
  }, {
    key: "getMultipleParsedAccounts",
    value: function () {
      var _getMultipleParsedAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(publicKeys, rawConfig) {
        var _extractCommitmentFro6, commitment, config, keys, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _extractCommitmentFro6 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro6.commitment, config = _extractCommitmentFro6.config;
              keys = publicKeys.map(function (key) {
                return key.toBase58();
              });
              args = this._buildArgs([keys], commitment, 'jsonParsed', config);
              _context20.next = 5;
              return this._rpcRequest('getMultipleAccounts', args);
            case 5:
              unsafeRes = _context20.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
              if (!('error' in res)) {
                _context20.next = 9;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get info for accounts ".concat(keys));
            case 9:
              return _context20.abrupt("return", res.result);
            case 10:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function getMultipleParsedAccounts(_x31, _x32) {
        return _getMultipleParsedAccounts.apply(this, arguments);
      }
      return getMultipleParsedAccounts;
    }()
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
     */
  }, {
    key: "getMultipleAccountsInfoAndContext",
    value: function () {
      var _getMultipleAccountsInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(publicKeys, commitmentOrConfig) {
        var _extractCommitmentFro7, commitment, config, keys, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _extractCommitmentFro7 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro7.commitment, config = _extractCommitmentFro7.config;
              keys = publicKeys.map(function (key) {
                return key.toBase58();
              });
              args = this._buildArgs([keys], commitment, 'base64', config);
              _context21.next = 5;
              return this._rpcRequest('getMultipleAccounts', args);
            case 5:
              unsafeRes = _context21.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
              if (!('error' in res)) {
                _context21.next = 9;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get info for accounts ".concat(keys));
            case 9:
              return _context21.abrupt("return", res.result);
            case 10:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function getMultipleAccountsInfoAndContext(_x33, _x34) {
        return _getMultipleAccountsInfoAndContext.apply(this, arguments);
      }
      return getMultipleAccountsInfoAndContext;
    }()
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys
     */
  }, {
    key: "getMultipleAccountsInfo",
    value: function () {
      var _getMultipleAccountsInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(publicKeys, commitmentOrConfig) {
        var res;
        return _regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
            case 2:
              res = _context22.sent;
              return _context22.abrupt("return", res.value);
            case 4:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function getMultipleAccountsInfo(_x35, _x36) {
        return _getMultipleAccountsInfo.apply(this, arguments);
      }
      return getMultipleAccountsInfo;
    }()
    /**
     * Returns epoch activation information for a stake account that has been delegated
     */
  }, {
    key: "getStakeActivation",
    value: function () {
      var _getStakeActivation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(publicKey, commitmentOrConfig, epoch) {
        var _extractCommitmentFro8, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _extractCommitmentFro8 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro8.commitment, config = _extractCommitmentFro8.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, _objectSpread(_objectSpread({}, config), {}, {
                epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch
              }));
              _context23.next = 4;
              return this._rpcRequest('getStakeActivation', args);
            case 4:
              unsafeRes = _context23.sent;
              res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
              if (!('error' in res)) {
                _context23.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get Stake Activation ".concat(publicKey.toBase58()));
            case 8:
              return _context23.abrupt("return", res.result);
            case 9:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function getStakeActivation(_x37, _x38, _x39) {
        return _getStakeActivation.apply(this, arguments);
      }
      return getStakeActivation;
    }()
    /**
     * Fetch all the accounts owned by the specified program id
     *
     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
     */
  }, {
    key: "getProgramAccounts",
    value: // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(programId, configOrCommitment) {
        var _extractCommitmentFro9, commitment, config, _ref5, encoding, configWithoutEncoding, args, unsafeRes, baseSchema, res;
        return _regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _extractCommitmentFro9 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro9.commitment, config = _extractCommitmentFro9.config;
              _ref5 = config || {}, encoding = _ref5.encoding, configWithoutEncoding = _objectWithoutProperties(_ref5, _excluded2);
              args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);
              _context24.next = 5;
              return this._rpcRequest('getProgramAccounts', args);
            case 5:
              unsafeRes = _context24.sent;
              baseSchema = array(KeyedAccountInfoResult);
              res = configWithoutEncoding.withContext === true ? create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : create(unsafeRes, jsonRpcResult(baseSchema));
              if (!('error' in res)) {
                _context24.next = 10;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get accounts owned by program ".concat(programId.toBase58()));
            case 10:
              return _context24.abrupt("return", res.result);
            case 11:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function getProgramAccounts(_x40, _x41) {
        return _getProgramAccounts.apply(this, arguments);
      }
      return getProgramAccounts;
    }()
    /**
     * Fetch and parse all the accounts owned by the specified program id
     *
     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
     */
  }, {
    key: "getParsedProgramAccounts",
    value: function () {
      var _getParsedProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(programId, configOrCommitment) {
        var _extractCommitmentFro10, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              _extractCommitmentFro10 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro10.commitment, config = _extractCommitmentFro10.config;
              args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);
              _context25.next = 4;
              return this._rpcRequest('getProgramAccounts', args);
            case 4:
              unsafeRes = _context25.sent;
              res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
              if (!('error' in res)) {
                _context25.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get accounts owned by program ".concat(programId.toBase58()));
            case 8:
              return _context25.abrupt("return", res.result);
            case 9:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function getParsedProgramAccounts(_x42, _x43) {
        return _getParsedProgramAccounts.apply(this, arguments);
      }
      return getParsedProgramAccounts;
    }()
  }, {
    key: "confirmTransaction",
    value: // eslint-disable-next-line no-dupe-class-members
    function () {
      var _confirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(strategy, commitment) {
        var rawSignature, _config$abortSignal, _config, decodedSignature;
        return _regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              if (!(typeof strategy == 'string')) {
                _context26.next = 4;
                break;
              }
              rawSignature = strategy;
              _context26.next = 8;
              break;
            case 4:
              _config = strategy;
              if (!((_config$abortSignal = _config.abortSignal) !== null && _config$abortSignal !== void 0 && _config$abortSignal.aborted)) {
                _context26.next = 7;
                break;
              }
              return _context26.abrupt("return", Promise.reject(_config.abortSignal.reason));
            case 7:
              rawSignature = _config.signature;
            case 8:
              _context26.prev = 8;
              decodedSignature = bs58.decode(rawSignature);
              _context26.next = 15;
              break;
            case 12:
              _context26.prev = 12;
              _context26.t0 = _context26["catch"](8);
              throw new Error('signature must be base58 encoded: ' + rawSignature);
            case 15:
              assert(decodedSignature.length === 64, 'signature has invalid length');
              if (!(typeof strategy === 'string')) {
                _context26.next = 22;
                break;
              }
              _context26.next = 19;
              return this.confirmTransactionUsingLegacyTimeoutStrategy({
                commitment: commitment || this.commitment,
                signature: rawSignature
              });
            case 19:
              return _context26.abrupt("return", _context26.sent);
            case 22:
              if (!('lastValidBlockHeight' in strategy)) {
                _context26.next = 28;
                break;
              }
              _context26.next = 25;
              return this.confirmTransactionUsingBlockHeightExceedanceStrategy({
                commitment: commitment || this.commitment,
                strategy: strategy
              });
            case 25:
              return _context26.abrupt("return", _context26.sent);
            case 28:
              _context26.next = 30;
              return this.confirmTransactionUsingDurableNonceStrategy({
                commitment: commitment || this.commitment,
                strategy: strategy
              });
            case 30:
              return _context26.abrupt("return", _context26.sent);
            case 31:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this, [[8, 12]]);
      }));
      function confirmTransaction(_x44, _x45) {
        return _confirmTransaction.apply(this, arguments);
      }
      return confirmTransaction;
    }()
  }, {
    key: "getCancellationPromise",
    value: function getCancellationPromise(signal) {
      return new Promise(function (_, reject) {
        if (signal == null) {
          return;
        }
        if (signal.aborted) {
          reject(signal.reason);
        } else {
          signal.addEventListener('abort', function () {
            reject(signal.reason);
          });
        }
      });
    }
  }, {
    key: "getTransactionConfirmationPromise",
    value: function getTransactionConfirmationPromise(_ref6) {
      var _this2 = this;
      var commitment = _ref6.commitment,
        signature = _ref6.signature;
      var signatureSubscriptionId;
      var disposeSignatureSubscriptionStateChangeObserver;
      var done = false;
      var confirmationPromise = new Promise(function (resolve, reject) {
        try {
          signatureSubscriptionId = _this2.onSignature(signature, function (result, context) {
            signatureSubscriptionId = undefined;
            var response = {
              context: context,
              value: result
            };
            resolve({
              __type: TransactionStatus.PROCESSED,
              response: response
            });
          }, commitment);
          var subscriptionSetupPromise = new Promise(function (resolveSubscriptionSetup) {
            if (signatureSubscriptionId == null) {
              resolveSubscriptionSetup();
            } else {
              disposeSignatureSubscriptionStateChangeObserver = _this2._onSubscriptionStateChange(signatureSubscriptionId, function (nextState) {
                if (nextState === 'subscribed') {
                  resolveSubscriptionSetup();
                }
              });
            }
          });
          _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {
            var response, context, value;
            return _regeneratorRuntime.wrap(function _callee27$(_context27) {
              while (1) switch (_context27.prev = _context27.next) {
                case 0:
                  _context27.next = 2;
                  return subscriptionSetupPromise;
                case 2:
                  if (!done) {
                    _context27.next = 4;
                    break;
                  }
                  return _context27.abrupt("return");
                case 4:
                  _context27.next = 6;
                  return _this2.getSignatureStatus(signature);
                case 6:
                  response = _context27.sent;
                  if (!done) {
                    _context27.next = 9;
                    break;
                  }
                  return _context27.abrupt("return");
                case 9:
                  if (!(response == null)) {
                    _context27.next = 11;
                    break;
                  }
                  return _context27.abrupt("return");
                case 11:
                  context = response.context, value = response.value;
                  if (!(value == null)) {
                    _context27.next = 14;
                    break;
                  }
                  return _context27.abrupt("return");
                case 14:
                  if (!(value !== null && value !== void 0 && value.err)) {
                    _context27.next = 18;
                    break;
                  }
                  reject(value.err);
                  _context27.next = 29;
                  break;
                case 18:
                  _context27.t0 = commitment;
                  _context27.next = _context27.t0 === 'confirmed' ? 21 : _context27.t0 === 'single' ? 21 : _context27.t0 === 'singleGossip' ? 21 : _context27.t0 === 'finalized' ? 24 : _context27.t0 === 'max' ? 24 : _context27.t0 === 'root' ? 24 : _context27.t0 === 'processed' ? 27 : _context27.t0 === 'recent' ? 27 : 27;
                  break;
                case 21:
                  if (!(value.confirmationStatus === 'processed')) {
                    _context27.next = 23;
                    break;
                  }
                  return _context27.abrupt("return");
                case 23:
                  return _context27.abrupt("break", 27);
                case 24:
                  if (!(value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed')) {
                    _context27.next = 26;
                    break;
                  }
                  return _context27.abrupt("return");
                case 26:
                  return _context27.abrupt("break", 27);
                case 27:
                  done = true;
                  resolve({
                    __type: TransactionStatus.PROCESSED,
                    response: {
                      context: context,
                      value: value
                    }
                  });
                case 29:
                case "end":
                  return _context27.stop();
              }
            }, _callee27);
          }))();
        } catch (err) {
          reject(err);
        }
      });
      var abortConfirmation = function abortConfirmation() {
        if (disposeSignatureSubscriptionStateChangeObserver) {
          disposeSignatureSubscriptionStateChangeObserver();
          disposeSignatureSubscriptionStateChangeObserver = undefined;
        }
        if (signatureSubscriptionId != null) {
          _this2.removeSignatureListener(signatureSubscriptionId);
          signatureSubscriptionId = undefined;
        }
      };
      return {
        abortConfirmation: abortConfirmation,
        confirmationPromise: confirmationPromise
      };
    }
  }, {
    key: "confirmTransactionUsingBlockHeightExceedanceStrategy",
    value: function () {
      var _confirmTransactionUsingBlockHeightExceedanceStrategy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(_ref8) {
        var _this3 = this;
        var commitment, _ref8$strategy, abortSignal, lastValidBlockHeight, signature, done, expiryPromise, _this$getTransactionC, abortConfirmation, confirmationPromise, cancellationPromise, result, outcome;
        return _regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              commitment = _ref8.commitment, _ref8$strategy = _ref8.strategy, abortSignal = _ref8$strategy.abortSignal, lastValidBlockHeight = _ref8$strategy.lastValidBlockHeight, signature = _ref8$strategy.signature;
              done = false;
              expiryPromise = new Promise(function (resolve) {
                var checkBlockHeight = /*#__PURE__*/function () {
                  var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {
                    var blockHeight;
                    return _regeneratorRuntime.wrap(function _callee28$(_context28) {
                      while (1) switch (_context28.prev = _context28.next) {
                        case 0:
                          _context28.prev = 0;
                          _context28.next = 3;
                          return _this3.getBlockHeight(commitment);
                        case 3:
                          blockHeight = _context28.sent;
                          return _context28.abrupt("return", blockHeight);
                        case 7:
                          _context28.prev = 7;
                          _context28.t0 = _context28["catch"](0);
                          return _context28.abrupt("return", -1);
                        case 10:
                        case "end":
                          return _context28.stop();
                      }
                    }, _callee28, null, [[0, 7]]);
                  }));
                  return function checkBlockHeight() {
                    return _ref9.apply(this, arguments);
                  };
                }();
                _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {
                  var currentBlockHeight;
                  return _regeneratorRuntime.wrap(function _callee29$(_context29) {
                    while (1) switch (_context29.prev = _context29.next) {
                      case 0:
                        _context29.next = 2;
                        return checkBlockHeight();
                      case 2:
                        currentBlockHeight = _context29.sent;
                        if (!done) {
                          _context29.next = 5;
                          break;
                        }
                        return _context29.abrupt("return");
                      case 5:
                        if (!(currentBlockHeight <= lastValidBlockHeight)) {
                          _context29.next = 17;
                          break;
                        }
                        _context29.next = 8;
                        return sleep(1000);
                      case 8:
                        if (!done) {
                          _context29.next = 10;
                          break;
                        }
                        return _context29.abrupt("return");
                      case 10:
                        _context29.next = 12;
                        return checkBlockHeight();
                      case 12:
                        currentBlockHeight = _context29.sent;
                        if (!done) {
                          _context29.next = 15;
                          break;
                        }
                        return _context29.abrupt("return");
                      case 15:
                        _context29.next = 5;
                        break;
                      case 17:
                        resolve({
                          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
                        });
                      case 18:
                      case "end":
                        return _context29.stop();
                    }
                  }, _callee29);
                }))();
              });
              _this$getTransactionC = this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature
              }), abortConfirmation = _this$getTransactionC.abortConfirmation, confirmationPromise = _this$getTransactionC.confirmationPromise;
              cancellationPromise = this.getCancellationPromise(abortSignal);
              _context30.prev = 5;
              _context30.next = 8;
              return Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            case 8:
              outcome = _context30.sent;
              if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                _context30.next = 13;
                break;
              }
              result = outcome.response;
              _context30.next = 14;
              break;
            case 13:
              throw new TransactionExpiredBlockheightExceededError(signature);
            case 14:
              _context30.prev = 14;
              done = true;
              abortConfirmation();
              return _context30.finish(14);
            case 18:
              return _context30.abrupt("return", result);
            case 19:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this, [[5,, 14, 18]]);
      }));
      function confirmTransactionUsingBlockHeightExceedanceStrategy(_x46) {
        return _confirmTransactionUsingBlockHeightExceedanceStrategy.apply(this, arguments);
      }
      return confirmTransactionUsingBlockHeightExceedanceStrategy;
    }()
  }, {
    key: "confirmTransactionUsingDurableNonceStrategy",
    value: function () {
      var _confirmTransactionUsingDurableNonceStrategy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee33(_ref11) {
        var _this4 = this;
        var commitment, _ref11$strategy, abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature, done, expiryPromise, _this$getTransactionC2, abortConfirmation, confirmationPromise, cancellationPromise, result, outcome, _signatureStatus, signatureStatus, _outcome$slotInWhichN, status, commitmentForStatus, confirmationStatus;
        return _regeneratorRuntime.wrap(function _callee33$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              commitment = _ref11.commitment, _ref11$strategy = _ref11.strategy, abortSignal = _ref11$strategy.abortSignal, minContextSlot = _ref11$strategy.minContextSlot, nonceAccountPubkey = _ref11$strategy.nonceAccountPubkey, nonceValue = _ref11$strategy.nonceValue, signature = _ref11$strategy.signature;
              done = false;
              expiryPromise = new Promise(function (resolve) {
                var currentNonceValue = nonceValue;
                var lastCheckedSlot = null;
                var getCurrentNonceValue = /*#__PURE__*/function () {
                  var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31() {
                    var _yield$_this4$getNonc, _context31, nonceAccount;
                    return _regeneratorRuntime.wrap(function _callee31$(_context32) {
                      while (1) switch (_context32.prev = _context32.next) {
                        case 0:
                          _context32.prev = 0;
                          _context32.next = 3;
                          return _this4.getNonceAndContext(nonceAccountPubkey, {
                            commitment: commitment,
                            minContextSlot: minContextSlot
                          });
                        case 3:
                          _yield$_this4$getNonc = _context32.sent;
                          _context31 = _yield$_this4$getNonc.context;
                          nonceAccount = _yield$_this4$getNonc.value;
                          lastCheckedSlot = _context31.slot;
                          return _context32.abrupt("return", nonceAccount === null || nonceAccount === void 0 ? void 0 : nonceAccount.nonce);
                        case 10:
                          _context32.prev = 10;
                          _context32.t0 = _context32["catch"](0);
                          return _context32.abrupt("return", currentNonceValue);
                        case 13:
                        case "end":
                          return _context32.stop();
                      }
                    }, _callee31, null, [[0, 10]]);
                  }));
                  return function getCurrentNonceValue() {
                    return _ref12.apply(this, arguments);
                  };
                }();
                _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32() {
                  return _regeneratorRuntime.wrap(function _callee32$(_context33) {
                    while (1) switch (_context33.prev = _context33.next) {
                      case 0:
                        _context33.next = 2;
                        return getCurrentNonceValue();
                      case 2:
                        currentNonceValue = _context33.sent;
                        if (!done) {
                          _context33.next = 5;
                          break;
                        }
                        return _context33.abrupt("return");
                      case 5:
                        if (!(nonceValue !== currentNonceValue)) {
                          _context33.next = 9;
                          break;
                        }
                        resolve({
                          __type: TransactionStatus.NONCE_INVALID,
                          slotInWhichNonceDidAdvance: lastCheckedSlot
                        });
                        return _context33.abrupt("return");
                      case 9:
                        _context33.next = 11;
                        return sleep(2000);
                      case 11:
                        if (!done) {
                          _context33.next = 13;
                          break;
                        }
                        return _context33.abrupt("return");
                      case 13:
                        _context33.next = 15;
                        return getCurrentNonceValue();
                      case 15:
                        currentNonceValue = _context33.sent;
                        if (!done) {
                          _context33.next = 18;
                          break;
                        }
                        return _context33.abrupt("return");
                      case 18:
                        _context33.next = 5;
                        break;
                      case 20:
                      case "end":
                        return _context33.stop();
                    }
                  }, _callee32);
                }))();
              });
              _this$getTransactionC2 = this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature
              }), abortConfirmation = _this$getTransactionC2.abortConfirmation, confirmationPromise = _this$getTransactionC2.confirmationPromise;
              cancellationPromise = this.getCancellationPromise(abortSignal);
              _context34.prev = 5;
              _context34.next = 8;
              return Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            case 8:
              outcome = _context34.sent;
              if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                _context34.next = 13;
                break;
              }
              result = outcome.response;
              _context34.next = 47;
              break;
            case 13:
              _context34.next = 16;
              return this.getSignatureStatus(signature);
            case 16:
              status = _context34.sent;
              if (!(status == null)) {
                _context34.next = 19;
                break;
              }
              return _context34.abrupt("break", 27);
            case 19:
              if (!(status.context.slot < ((_outcome$slotInWhichN = outcome.slotInWhichNonceDidAdvance) !== null && _outcome$slotInWhichN !== void 0 ? _outcome$slotInWhichN : minContextSlot))) {
                _context34.next = 23;
                break;
              }
              _context34.next = 22;
              return sleep(400);
            case 22:
              return _context34.abrupt("continue", 13);
            case 23:
              signatureStatus = status;
              return _context34.abrupt("break", 27);
            case 27:
              if (!((_signatureStatus = signatureStatus) !== null && _signatureStatus !== void 0 && _signatureStatus.value)) {
                _context34.next = 46;
                break;
              }
              commitmentForStatus = commitment || 'finalized';
              confirmationStatus = signatureStatus.value.confirmationStatus;
              _context34.t0 = commitmentForStatus;
              _context34.next = _context34.t0 === 'processed' ? 33 : _context34.t0 === 'recent' ? 33 : _context34.t0 === 'confirmed' ? 36 : _context34.t0 === 'single' ? 36 : _context34.t0 === 'singleGossip' ? 36 : _context34.t0 === 'finalized' ? 39 : _context34.t0 === 'max' ? 39 : _context34.t0 === 'root' ? 39 : 42;
              break;
            case 33:
              if (!(confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized')) {
                _context34.next = 35;
                break;
              }
              throw new TransactionExpiredNonceInvalidError(signature);
            case 35:
              return _context34.abrupt("break", 43);
            case 36:
              if (!(confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized')) {
                _context34.next = 38;
                break;
              }
              throw new TransactionExpiredNonceInvalidError(signature);
            case 38:
              return _context34.abrupt("break", 43);
            case 39:
              if (!(confirmationStatus !== 'finalized')) {
                _context34.next = 41;
                break;
              }
              throw new TransactionExpiredNonceInvalidError(signature);
            case 41:
              return _context34.abrupt("break", 43);
            case 42:
            case 43:
              result = {
                context: signatureStatus.context,
                value: {
                  err: signatureStatus.value.err
                }
              };
              _context34.next = 47;
              break;
            case 46:
              throw new TransactionExpiredNonceInvalidError(signature);
            case 47:
              _context34.prev = 47;
              done = true;
              abortConfirmation();
              return _context34.finish(47);
            case 51:
              return _context34.abrupt("return", result);
            case 52:
            case "end":
              return _context34.stop();
          }
        }, _callee33, this, [[5,, 47, 51]]);
      }));
      function confirmTransactionUsingDurableNonceStrategy(_x47) {
        return _confirmTransactionUsingDurableNonceStrategy.apply(this, arguments);
      }
      return confirmTransactionUsingDurableNonceStrategy;
    }()
  }, {
    key: "confirmTransactionUsingLegacyTimeoutStrategy",
    value: function () {
      var _confirmTransactionUsingLegacyTimeoutStrategy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee34(_ref14) {
        var _this5 = this;
        var commitment, signature, timeoutId, expiryPromise, _this$getTransactionC3, abortConfirmation, confirmationPromise, result, outcome;
        return _regeneratorRuntime.wrap(function _callee34$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              commitment = _ref14.commitment, signature = _ref14.signature;
              expiryPromise = new Promise(function (resolve) {
                var timeoutMs = _this5._confirmTransactionInitialTimeout || 60 * 1000;
                switch (commitment) {
                  case 'processed':
                  case 'recent':
                  case 'single':
                  case 'confirmed':
                  case 'singleGossip':
                    {
                      timeoutMs = _this5._confirmTransactionInitialTimeout || 30 * 1000;
                      break;
                    }
                }
                timeoutId = setTimeout(function () {
                  return resolve({
                    __type: TransactionStatus.TIMED_OUT,
                    timeoutMs: timeoutMs
                  });
                }, timeoutMs);
              });
              _this$getTransactionC3 = this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature
              }), abortConfirmation = _this$getTransactionC3.abortConfirmation, confirmationPromise = _this$getTransactionC3.confirmationPromise;
              _context35.prev = 3;
              _context35.next = 6;
              return Promise.race([confirmationPromise, expiryPromise]);
            case 6:
              outcome = _context35.sent;
              if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                _context35.next = 11;
                break;
              }
              result = outcome.response;
              _context35.next = 12;
              break;
            case 11:
              throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);
            case 12:
              _context35.prev = 12;
              clearTimeout(timeoutId);
              abortConfirmation();
              return _context35.finish(12);
            case 16:
              return _context35.abrupt("return", result);
            case 17:
            case "end":
              return _context35.stop();
          }
        }, _callee34, this, [[3,, 12, 16]]);
      }));
      function confirmTransactionUsingLegacyTimeoutStrategy(_x48) {
        return _confirmTransactionUsingLegacyTimeoutStrategy.apply(this, arguments);
      }
      return confirmTransactionUsingLegacyTimeoutStrategy;
    }()
    /**
     * Return the list of nodes that are currently participating in the cluster
     */
  }, {
    key: "getClusterNodes",
    value: function () {
      var _getClusterNodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee35() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee35$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              _context36.next = 2;
              return this._rpcRequest('getClusterNodes', []);
            case 2:
              unsafeRes = _context36.sent;
              res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
              if (!('error' in res)) {
                _context36.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');
            case 6:
              return _context36.abrupt("return", res.result);
            case 7:
            case "end":
              return _context36.stop();
          }
        }, _callee35, this);
      }));
      function getClusterNodes() {
        return _getClusterNodes.apply(this, arguments);
      }
      return getClusterNodes;
    }()
    /**
     * Return the list of nodes that are currently participating in the cluster
     */
  }, {
    key: "getVoteAccounts",
    value: function () {
      var _getVoteAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee36(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee36$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              args = this._buildArgs([], commitment);
              _context37.next = 3;
              return this._rpcRequest('getVoteAccounts', args);
            case 3:
              unsafeRes = _context37.sent;
              res = create(unsafeRes, GetVoteAccounts);
              if (!('error' in res)) {
                _context37.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');
            case 7:
              return _context37.abrupt("return", res.result);
            case 8:
            case "end":
              return _context37.stop();
          }
        }, _callee36, this);
      }));
      function getVoteAccounts(_x49) {
        return _getVoteAccounts.apply(this, arguments);
      }
      return getVoteAccounts;
    }()
    /**
     * Fetch the current slot that the node is processing
     */
  }, {
    key: "getSlot",
    value: function () {
      var _getSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee37(commitmentOrConfig) {
        var _extractCommitmentFro11, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee37$(_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              _extractCommitmentFro11 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro11.commitment, config = _extractCommitmentFro11.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context38.next = 4;
              return this._rpcRequest('getSlot', args);
            case 4:
              unsafeRes = _context38.sent;
              res = create(unsafeRes, jsonRpcResult(number()));
              if (!('error' in res)) {
                _context38.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get slot');
            case 8:
              return _context38.abrupt("return", res.result);
            case 9:
            case "end":
              return _context38.stop();
          }
        }, _callee37, this);
      }));
      function getSlot(_x50) {
        return _getSlot.apply(this, arguments);
      }
      return getSlot;
    }()
    /**
     * Fetch the current slot leader of the cluster
     */
  }, {
    key: "getSlotLeader",
    value: function () {
      var _getSlotLeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee38(commitmentOrConfig) {
        var _extractCommitmentFro12, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee38$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              _extractCommitmentFro12 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro12.commitment, config = _extractCommitmentFro12.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context39.next = 4;
              return this._rpcRequest('getSlotLeader', args);
            case 4:
              unsafeRes = _context39.sent;
              res = create(unsafeRes, jsonRpcResult(string()));
              if (!('error' in res)) {
                _context39.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');
            case 8:
              return _context39.abrupt("return", res.result);
            case 9:
            case "end":
              return _context39.stop();
          }
        }, _callee38, this);
      }));
      function getSlotLeader(_x51) {
        return _getSlotLeader.apply(this, arguments);
      }
      return getSlotLeader;
    }()
    /**
     * Fetch `limit` number of slot leaders starting from `startSlot`
     *
     * @param startSlot fetch slot leaders starting from this slot
     * @param limit number of slot leaders to return
     */
  }, {
    key: "getSlotLeaders",
    value: function () {
      var _getSlotLeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee39(startSlot, limit) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee39$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              args = [startSlot, limit];
              _context40.next = 3;
              return this._rpcRequest('getSlotLeaders', args);
            case 3:
              unsafeRes = _context40.sent;
              res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
              if (!('error' in res)) {
                _context40.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');
            case 7:
              return _context40.abrupt("return", res.result);
            case 8:
            case "end":
              return _context40.stop();
          }
        }, _callee39, this);
      }));
      function getSlotLeaders(_x52, _x53) {
        return _getSlotLeaders.apply(this, arguments);
      }
      return getSlotLeaders;
    }()
    /**
     * Fetch the current status of a signature
     */
  }, {
    key: "getSignatureStatus",
    value: function () {
      var _getSignatureStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee40(signature, config) {
        var _yield$this$getSignat, context, values, value;
        return _regeneratorRuntime.wrap(function _callee40$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              _context41.next = 2;
              return this.getSignatureStatuses([signature], config);
            case 2:
              _yield$this$getSignat = _context41.sent;
              context = _yield$this$getSignat.context;
              values = _yield$this$getSignat.value;
              assert(values.length === 1);
              value = values[0];
              return _context41.abrupt("return", {
                context: context,
                value: value
              });
            case 8:
            case "end":
              return _context41.stop();
          }
        }, _callee40, this);
      }));
      function getSignatureStatus(_x54, _x55) {
        return _getSignatureStatus.apply(this, arguments);
      }
      return getSignatureStatus;
    }()
    /**
     * Fetch the current statuses of a batch of signatures
     */
  }, {
    key: "getSignatureStatuses",
    value: function () {
      var _getSignatureStatuses = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee41(signatures, config) {
        var params, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee41$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              params = [signatures];
              if (config) {
                params.push(config);
              }
              _context42.next = 4;
              return this._rpcRequest('getSignatureStatuses', params);
            case 4:
              unsafeRes = _context42.sent;
              res = create(unsafeRes, GetSignatureStatusesRpcResult);
              if (!('error' in res)) {
                _context42.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get signature status');
            case 8:
              return _context42.abrupt("return", res.result);
            case 9:
            case "end":
              return _context42.stop();
          }
        }, _callee41, this);
      }));
      function getSignatureStatuses(_x56, _x57) {
        return _getSignatureStatuses.apply(this, arguments);
      }
      return getSignatureStatuses;
    }()
    /**
     * Fetch the current transaction count of the cluster
     */
  }, {
    key: "getTransactionCount",
    value: function () {
      var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee42(commitmentOrConfig) {
        var _extractCommitmentFro13, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee42$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              _extractCommitmentFro13 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro13.commitment, config = _extractCommitmentFro13.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context43.next = 4;
              return this._rpcRequest('getTransactionCount', args);
            case 4:
              unsafeRes = _context43.sent;
              res = create(unsafeRes, jsonRpcResult(number()));
              if (!('error' in res)) {
                _context43.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');
            case 8:
              return _context43.abrupt("return", res.result);
            case 9:
            case "end":
              return _context43.stop();
          }
        }, _callee42, this);
      }));
      function getTransactionCount(_x58) {
        return _getTransactionCount.apply(this, arguments);
      }
      return getTransactionCount;
    }()
    /**
     * Fetch the current total currency supply of the cluster in lamports
     *
     * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
     */
  }, {
    key: "getTotalSupply",
    value: function () {
      var _getTotalSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee43(commitment) {
        var result;
        return _regeneratorRuntime.wrap(function _callee43$(_context44) {
          while (1) switch (_context44.prev = _context44.next) {
            case 0:
              _context44.next = 2;
              return this.getSupply({
                commitment: commitment,
                excludeNonCirculatingAccountsList: true
              });
            case 2:
              result = _context44.sent;
              return _context44.abrupt("return", result.value.total);
            case 4:
            case "end":
              return _context44.stop();
          }
        }, _callee43, this);
      }));
      function getTotalSupply(_x59) {
        return _getTotalSupply.apply(this, arguments);
      }
      return getTotalSupply;
    }()
    /**
     * Fetch the cluster InflationGovernor parameters
     */
  }, {
    key: "getInflationGovernor",
    value: function () {
      var _getInflationGovernor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee44(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee44$(_context45) {
          while (1) switch (_context45.prev = _context45.next) {
            case 0:
              args = this._buildArgs([], commitment);
              _context45.next = 3;
              return this._rpcRequest('getInflationGovernor', args);
            case 3:
              unsafeRes = _context45.sent;
              res = create(unsafeRes, GetInflationGovernorRpcResult);
              if (!('error' in res)) {
                _context45.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get inflation');
            case 7:
              return _context45.abrupt("return", res.result);
            case 8:
            case "end":
              return _context45.stop();
          }
        }, _callee44, this);
      }));
      function getInflationGovernor(_x60) {
        return _getInflationGovernor.apply(this, arguments);
      }
      return getInflationGovernor;
    }()
    /**
     * Fetch the inflation reward for a list of addresses for an epoch
     */
  }, {
    key: "getInflationReward",
    value: function () {
      var _getInflationReward = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee45(addresses, epoch, commitmentOrConfig) {
        var _extractCommitmentFro14, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee45$(_context46) {
          while (1) switch (_context46.prev = _context46.next) {
            case 0:
              _extractCommitmentFro14 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro14.commitment, config = _extractCommitmentFro14.config;
              args = this._buildArgs([addresses.map(function (pubkey) {
                return pubkey.toBase58();
              })], commitment, undefined /* encoding */, _objectSpread(_objectSpread({}, config), {}, {
                epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch
              }));
              _context46.next = 4;
              return this._rpcRequest('getInflationReward', args);
            case 4:
              unsafeRes = _context46.sent;
              res = create(unsafeRes, GetInflationRewardResult);
              if (!('error' in res)) {
                _context46.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');
            case 8:
              return _context46.abrupt("return", res.result);
            case 9:
            case "end":
              return _context46.stop();
          }
        }, _callee45, this);
      }));
      function getInflationReward(_x61, _x62, _x63) {
        return _getInflationReward.apply(this, arguments);
      }
      return getInflationReward;
    }()
    /**
     * Fetch the specific inflation values for the current epoch
     */
  }, {
    key: "getInflationRate",
    value: function () {
      var _getInflationRate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee46() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee46$(_context47) {
          while (1) switch (_context47.prev = _context47.next) {
            case 0:
              _context47.next = 2;
              return this._rpcRequest('getInflationRate', []);
            case 2:
              unsafeRes = _context47.sent;
              res = create(unsafeRes, GetInflationRateRpcResult);
              if (!('error' in res)) {
                _context47.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');
            case 6:
              return _context47.abrupt("return", res.result);
            case 7:
            case "end":
              return _context47.stop();
          }
        }, _callee46, this);
      }));
      function getInflationRate() {
        return _getInflationRate.apply(this, arguments);
      }
      return getInflationRate;
    }()
    /**
     * Fetch the Epoch Info parameters
     */
  }, {
    key: "getEpochInfo",
    value: function () {
      var _getEpochInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee47(commitmentOrConfig) {
        var _extractCommitmentFro15, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee47$(_context48) {
          while (1) switch (_context48.prev = _context48.next) {
            case 0:
              _extractCommitmentFro15 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro15.commitment, config = _extractCommitmentFro15.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context48.next = 4;
              return this._rpcRequest('getEpochInfo', args);
            case 4:
              unsafeRes = _context48.sent;
              res = create(unsafeRes, GetEpochInfoRpcResult);
              if (!('error' in res)) {
                _context48.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');
            case 8:
              return _context48.abrupt("return", res.result);
            case 9:
            case "end":
              return _context48.stop();
          }
        }, _callee47, this);
      }));
      function getEpochInfo(_x64) {
        return _getEpochInfo.apply(this, arguments);
      }
      return getEpochInfo;
    }()
    /**
     * Fetch the Epoch Schedule parameters
     */
  }, {
    key: "getEpochSchedule",
    value: function () {
      var _getEpochSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee48() {
        var unsafeRes, res, epochSchedule;
        return _regeneratorRuntime.wrap(function _callee48$(_context49) {
          while (1) switch (_context49.prev = _context49.next) {
            case 0:
              _context49.next = 2;
              return this._rpcRequest('getEpochSchedule', []);
            case 2:
              unsafeRes = _context49.sent;
              res = create(unsafeRes, GetEpochScheduleRpcResult);
              if (!('error' in res)) {
                _context49.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');
            case 6:
              epochSchedule = res.result;
              return _context49.abrupt("return", new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot));
            case 8:
            case "end":
              return _context49.stop();
          }
        }, _callee48, this);
      }));
      function getEpochSchedule() {
        return _getEpochSchedule.apply(this, arguments);
      }
      return getEpochSchedule;
    }()
    /**
     * Fetch the leader schedule for the current epoch
     * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
     */
  }, {
    key: "getLeaderSchedule",
    value: function () {
      var _getLeaderSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee49() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee49$(_context50) {
          while (1) switch (_context50.prev = _context50.next) {
            case 0:
              _context50.next = 2;
              return this._rpcRequest('getLeaderSchedule', []);
            case 2:
              unsafeRes = _context50.sent;
              res = create(unsafeRes, GetLeaderScheduleRpcResult);
              if (!('error' in res)) {
                _context50.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');
            case 6:
              return _context50.abrupt("return", res.result);
            case 7:
            case "end":
              return _context50.stop();
          }
        }, _callee49, this);
      }));
      function getLeaderSchedule() {
        return _getLeaderSchedule.apply(this, arguments);
      }
      return getLeaderSchedule;
    }()
    /**
     * Fetch the minimum balance needed to exempt an account of `dataLength`
     * size from rent
     */
  }, {
    key: "getMinimumBalanceForRentExemption",
    value: function () {
      var _getMinimumBalanceForRentExemption = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee50(dataLength, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee50$(_context51) {
          while (1) switch (_context51.prev = _context51.next) {
            case 0:
              args = this._buildArgs([dataLength], commitment);
              _context51.next = 3;
              return this._rpcRequest('getMinimumBalanceForRentExemption', args);
            case 3:
              unsafeRes = _context51.sent;
              res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
              if (!('error' in res)) {
                _context51.next = 8;
                break;
              }
              console.warn('Unable to fetch minimum balance for rent exemption');
              return _context51.abrupt("return", 0);
            case 8:
              return _context51.abrupt("return", res.result);
            case 9:
            case "end":
              return _context51.stop();
          }
        }, _callee50, this);
      }));
      function getMinimumBalanceForRentExemption(_x65, _x66) {
        return _getMinimumBalanceForRentExemption.apply(this, arguments);
      }
      return getMinimumBalanceForRentExemption;
    }()
    /**
     * Fetch a recent blockhash from the cluster, return with context
     * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
     */
  }, {
    key: "getRecentBlockhashAndContext",
    value: function () {
      var _getRecentBlockhashAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee51(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee51$(_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              args = this._buildArgs([], commitment);
              _context52.next = 3;
              return this._rpcRequest('getRecentBlockhash', args);
            case 3:
              unsafeRes = _context52.sent;
              res = create(unsafeRes, GetRecentBlockhashAndContextRpcResult);
              if (!('error' in res)) {
                _context52.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');
            case 7:
              return _context52.abrupt("return", res.result);
            case 8:
            case "end":
              return _context52.stop();
          }
        }, _callee51, this);
      }));
      function getRecentBlockhashAndContext(_x67) {
        return _getRecentBlockhashAndContext.apply(this, arguments);
      }
      return getRecentBlockhashAndContext;
    }()
    /**
     * Fetch recent performance samples
     * @return {Promise<Array<PerfSample>>}
     */
  }, {
    key: "getRecentPerformanceSamples",
    value: function () {
      var _getRecentPerformanceSamples = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee52(limit) {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee52$(_context53) {
          while (1) switch (_context53.prev = _context53.next) {
            case 0:
              _context53.next = 2;
              return this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);
            case 2:
              unsafeRes = _context53.sent;
              res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
              if (!('error' in res)) {
                _context53.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');
            case 6:
              return _context53.abrupt("return", res.result);
            case 7:
            case "end":
              return _context53.stop();
          }
        }, _callee52, this);
      }));
      function getRecentPerformanceSamples(_x68) {
        return _getRecentPerformanceSamples.apply(this, arguments);
      }
      return getRecentPerformanceSamples;
    }()
    /**
     * Fetch the fee calculator for a recent blockhash from the cluster, return with context
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
     */
  }, {
    key: "getFeeCalculatorForBlockhash",
    value: function () {
      var _getFeeCalculatorForBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee53(blockhash, commitment) {
        var args, unsafeRes, res, _res$result, context, value;
        return _regeneratorRuntime.wrap(function _callee53$(_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              args = this._buildArgs([blockhash], commitment);
              _context54.next = 3;
              return this._rpcRequest('getFeeCalculatorForBlockhash', args);
            case 3:
              unsafeRes = _context54.sent;
              res = create(unsafeRes, GetFeeCalculatorRpcResult);
              if (!('error' in res)) {
                _context54.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');
            case 7:
              _res$result = res.result, context = _res$result.context, value = _res$result.value;
              return _context54.abrupt("return", {
                context: context,
                value: value !== null ? value.feeCalculator : null
              });
            case 9:
            case "end":
              return _context54.stop();
          }
        }, _callee53, this);
      }));
      function getFeeCalculatorForBlockhash(_x69, _x70) {
        return _getFeeCalculatorForBlockhash.apply(this, arguments);
      }
      return getFeeCalculatorForBlockhash;
    }()
    /**
     * Fetch the fee for a message from the cluster, return with context
     */
  }, {
    key: "getFeeForMessage",
    value: function () {
      var _getFeeForMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee54(message, commitment) {
        var wireMessage, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee54$(_context55) {
          while (1) switch (_context55.prev = _context55.next) {
            case 0:
              wireMessage = toBuffer(message.serialize()).toString('base64');
              args = this._buildArgs([wireMessage], commitment);
              _context55.next = 4;
              return this._rpcRequest('getFeeForMessage', args);
            case 4:
              unsafeRes = _context55.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(nullable(number())));
              if (!('error' in res)) {
                _context55.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');
            case 8:
              if (!(res.result === null)) {
                _context55.next = 10;
                break;
              }
              throw new Error('invalid blockhash');
            case 10:
              return _context55.abrupt("return", res.result);
            case 11:
            case "end":
              return _context55.stop();
          }
        }, _callee54, this);
      }));
      function getFeeForMessage(_x71, _x72) {
        return _getFeeForMessage.apply(this, arguments);
      }
      return getFeeForMessage;
    }()
    /**
     * Fetch a list of prioritization fees from recent blocks.
     */
  }, {
    key: "getRecentPrioritizationFees",
    value: function () {
      var _getRecentPrioritizationFees = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee55(config) {
        var _config$lockedWritabl;
        var accounts, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee55$(_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              accounts = config === null || config === void 0 ? void 0 : (_config$lockedWritabl = config.lockedWritableAccounts) === null || _config$lockedWritabl === void 0 ? void 0 : _config$lockedWritabl.map(function (key) {
                return key.toBase58();
              });
              args = accounts !== null && accounts !== void 0 && accounts.length ? [accounts] : [];
              _context56.next = 4;
              return this._rpcRequest('getRecentPrioritizationFees', args);
            case 4:
              unsafeRes = _context56.sent;
              res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
              if (!('error' in res)) {
                _context56.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get recent prioritization fees');
            case 8:
              return _context56.abrupt("return", res.result);
            case 9:
            case "end":
              return _context56.stop();
          }
        }, _callee55, this);
      }));
      function getRecentPrioritizationFees(_x73) {
        return _getRecentPrioritizationFees.apply(this, arguments);
      }
      return getRecentPrioritizationFees;
    }()
    /**
     * Fetch a recent blockhash from the cluster
     * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
     */
  }, {
    key: "getRecentBlockhash",
    value: function () {
      var _getRecentBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee56(commitment) {
        var res;
        return _regeneratorRuntime.wrap(function _callee56$(_context57) {
          while (1) switch (_context57.prev = _context57.next) {
            case 0:
              _context57.prev = 0;
              _context57.next = 3;
              return this.getRecentBlockhashAndContext(commitment);
            case 3:
              res = _context57.sent;
              return _context57.abrupt("return", res.value);
            case 7:
              _context57.prev = 7;
              _context57.t0 = _context57["catch"](0);
              throw new Error('failed to get recent blockhash: ' + _context57.t0);
            case 10:
            case "end":
              return _context57.stop();
          }
        }, _callee56, this, [[0, 7]]);
      }));
      function getRecentBlockhash(_x74) {
        return _getRecentBlockhash.apply(this, arguments);
      }
      return getRecentBlockhash;
    }()
    /**
     * Fetch the latest blockhash from the cluster
     * @return {Promise<BlockhashWithExpiryBlockHeight>}
     */
  }, {
    key: "getLatestBlockhash",
    value: function () {
      var _getLatestBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee57(commitmentOrConfig) {
        var res;
        return _regeneratorRuntime.wrap(function _callee57$(_context58) {
          while (1) switch (_context58.prev = _context58.next) {
            case 0:
              _context58.prev = 0;
              _context58.next = 3;
              return this.getLatestBlockhashAndContext(commitmentOrConfig);
            case 3:
              res = _context58.sent;
              return _context58.abrupt("return", res.value);
            case 7:
              _context58.prev = 7;
              _context58.t0 = _context58["catch"](0);
              throw new Error('failed to get recent blockhash: ' + _context58.t0);
            case 10:
            case "end":
              return _context58.stop();
          }
        }, _callee57, this, [[0, 7]]);
      }));
      function getLatestBlockhash(_x75) {
        return _getLatestBlockhash.apply(this, arguments);
      }
      return getLatestBlockhash;
    }()
    /**
     * Fetch the latest blockhash from the cluster
     * @return {Promise<BlockhashWithExpiryBlockHeight>}
     */
  }, {
    key: "getLatestBlockhashAndContext",
    value: function () {
      var _getLatestBlockhashAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee58(commitmentOrConfig) {
        var _extractCommitmentFro16, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee58$(_context59) {
          while (1) switch (_context59.prev = _context59.next) {
            case 0:
              _extractCommitmentFro16 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro16.commitment, config = _extractCommitmentFro16.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context59.next = 4;
              return this._rpcRequest('getLatestBlockhash', args);
            case 4:
              unsafeRes = _context59.sent;
              res = create(unsafeRes, GetLatestBlockhashRpcResult);
              if (!('error' in res)) {
                _context59.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');
            case 8:
              return _context59.abrupt("return", res.result);
            case 9:
            case "end":
              return _context59.stop();
          }
        }, _callee58, this);
      }));
      function getLatestBlockhashAndContext(_x76) {
        return _getLatestBlockhashAndContext.apply(this, arguments);
      }
      return getLatestBlockhashAndContext;
    }()
    /**
     * Returns whether a blockhash is still valid or not
     */
  }, {
    key: "isBlockhashValid",
    value: function () {
      var _isBlockhashValid = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee59(blockhash, rawConfig) {
        var _extractCommitmentFro17, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee59$(_context60) {
          while (1) switch (_context60.prev = _context60.next) {
            case 0:
              _extractCommitmentFro17 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro17.commitment, config = _extractCommitmentFro17.config;
              args = this._buildArgs([blockhash], commitment, undefined /* encoding */, config);
              _context60.next = 4;
              return this._rpcRequest('isBlockhashValid', args);
            case 4:
              unsafeRes = _context60.sent;
              res = create(unsafeRes, IsBlockhashValidRpcResult);
              if (!('error' in res)) {
                _context60.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to determine if the blockhash `' + blockhash + '`is valid');
            case 8:
              return _context60.abrupt("return", res.result);
            case 9:
            case "end":
              return _context60.stop();
          }
        }, _callee59, this);
      }));
      function isBlockhashValid(_x77, _x78) {
        return _isBlockhashValid.apply(this, arguments);
      }
      return isBlockhashValid;
    }()
    /**
     * Fetch the node version
     */
  }, {
    key: "getVersion",
    value: function () {
      var _getVersion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee60() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee60$(_context61) {
          while (1) switch (_context61.prev = _context61.next) {
            case 0:
              _context61.next = 2;
              return this._rpcRequest('getVersion', []);
            case 2:
              unsafeRes = _context61.sent;
              res = create(unsafeRes, jsonRpcResult(VersionResult));
              if (!('error' in res)) {
                _context61.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get version');
            case 6:
              return _context61.abrupt("return", res.result);
            case 7:
            case "end":
              return _context61.stop();
          }
        }, _callee60, this);
      }));
      function getVersion() {
        return _getVersion.apply(this, arguments);
      }
      return getVersion;
    }()
    /**
     * Fetch the genesis hash
     */
  }, {
    key: "getGenesisHash",
    value: function () {
      var _getGenesisHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee61() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee61$(_context62) {
          while (1) switch (_context62.prev = _context62.next) {
            case 0:
              _context62.next = 2;
              return this._rpcRequest('getGenesisHash', []);
            case 2:
              unsafeRes = _context62.sent;
              res = create(unsafeRes, jsonRpcResult(string()));
              if (!('error' in res)) {
                _context62.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');
            case 6:
              return _context62.abrupt("return", res.result);
            case 7:
            case "end":
              return _context62.stop();
          }
        }, _callee61, this);
      }));
      function getGenesisHash() {
        return _getGenesisHash.apply(this, arguments);
      }
      return getGenesisHash;
    }()
    /**
     * Fetch a processed block from the cluster.
     *
     * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
     * setting the `maxSupportedTransactionVersion` property.
     */
  }, {
    key: "getBlock",
    value:
    /**
     * Fetch a processed block from the cluster.
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee62(slot, rawConfig) {
        var _extractCommitmentFro18, commitment, config, args, unsafeRes, res, _res, _res2, result;
        return _regeneratorRuntime.wrap(function _callee62$(_context63) {
          while (1) switch (_context63.prev = _context63.next) {
            case 0:
              _extractCommitmentFro18 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro18.commitment, config = _extractCommitmentFro18.config;
              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined /* encoding */, config);
              _context63.next = 4;
              return this._rpcRequest('getBlock', args);
            case 4:
              unsafeRes = _context63.sent;
              _context63.prev = 5;
              _context63.t0 = config === null || config === void 0 ? void 0 : config.transactionDetails;
              _context63.next = _context63.t0 === 'accounts' ? 9 : _context63.t0 === 'none' ? 13 : 17;
              break;
            case 9:
              res = create(unsafeRes, GetAccountsModeBlockRpcResult);
              if (!('error' in res)) {
                _context63.next = 12;
                break;
              }
              throw res.error;
            case 12:
              return _context63.abrupt("return", res.result);
            case 13:
              _res = create(unsafeRes, GetNoneModeBlockRpcResult);
              if (!('error' in _res)) {
                _context63.next = 16;
                break;
              }
              throw _res.error;
            case 16:
              return _context63.abrupt("return", _res.result);
            case 17:
              _res2 = create(unsafeRes, GetBlockRpcResult);
              if (!('error' in _res2)) {
                _context63.next = 20;
                break;
              }
              throw _res2.error;
            case 20:
              result = _res2.result;
              return _context63.abrupt("return", result ? _objectSpread(_objectSpread({}, result), {}, {
                transactions: result.transactions.map(function (_ref15) {
                  var transaction = _ref15.transaction,
                    meta = _ref15.meta,
                    version = _ref15.version;
                  return {
                    meta: meta,
                    transaction: _objectSpread(_objectSpread({}, transaction), {}, {
                      message: versionedMessageFromResponse(version, transaction.message)
                    }),
                    version: version
                  };
                })
              }) : null);
            case 22:
              _context63.next = 27;
              break;
            case 24:
              _context63.prev = 24;
              _context63.t1 = _context63["catch"](5);
              throw new SolanaJSONRPCError(_context63.t1, 'failed to get confirmed block');
            case 27:
            case "end":
              return _context63.stop();
          }
        }, _callee62, this, [[5, 24]]);
      }));
      function getBlock(_x79, _x80) {
        return _getBlock.apply(this, arguments);
      }
      return getBlock;
    }()
    /**
     * Fetch parsed transaction details for a confirmed or finalized block
     */
  }, {
    key: "getParsedBlock",
    value: // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getParsedBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee63(slot, rawConfig) {
        var _extractCommitmentFro19, commitment, config, args, unsafeRes, res, _res3, _res4;
        return _regeneratorRuntime.wrap(function _callee63$(_context64) {
          while (1) switch (_context64.prev = _context64.next) {
            case 0:
              _extractCommitmentFro19 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro19.commitment, config = _extractCommitmentFro19.config;
              args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);
              _context64.next = 4;
              return this._rpcRequest('getBlock', args);
            case 4:
              unsafeRes = _context64.sent;
              _context64.prev = 5;
              _context64.t0 = config === null || config === void 0 ? void 0 : config.transactionDetails;
              _context64.next = _context64.t0 === 'accounts' ? 9 : _context64.t0 === 'none' ? 13 : 17;
              break;
            case 9:
              res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
              if (!('error' in res)) {
                _context64.next = 12;
                break;
              }
              throw res.error;
            case 12:
              return _context64.abrupt("return", res.result);
            case 13:
              _res3 = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
              if (!('error' in _res3)) {
                _context64.next = 16;
                break;
              }
              throw _res3.error;
            case 16:
              return _context64.abrupt("return", _res3.result);
            case 17:
              _res4 = create(unsafeRes, GetParsedBlockRpcResult);
              if (!('error' in _res4)) {
                _context64.next = 20;
                break;
              }
              throw _res4.error;
            case 20:
              return _context64.abrupt("return", _res4.result);
            case 21:
              _context64.next = 26;
              break;
            case 23:
              _context64.prev = 23;
              _context64.t1 = _context64["catch"](5);
              throw new SolanaJSONRPCError(_context64.t1, 'failed to get block');
            case 26:
            case "end":
              return _context64.stop();
          }
        }, _callee63, this, [[5, 23]]);
      }));
      function getParsedBlock(_x81, _x82) {
        return _getParsedBlock.apply(this, arguments);
      }
      return getParsedBlock;
    }()
  }, {
    key: "getBlockProduction",
    value:
    /*
     * Returns recent block production information from the current or previous epoch
     */
    function () {
      var _getBlockProduction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee64(configOrCommitment) {
        var extra, commitment, c, rest, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee64$(_context65) {
          while (1) switch (_context65.prev = _context65.next) {
            case 0:
              if (typeof configOrCommitment === 'string') {
                commitment = configOrCommitment;
              } else if (configOrCommitment) {
                c = configOrCommitment.commitment, rest = _objectWithoutProperties(configOrCommitment, _excluded3);
                commitment = c;
                extra = rest;
              }
              args = this._buildArgs([], commitment, 'base64', extra);
              _context65.next = 4;
              return this._rpcRequest('getBlockProduction', args);
            case 4:
              unsafeRes = _context65.sent;
              res = create(unsafeRes, BlockProductionResponseStruct);
              if (!('error' in res)) {
                _context65.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get block production information');
            case 8:
              return _context65.abrupt("return", res.result);
            case 9:
            case "end":
              return _context65.stop();
          }
        }, _callee64, this);
      }));
      function getBlockProduction(_x83) {
        return _getBlockProduction.apply(this, arguments);
      }
      return getBlockProduction;
    }()
    /**
     * Fetch a confirmed or finalized transaction from the cluster.
     *
     * @deprecated Instead, call `getTransaction` using a
     * `GetVersionedTransactionConfig` by setting the
     * `maxSupportedTransactionVersion` property.
     */
  }, {
    key: "getTransaction",
    value:
    /**
     * Fetch a confirmed or finalized transaction from the cluster.
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee65(signature, rawConfig) {
        var _extractCommitmentFro20, commitment, config, args, unsafeRes, res, result;
        return _regeneratorRuntime.wrap(function _callee65$(_context66) {
          while (1) switch (_context66.prev = _context66.next) {
            case 0:
              _extractCommitmentFro20 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro20.commitment, config = _extractCommitmentFro20.config;
              args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);
              _context66.next = 4;
              return this._rpcRequest('getTransaction', args);
            case 4:
              unsafeRes = _context66.sent;
              res = create(unsafeRes, GetTransactionRpcResult);
              if (!('error' in res)) {
                _context66.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
            case 8:
              result = res.result;
              if (result) {
                _context66.next = 11;
                break;
              }
              return _context66.abrupt("return", result);
            case 11:
              return _context66.abrupt("return", _objectSpread(_objectSpread({}, result), {}, {
                transaction: _objectSpread(_objectSpread({}, result.transaction), {}, {
                  message: versionedMessageFromResponse(result.version, result.transaction.message)
                })
              }));
            case 12:
            case "end":
              return _context66.stop();
          }
        }, _callee65, this);
      }));
      function getTransaction(_x84, _x85) {
        return _getTransaction.apply(this, arguments);
      }
      return getTransaction;
    }()
    /**
     * Fetch parsed transaction details for a confirmed or finalized transaction
     */
  }, {
    key: "getParsedTransaction",
    value: function () {
      var _getParsedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee66(signature, commitmentOrConfig) {
        var _extractCommitmentFro21, commitment, config, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee66$(_context67) {
          while (1) switch (_context67.prev = _context67.next) {
            case 0:
              _extractCommitmentFro21 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro21.commitment, config = _extractCommitmentFro21.config;
              args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
              _context67.next = 4;
              return this._rpcRequest('getTransaction', args);
            case 4:
              unsafeRes = _context67.sent;
              res = create(unsafeRes, GetParsedTransactionRpcResult);
              if (!('error' in res)) {
                _context67.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
            case 8:
              return _context67.abrupt("return", res.result);
            case 9:
            case "end":
              return _context67.stop();
          }
        }, _callee66, this);
      }));
      function getParsedTransaction(_x86, _x87) {
        return _getParsedTransaction.apply(this, arguments);
      }
      return getParsedTransaction;
    }()
    /**
     * Fetch parsed transaction details for a batch of confirmed transactions
     */
  }, {
    key: "getParsedTransactions",
    value: function () {
      var _getParsedTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee67(signatures, commitmentOrConfig) {
        var _this6 = this;
        var _extractCommitmentFro22, commitment, config, batch, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee67$(_context68) {
          while (1) switch (_context68.prev = _context68.next) {
            case 0:
              _extractCommitmentFro22 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro22.commitment, config = _extractCommitmentFro22.config;
              batch = signatures.map(function (signature) {
                var args = _this6._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
                return {
                  methodName: 'getTransaction',
                  args: args
                };
              });
              _context68.next = 4;
              return this._rpcBatchRequest(batch);
            case 4:
              unsafeRes = _context68.sent;
              res = unsafeRes.map(function (unsafeRes) {
                var res = create(unsafeRes, GetParsedTransactionRpcResult);
                if ('error' in res) {
                  throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
                }
                return res.result;
              });
              return _context68.abrupt("return", res);
            case 7:
            case "end":
              return _context68.stop();
          }
        }, _callee67, this);
      }));
      function getParsedTransactions(_x88, _x89) {
        return _getParsedTransactions.apply(this, arguments);
      }
      return getParsedTransactions;
    }()
    /**
     * Fetch transaction details for a batch of confirmed transactions.
     * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
     *
     * @deprecated Instead, call `getTransactions` using a
     * `GetVersionedTransactionConfig` by setting the
     * `maxSupportedTransactionVersion` property.
     */
  }, {
    key: "getTransactions",
    value:
    /**
     * Fetch transaction details for a batch of confirmed transactions.
     * Similar to {@link getParsedTransactions} but returns a {@link
     * VersionedTransactionResponse}.
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee68(signatures, commitmentOrConfig) {
        var _this7 = this;
        var _extractCommitmentFro23, commitment, config, batch, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee68$(_context69) {
          while (1) switch (_context69.prev = _context69.next) {
            case 0:
              _extractCommitmentFro23 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro23.commitment, config = _extractCommitmentFro23.config;
              batch = signatures.map(function (signature) {
                var args = _this7._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);
                return {
                  methodName: 'getTransaction',
                  args: args
                };
              });
              _context69.next = 4;
              return this._rpcBatchRequest(batch);
            case 4:
              unsafeRes = _context69.sent;
              res = unsafeRes.map(function (unsafeRes) {
                var res = create(unsafeRes, GetTransactionRpcResult);
                if ('error' in res) {
                  throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
                }
                var result = res.result;
                if (!result) return result;
                return _objectSpread(_objectSpread({}, result), {}, {
                  transaction: _objectSpread(_objectSpread({}, result.transaction), {}, {
                    message: versionedMessageFromResponse(result.version, result.transaction.message)
                  })
                });
              });
              return _context69.abrupt("return", res);
            case 7:
            case "end":
              return _context69.stop();
          }
        }, _callee68, this);
      }));
      function getTransactions(_x90, _x91) {
        return _getTransactions.apply(this, arguments);
      }
      return getTransactions;
    }()
    /**
     * Fetch a list of Transactions and transaction statuses from the cluster
     * for a confirmed block.
     *
     * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
     */
  }, {
    key: "getConfirmedBlock",
    value: function () {
      var _getConfirmedBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee69(slot, commitment) {
        var args, unsafeRes, res, result, block;
        return _regeneratorRuntime.wrap(function _callee69$(_context70) {
          while (1) switch (_context70.prev = _context70.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([slot], commitment);
              _context70.next = 3;
              return this._rpcRequest('getConfirmedBlock', args);
            case 3:
              unsafeRes = _context70.sent;
              res = create(unsafeRes, GetConfirmedBlockRpcResult);
              if (!('error' in res)) {
                _context70.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
            case 7:
              result = res.result;
              if (result) {
                _context70.next = 10;
                break;
              }
              throw new Error('Confirmed block ' + slot + ' not found');
            case 10:
              block = _objectSpread(_objectSpread({}, result), {}, {
                transactions: result.transactions.map(function (_ref16) {
                  var transaction = _ref16.transaction,
                    meta = _ref16.meta;
                  var message = new Message(transaction.message);
                  return {
                    meta: meta,
                    transaction: _objectSpread(_objectSpread({}, transaction), {}, {
                      message: message
                    })
                  };
                })
              });
              return _context70.abrupt("return", _objectSpread(_objectSpread({}, block), {}, {
                transactions: block.transactions.map(function (_ref17) {
                  var transaction = _ref17.transaction,
                    meta = _ref17.meta;
                  return {
                    meta: meta,
                    transaction: Transaction.populate(transaction.message, transaction.signatures)
                  };
                })
              }));
            case 12:
            case "end":
              return _context70.stop();
          }
        }, _callee69, this);
      }));
      function getConfirmedBlock(_x92, _x93) {
        return _getConfirmedBlock.apply(this, arguments);
      }
      return getConfirmedBlock;
    }()
    /**
     * Fetch confirmed blocks between two slots
     */
  }, {
    key: "getBlocks",
    value: function () {
      var _getBlocks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee70(startSlot, endSlot, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee70$(_context71) {
          while (1) switch (_context71.prev = _context71.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);
              _context71.next = 3;
              return this._rpcRequest('getBlocks', args);
            case 3:
              unsafeRes = _context71.sent;
              res = create(unsafeRes, jsonRpcResult(array(number())));
              if (!('error' in res)) {
                _context71.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get blocks');
            case 7:
              return _context71.abrupt("return", res.result);
            case 8:
            case "end":
              return _context71.stop();
          }
        }, _callee70, this);
      }));
      function getBlocks(_x94, _x95, _x96) {
        return _getBlocks.apply(this, arguments);
      }
      return getBlocks;
    }()
    /**
     * Fetch a list of Signatures from the cluster for a block, excluding rewards
     */
  }, {
    key: "getBlockSignatures",
    value: function () {
      var _getBlockSignatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee71(slot, commitment) {
        var args, unsafeRes, res, result;
        return _regeneratorRuntime.wrap(function _callee71$(_context72) {
          while (1) switch (_context72.prev = _context72.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
                transactionDetails: 'signatures',
                rewards: false
              });
              _context72.next = 3;
              return this._rpcRequest('getBlock', args);
            case 3:
              unsafeRes = _context72.sent;
              res = create(unsafeRes, GetBlockSignaturesRpcResult);
              if (!('error' in res)) {
                _context72.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get block');
            case 7:
              result = res.result;
              if (result) {
                _context72.next = 10;
                break;
              }
              throw new Error('Block ' + slot + ' not found');
            case 10:
              return _context72.abrupt("return", result);
            case 11:
            case "end":
              return _context72.stop();
          }
        }, _callee71, this);
      }));
      function getBlockSignatures(_x97, _x98) {
        return _getBlockSignatures.apply(this, arguments);
      }
      return getBlockSignatures;
    }()
    /**
     * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
     */
  }, {
    key: "getConfirmedBlockSignatures",
    value: function () {
      var _getConfirmedBlockSignatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee72(slot, commitment) {
        var args, unsafeRes, res, result;
        return _regeneratorRuntime.wrap(function _callee72$(_context73) {
          while (1) switch (_context73.prev = _context73.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
                transactionDetails: 'signatures',
                rewards: false
              });
              _context73.next = 3;
              return this._rpcRequest('getConfirmedBlock', args);
            case 3:
              unsafeRes = _context73.sent;
              res = create(unsafeRes, GetBlockSignaturesRpcResult);
              if (!('error' in res)) {
                _context73.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
            case 7:
              result = res.result;
              if (result) {
                _context73.next = 10;
                break;
              }
              throw new Error('Confirmed block ' + slot + ' not found');
            case 10:
              return _context73.abrupt("return", result);
            case 11:
            case "end":
              return _context73.stop();
          }
        }, _callee72, this);
      }));
      function getConfirmedBlockSignatures(_x99, _x100) {
        return _getConfirmedBlockSignatures.apply(this, arguments);
      }
      return getConfirmedBlockSignatures;
    }()
    /**
     * Fetch a transaction details for a confirmed transaction
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
     */
  }, {
    key: "getConfirmedTransaction",
    value: function () {
      var _getConfirmedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee73(signature, commitment) {
        var args, unsafeRes, res, result, message, signatures;
        return _regeneratorRuntime.wrap(function _callee73$(_context74) {
          while (1) switch (_context74.prev = _context74.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([signature], commitment);
              _context74.next = 3;
              return this._rpcRequest('getConfirmedTransaction', args);
            case 3:
              unsafeRes = _context74.sent;
              res = create(unsafeRes, GetTransactionRpcResult);
              if (!('error' in res)) {
                _context74.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
            case 7:
              result = res.result;
              if (result) {
                _context74.next = 10;
                break;
              }
              return _context74.abrupt("return", result);
            case 10:
              message = new Message(result.transaction.message);
              signatures = result.transaction.signatures;
              return _context74.abrupt("return", _objectSpread(_objectSpread({}, result), {}, {
                transaction: Transaction.populate(message, signatures)
              }));
            case 13:
            case "end":
              return _context74.stop();
          }
        }, _callee73, this);
      }));
      function getConfirmedTransaction(_x101, _x102) {
        return _getConfirmedTransaction.apply(this, arguments);
      }
      return getConfirmedTransaction;
    }()
    /**
     * Fetch parsed transaction details for a confirmed transaction
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
     */
  }, {
    key: "getParsedConfirmedTransaction",
    value: function () {
      var _getParsedConfirmedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee74(signature, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee74$(_context75) {
          while (1) switch (_context75.prev = _context75.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
              _context75.next = 3;
              return this._rpcRequest('getConfirmedTransaction', args);
            case 3:
              unsafeRes = _context75.sent;
              res = create(unsafeRes, GetParsedTransactionRpcResult);
              if (!('error' in res)) {
                _context75.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');
            case 7:
              return _context75.abrupt("return", res.result);
            case 8:
            case "end":
              return _context75.stop();
          }
        }, _callee74, this);
      }));
      function getParsedConfirmedTransaction(_x103, _x104) {
        return _getParsedConfirmedTransaction.apply(this, arguments);
      }
      return getParsedConfirmedTransaction;
    }()
    /**
     * Fetch parsed transaction details for a batch of confirmed transactions
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
     */
  }, {
    key: "getParsedConfirmedTransactions",
    value: function () {
      var _getParsedConfirmedTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee75(signatures, commitment) {
        var _this8 = this;
        var batch, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee75$(_context76) {
          while (1) switch (_context76.prev = _context76.next) {
            case 0:
              batch = signatures.map(function (signature) {
                var args = _this8._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
                return {
                  methodName: 'getConfirmedTransaction',
                  args: args
                };
              });
              _context76.next = 3;
              return this._rpcBatchRequest(batch);
            case 3:
              unsafeRes = _context76.sent;
              res = unsafeRes.map(function (unsafeRes) {
                var res = create(unsafeRes, GetParsedTransactionRpcResult);
                if ('error' in res) {
                  throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');
                }
                return res.result;
              });
              return _context76.abrupt("return", res);
            case 6:
            case "end":
              return _context76.stop();
          }
        }, _callee75, this);
      }));
      function getParsedConfirmedTransactions(_x105, _x106) {
        return _getParsedConfirmedTransactions.apply(this, arguments);
      }
      return getParsedConfirmedTransactions;
    }()
    /**
     * Fetch a list of all the confirmed signatures for transactions involving an address
     * within a specified slot range. Max range allowed is 10,000 slots.
     *
     * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
     *
     * @param address queried address
     * @param startSlot start slot, inclusive
     * @param endSlot end slot, inclusive
     */
  }, {
    key: "getConfirmedSignaturesForAddress",
    value: function () {
      var _getConfirmedSignaturesForAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee76(address, startSlot, endSlot) {
        var options, firstAvailableBlock, block, highestConfirmedRoot, _block, confirmedSignatureInfo;
        return _regeneratorRuntime.wrap(function _callee76$(_context77) {
          while (1) switch (_context77.prev = _context77.next) {
            case 0:
              options = {};
              _context77.next = 3;
              return this.getFirstAvailableBlock();
            case 3:
              firstAvailableBlock = _context77.sent;
            case 4:
              if ('until' in options) {
                _context77.next = 24;
                break;
              }
              startSlot--;
              if (!(startSlot <= 0 || startSlot < firstAvailableBlock)) {
                _context77.next = 8;
                break;
              }
              return _context77.abrupt("break", 24);
            case 8:
              _context77.prev = 8;
              _context77.next = 11;
              return this.getConfirmedBlockSignatures(startSlot, 'finalized');
            case 11:
              block = _context77.sent;
              if (block.signatures.length > 0) {
                options.until = block.signatures[block.signatures.length - 1].toString();
              }
              _context77.next = 22;
              break;
            case 15:
              _context77.prev = 15;
              _context77.t0 = _context77["catch"](8);
              if (!(_context77.t0 instanceof Error && _context77.t0.message.includes('skipped'))) {
                _context77.next = 21;
                break;
              }
              return _context77.abrupt("continue", 4);
            case 21:
              throw _context77.t0;
            case 22:
              _context77.next = 4;
              break;
            case 24:
              _context77.next = 26;
              return this.getSlot('finalized');
            case 26:
              highestConfirmedRoot = _context77.sent;
            case 27:
              if ('before' in options) {
                _context77.next = 47;
                break;
              }
              endSlot++;
              if (!(endSlot > highestConfirmedRoot)) {
                _context77.next = 31;
                break;
              }
              return _context77.abrupt("break", 47);
            case 31:
              _context77.prev = 31;
              _context77.next = 34;
              return this.getConfirmedBlockSignatures(endSlot);
            case 34:
              _block = _context77.sent;
              if (_block.signatures.length > 0) {
                options.before = _block.signatures[_block.signatures.length - 1].toString();
              }
              _context77.next = 45;
              break;
            case 38:
              _context77.prev = 38;
              _context77.t1 = _context77["catch"](31);
              if (!(_context77.t1 instanceof Error && _context77.t1.message.includes('skipped'))) {
                _context77.next = 44;
                break;
              }
              return _context77.abrupt("continue", 27);
            case 44:
              throw _context77.t1;
            case 45:
              _context77.next = 27;
              break;
            case 47:
              _context77.next = 49;
              return this.getConfirmedSignaturesForAddress2(address, options);
            case 49:
              confirmedSignatureInfo = _context77.sent;
              return _context77.abrupt("return", confirmedSignatureInfo.map(function (info) {
                return info.signature;
              }));
            case 51:
            case "end":
              return _context77.stop();
          }
        }, _callee76, this, [[8, 15], [31, 38]]);
      }));
      function getConfirmedSignaturesForAddress(_x107, _x108, _x109) {
        return _getConfirmedSignaturesForAddress.apply(this, arguments);
      }
      return getConfirmedSignaturesForAddress;
    }()
    /**
     * Returns confirmed signatures for transactions involving an
     * address backwards in time from the provided signature or most recent confirmed block
     *
     *
     * @param address queried address
     * @param options
     */
  }, {
    key: "getConfirmedSignaturesForAddress2",
    value: function () {
      var _getConfirmedSignaturesForAddress2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee77(address, options, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee77$(_context78) {
          while (1) switch (_context78.prev = _context78.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
              _context78.next = 3;
              return this._rpcRequest('getConfirmedSignaturesForAddress2', args);
            case 3:
              unsafeRes = _context78.sent;
              res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
              if (!('error' in res)) {
                _context78.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');
            case 7:
              return _context78.abrupt("return", res.result);
            case 8:
            case "end":
              return _context78.stop();
          }
        }, _callee77, this);
      }));
      function getConfirmedSignaturesForAddress2(_x110, _x111, _x112) {
        return _getConfirmedSignaturesForAddress2.apply(this, arguments);
      }
      return getConfirmedSignaturesForAddress2;
    }()
    /**
     * Returns confirmed signatures for transactions involving an
     * address backwards in time from the provided signature or most recent confirmed block
     *
     *
     * @param address queried address
     * @param options
     */
  }, {
    key: "getSignaturesForAddress",
    value: function () {
      var _getSignaturesForAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee78(address, options, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee78$(_context79) {
          while (1) switch (_context79.prev = _context79.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
              _context79.next = 3;
              return this._rpcRequest('getSignaturesForAddress', args);
            case 3:
              unsafeRes = _context79.sent;
              res = create(unsafeRes, GetSignaturesForAddressRpcResult);
              if (!('error' in res)) {
                _context79.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');
            case 7:
              return _context79.abrupt("return", res.result);
            case 8:
            case "end":
              return _context79.stop();
          }
        }, _callee78, this);
      }));
      function getSignaturesForAddress(_x113, _x114, _x115) {
        return _getSignaturesForAddress.apply(this, arguments);
      }
      return getSignaturesForAddress;
    }()
  }, {
    key: "getAddressLookupTable",
    value: function () {
      var _getAddressLookupTable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee79(accountKey, config) {
        var _yield$this$getAccoun, context, accountInfo, value;
        return _regeneratorRuntime.wrap(function _callee79$(_context80) {
          while (1) switch (_context80.prev = _context80.next) {
            case 0:
              _context80.next = 2;
              return this.getAccountInfoAndContext(accountKey, config);
            case 2:
              _yield$this$getAccoun = _context80.sent;
              context = _yield$this$getAccoun.context;
              accountInfo = _yield$this$getAccoun.value;
              value = null;
              if (accountInfo !== null) {
                value = new AddressLookupTableAccount({
                  key: accountKey,
                  state: AddressLookupTableAccount.deserialize(accountInfo.data)
                });
              }
              return _context80.abrupt("return", {
                context: context,
                value: value
              });
            case 8:
            case "end":
              return _context80.stop();
          }
        }, _callee79, this);
      }));
      function getAddressLookupTable(_x116, _x117) {
        return _getAddressLookupTable.apply(this, arguments);
      }
      return getAddressLookupTable;
    }()
    /**
     * Fetch the contents of a Nonce account from the cluster, return with context
     */
  }, {
    key: "getNonceAndContext",
    value: function () {
      var _getNonceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee80(nonceAccount, commitmentOrConfig) {
        var _yield$this$getAccoun2, context, accountInfo, value;
        return _regeneratorRuntime.wrap(function _callee80$(_context81) {
          while (1) switch (_context81.prev = _context81.next) {
            case 0:
              _context81.next = 2;
              return this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
            case 2:
              _yield$this$getAccoun2 = _context81.sent;
              context = _yield$this$getAccoun2.context;
              accountInfo = _yield$this$getAccoun2.value;
              value = null;
              if (accountInfo !== null) {
                value = NonceAccount.fromAccountData(accountInfo.data);
              }
              return _context81.abrupt("return", {
                context: context,
                value: value
              });
            case 8:
            case "end":
              return _context81.stop();
          }
        }, _callee80, this);
      }));
      function getNonceAndContext(_x118, _x119) {
        return _getNonceAndContext.apply(this, arguments);
      }
      return getNonceAndContext;
    }()
    /**
     * Fetch the contents of a Nonce account from the cluster
     */
  }, {
    key: "getNonce",
    value: function () {
      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee81(nonceAccount, commitmentOrConfig) {
        return _regeneratorRuntime.wrap(function _callee81$(_context82) {
          while (1) switch (_context82.prev = _context82.next) {
            case 0:
              _context82.next = 2;
              return this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(function (x) {
                return x.value;
              })["catch"](function (e) {
                throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);
              });
            case 2:
              return _context82.abrupt("return", _context82.sent);
            case 3:
            case "end":
              return _context82.stop();
          }
        }, _callee81, this);
      }));
      function getNonce(_x120, _x121) {
        return _getNonce.apply(this, arguments);
      }
      return getNonce;
    }()
    /**
     * Request an allocation of lamports to the specified address
     *
     * ```typescript
     * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
     *
     * (async () => {
     *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
     *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
     *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
     *   await connection.confirmTransaction(signature);
     * })();
     * ```
     */
  }, {
    key: "requestAirdrop",
    value: function () {
      var _requestAirdrop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee82(to, lamports) {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee82$(_context83) {
          while (1) switch (_context83.prev = _context83.next) {
            case 0:
              _context83.next = 2;
              return this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);
            case 2:
              unsafeRes = _context83.sent;
              res = create(unsafeRes, RequestAirdropRpcResult);
              if (!('error' in res)) {
                _context83.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "airdrop to ".concat(to.toBase58(), " failed"));
            case 6:
              return _context83.abrupt("return", res.result);
            case 7:
            case "end":
              return _context83.stop();
          }
        }, _callee82, this);
      }));
      function requestAirdrop(_x122, _x123) {
        return _requestAirdrop.apply(this, arguments);
      }
      return requestAirdrop;
    }()
    /**
     * @internal
     */
  }, {
    key: "_blockhashWithExpiryBlockHeight",
    value: function () {
      var _blockhashWithExpiryBlockHeight2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee83(disableCache) {
        var timeSinceFetch, expired;
        return _regeneratorRuntime.wrap(function _callee83$(_context84) {
          while (1) switch (_context84.prev = _context84.next) {
            case 0:
              if (disableCache) {
                _context84.next = 10;
                break;
              }
            case 1:
              if (!this._pollingBlockhash) {
                _context84.next = 6;
                break;
              }
              _context84.next = 4;
              return sleep(100);
            case 4:
              _context84.next = 1;
              break;
            case 6:
              timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
              expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
              if (!(this._blockhashInfo.latestBlockhash !== null && !expired)) {
                _context84.next = 10;
                break;
              }
              return _context84.abrupt("return", this._blockhashInfo.latestBlockhash);
            case 10:
              _context84.next = 12;
              return this._pollNewBlockhash();
            case 12:
              return _context84.abrupt("return", _context84.sent);
            case 13:
            case "end":
              return _context84.stop();
          }
        }, _callee83, this);
      }));
      function _blockhashWithExpiryBlockHeight(_x124) {
        return _blockhashWithExpiryBlockHeight2.apply(this, arguments);
      }
      return _blockhashWithExpiryBlockHeight;
    }()
    /**
     * @internal
     */
  }, {
    key: "_pollNewBlockhash",
    value: function () {
      var _pollNewBlockhash2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee84() {
        var startTime, cachedLatestBlockhash, cachedBlockhash, i, latestBlockhash;
        return _regeneratorRuntime.wrap(function _callee84$(_context85) {
          while (1) switch (_context85.prev = _context85.next) {
            case 0:
              this._pollingBlockhash = true;
              _context85.prev = 1;
              startTime = Date.now();
              cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
              cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
              i = 0;
            case 6:
              if (!(i < 50)) {
                _context85.next = 18;
                break;
              }
              _context85.next = 9;
              return this.getLatestBlockhash('finalized');
            case 9:
              latestBlockhash = _context85.sent;
              if (!(cachedBlockhash !== latestBlockhash.blockhash)) {
                _context85.next = 13;
                break;
              }
              this._blockhashInfo = {
                latestBlockhash: latestBlockhash,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: []
              };
              return _context85.abrupt("return", latestBlockhash);
            case 13:
              _context85.next = 15;
              return sleep(MS_PER_SLOT / 2);
            case 15:
              i++;
              _context85.next = 6;
              break;
            case 18:
              throw new Error("Unable to obtain a new blockhash after ".concat(Date.now() - startTime, "ms"));
            case 19:
              _context85.prev = 19;
              this._pollingBlockhash = false;
              return _context85.finish(19);
            case 22:
            case "end":
              return _context85.stop();
          }
        }, _callee84, this, [[1,, 19, 22]]);
      }));
      function _pollNewBlockhash() {
        return _pollNewBlockhash2.apply(this, arguments);
      }
      return _pollNewBlockhash;
    }()
    /**
     * get the stake minimum delegation
     */
  }, {
    key: "getStakeMinimumDelegation",
    value: function () {
      var _getStakeMinimumDelegation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee85(config) {
        var _extractCommitmentFro24, commitment, configArg, args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee85$(_context86) {
          while (1) switch (_context86.prev = _context86.next) {
            case 0:
              _extractCommitmentFro24 = extractCommitmentFromConfig(config), commitment = _extractCommitmentFro24.commitment, configArg = _extractCommitmentFro24.config;
              args = this._buildArgs([], commitment, 'base64', configArg);
              _context86.next = 4;
              return this._rpcRequest('getStakeMinimumDelegation', args);
            case 4:
              unsafeRes = _context86.sent;
              res = create(unsafeRes, jsonRpcResultAndContext(number()));
              if (!('error' in res)) {
                _context86.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get stake minimum delegation");
            case 8:
              return _context86.abrupt("return", res.result);
            case 9:
            case "end":
              return _context86.stop();
          }
        }, _callee85, this);
      }));
      function getStakeMinimumDelegation(_x125) {
        return _getStakeMinimumDelegation.apply(this, arguments);
      }
      return getStakeMinimumDelegation;
    }()
    /**
     * Simulate a transaction
     *
     * @deprecated Instead, call {@link simulateTransaction} with {@link
     * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
     */
  }, {
    key: "simulateTransaction",
    value:
    /**
     * Simulate a transaction
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _simulateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee86(transactionOrMessage, configOrSigners, includeAccounts) {
        var versionedTx, _wireTransaction, _encodedTransaction, _config2, _args87, _unsafeRes, _res5, transaction, originalTx, signers, _transaction, disableCache, _transaction2, latestBlockhash, _signature, message, signData, wireTransaction, encodedTransaction, config, addresses, args, unsafeRes, res, _logs, traceIndent, logTrace;
        return _regeneratorRuntime.wrap(function _callee86$(_context87) {
          while (1) switch (_context87.prev = _context87.next) {
            case 0:
              if (!('message' in transactionOrMessage)) {
                _context87.next = 17;
                break;
              }
              versionedTx = transactionOrMessage;
              _wireTransaction = versionedTx.serialize();
              _encodedTransaction = Buffer.from(_wireTransaction).toString('base64');
              if (!(Array.isArray(configOrSigners) || includeAccounts !== undefined)) {
                _context87.next = 6;
                break;
              }
              throw new Error('Invalid arguments');
            case 6:
              _config2 = configOrSigners || {};
              _config2.encoding = 'base64';
              if (!('commitment' in _config2)) {
                _config2.commitment = this.commitment;
              }
              _args87 = [_encodedTransaction, _config2];
              _context87.next = 12;
              return this._rpcRequest('simulateTransaction', _args87);
            case 12:
              _unsafeRes = _context87.sent;
              _res5 = create(_unsafeRes, SimulatedTransactionResponseStruct);
              if (!('error' in _res5)) {
                _context87.next = 16;
                break;
              }
              throw new Error('failed to simulate transaction: ' + _res5.error.message);
            case 16:
              return _context87.abrupt("return", _res5.result);
            case 17:
              if (transactionOrMessage instanceof Transaction) {
                originalTx = transactionOrMessage;
                transaction = new Transaction();
                transaction.feePayer = originalTx.feePayer;
                transaction.instructions = transactionOrMessage.instructions;
                transaction.nonceInfo = originalTx.nonceInfo;
                transaction.signatures = originalTx.signatures;
              } else {
                transaction = Transaction.populate(transactionOrMessage);
                // HACK: this function relies on mutating the populated transaction
                transaction._message = transaction._json = undefined;
              }
              if (!(configOrSigners !== undefined && !Array.isArray(configOrSigners))) {
                _context87.next = 20;
                break;
              }
              throw new Error('Invalid arguments');
            case 20:
              signers = configOrSigners;
              if (!(transaction.nonceInfo && signers)) {
                _context87.next = 25;
                break;
              }
              (_transaction = transaction).sign.apply(_transaction, _toConsumableArray(signers));
              _context87.next = 45;
              break;
            case 25:
              disableCache = this._disableBlockhashCaching;
            case 26:
              _context87.next = 28;
              return this._blockhashWithExpiryBlockHeight(disableCache);
            case 28:
              latestBlockhash = _context87.sent;
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              if (signers) {
                _context87.next = 33;
                break;
              }
              return _context87.abrupt("break", 45);
            case 33:
              (_transaction2 = transaction).sign.apply(_transaction2, _toConsumableArray(signers));
              if (transaction.signature) {
                _context87.next = 36;
                break;
              }
              throw new Error('!signature');
            case 36:
              _signature = transaction.signature.toString('base64');
              if (!(!this._blockhashInfo.simulatedSignatures.includes(_signature) && !this._blockhashInfo.transactionSignatures.includes(_signature))) {
                _context87.next = 42;
                break;
              }
              // The signature of this transaction has not been seen before with the
              // current recentBlockhash, all done. Let's break
              this._blockhashInfo.simulatedSignatures.push(_signature);
              return _context87.abrupt("break", 45);
            case 42:
              // This transaction would be treated as duplicate (its derived signature
              // matched to one of already recorded signatures).
              // So, we must fetch a new blockhash for a different signature by disabling
              // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
              disableCache = true;
            case 43:
              _context87.next = 26;
              break;
            case 45:
              message = transaction._compile();
              signData = message.serialize();
              wireTransaction = transaction._serialize(signData);
              encodedTransaction = wireTransaction.toString('base64');
              config = {
                encoding: 'base64',
                commitment: this.commitment
              };
              if (includeAccounts) {
                addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(function (key) {
                  return key.toBase58();
                });
                config['accounts'] = {
                  encoding: 'base64',
                  addresses: addresses
                };
              }
              if (signers) {
                config.sigVerify = true;
              }
              args = [encodedTransaction, config];
              _context87.next = 55;
              return this._rpcRequest('simulateTransaction', args);
            case 55:
              unsafeRes = _context87.sent;
              res = create(unsafeRes, SimulatedTransactionResponseStruct);
              if (!('error' in res)) {
                _context87.next = 60;
                break;
              }
              if ('data' in res.error) {
                _logs = res.error.data.logs;
                if (_logs && Array.isArray(_logs)) {
                  traceIndent = '\n    ';
                  logTrace = traceIndent + _logs.join(traceIndent);
                  console.error(res.error.message, logTrace);
                }
              }
              throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, _logs);
            case 60:
              return _context87.abrupt("return", res.result);
            case 61:
            case "end":
              return _context87.stop();
          }
        }, _callee86, this);
      }));
      function simulateTransaction(_x126, _x127, _x128) {
        return _simulateTransaction.apply(this, arguments);
      }
      return simulateTransaction;
    }()
    /**
     * Sign and send a transaction
     *
     * @deprecated Instead, call {@link sendTransaction} with a {@link
     * VersionedTransaction}
     */
  }, {
    key: "sendTransaction",
    value:
    /**
     * Sign and send a transaction
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee87(transaction, signersOrOptions, options) {
        var _wireTransaction2, signers, disableCache, latestBlockhash, _signature2, wireTransaction;
        return _regeneratorRuntime.wrap(function _callee87$(_context88) {
          while (1) switch (_context88.prev = _context88.next) {
            case 0:
              if (!('version' in transaction)) {
                _context88.next = 7;
                break;
              }
              if (!(signersOrOptions && Array.isArray(signersOrOptions))) {
                _context88.next = 3;
                break;
              }
              throw new Error('Invalid arguments');
            case 3:
              _wireTransaction2 = transaction.serialize();
              _context88.next = 6;
              return this.sendRawTransaction(_wireTransaction2, signersOrOptions);
            case 6:
              return _context88.abrupt("return", _context88.sent);
            case 7:
              if (!(signersOrOptions === undefined || !Array.isArray(signersOrOptions))) {
                _context88.next = 9;
                break;
              }
              throw new Error('Invalid arguments');
            case 9:
              signers = signersOrOptions;
              if (!transaction.nonceInfo) {
                _context88.next = 14;
                break;
              }
              transaction.sign.apply(transaction, _toConsumableArray(signers));
              _context88.next = 32;
              break;
            case 14:
              disableCache = this._disableBlockhashCaching;
            case 15:
              _context88.next = 17;
              return this._blockhashWithExpiryBlockHeight(disableCache);
            case 17:
              latestBlockhash = _context88.sent;
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              transaction.sign.apply(transaction, _toConsumableArray(signers));
              if (transaction.signature) {
                _context88.next = 23;
                break;
              }
              throw new Error('!signature');
            case 23:
              _signature2 = transaction.signature.toString('base64');
              if (this._blockhashInfo.transactionSignatures.includes(_signature2)) {
                _context88.next = 29;
                break;
              }
              // The signature of this transaction has not been seen before with the
              // current recentBlockhash, all done. Let's break
              this._blockhashInfo.transactionSignatures.push(_signature2);
              return _context88.abrupt("break", 32);
            case 29:
              // This transaction would be treated as duplicate (its derived signature
              // matched to one of already recorded signatures).
              // So, we must fetch a new blockhash for a different signature by disabling
              // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
              disableCache = true;
            case 30:
              _context88.next = 15;
              break;
            case 32:
              wireTransaction = transaction.serialize();
              _context88.next = 35;
              return this.sendRawTransaction(wireTransaction, options);
            case 35:
              return _context88.abrupt("return", _context88.sent);
            case 36:
            case "end":
              return _context88.stop();
          }
        }, _callee87, this);
      }));
      function sendTransaction(_x129, _x130, _x131) {
        return _sendTransaction.apply(this, arguments);
      }
      return sendTransaction;
    }()
    /**
     * Send a transaction that has already been signed and serialized into the
     * wire format
     */
  }, {
    key: "sendRawTransaction",
    value: function () {
      var _sendRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee88(rawTransaction, options) {
        var encodedTransaction, result;
        return _regeneratorRuntime.wrap(function _callee88$(_context89) {
          while (1) switch (_context89.prev = _context89.next) {
            case 0:
              encodedTransaction = toBuffer(rawTransaction).toString('base64');
              _context89.next = 3;
              return this.sendEncodedTransaction(encodedTransaction, options);
            case 3:
              result = _context89.sent;
              return _context89.abrupt("return", result);
            case 5:
            case "end":
              return _context89.stop();
          }
        }, _callee88, this);
      }));
      function sendRawTransaction(_x132, _x133) {
        return _sendRawTransaction.apply(this, arguments);
      }
      return sendRawTransaction;
    }()
    /**
     * Send a transaction that has already been signed, serialized into the
     * wire format, and encoded as a base64 string
     */
  }, {
    key: "sendEncodedTransaction",
    value: function () {
      var _sendEncodedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee89(encodedTransaction, options) {
        var config, skipPreflight, preflightCommitment, args, unsafeRes, res, _logs2;
        return _regeneratorRuntime.wrap(function _callee89$(_context90) {
          while (1) switch (_context90.prev = _context90.next) {
            case 0:
              config = {
                encoding: 'base64'
              };
              skipPreflight = options && options.skipPreflight;
              preflightCommitment = options && options.preflightCommitment || this.commitment;
              if (options && options.maxRetries != null) {
                config.maxRetries = options.maxRetries;
              }
              if (options && options.minContextSlot != null) {
                config.minContextSlot = options.minContextSlot;
              }
              if (skipPreflight) {
                config.skipPreflight = skipPreflight;
              }
              if (preflightCommitment) {
                config.preflightCommitment = preflightCommitment;
              }
              args = [encodedTransaction, config];
              _context90.next = 10;
              return this._rpcRequest('sendTransaction', args);
            case 10:
              unsafeRes = _context90.sent;
              res = create(unsafeRes, SendTransactionRpcResult);
              if (!('error' in res)) {
                _context90.next = 15;
                break;
              }
              if ('data' in res.error) {
                _logs2 = res.error.data.logs;
              }
              throw new SendTransactionError('failed to send transaction: ' + res.error.message, _logs2);
            case 15:
              return _context90.abrupt("return", res.result);
            case 16:
            case "end":
              return _context90.stop();
          }
        }, _callee89, this);
      }));
      function sendEncodedTransaction(_x134, _x135) {
        return _sendEncodedTransaction.apply(this, arguments);
      }
      return sendEncodedTransaction;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnOpen",
    value: function _wsOnOpen() {
      var _this9 = this;
      this._rpcWebSocketConnected = true;
      this._rpcWebSocketHeartbeat = setInterval(function () {
        // Ping server every 5s to prevent idle timeouts
        _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee90() {
          return _regeneratorRuntime.wrap(function _callee90$(_context91) {
            while (1) switch (_context91.prev = _context91.next) {
              case 0:
                _context91.prev = 0;
                _context91.next = 3;
                return _this9._rpcWebSocket.notify('ping');
              case 3:
                _context91.next = 7;
                break;
              case 5:
                _context91.prev = 5;
                _context91.t0 = _context91["catch"](0);
              case 7:
              case "end":
                return _context91.stop();
            }
          }, _callee90, null, [[0, 5]]);
        }))();
      }, 5000);
      this._updateSubscriptions();
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnError",
    value: function _wsOnError(err) {
      this._rpcWebSocketConnected = false;
      console.error('ws error:', err.message);
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnClose",
    value: function _wsOnClose(code) {
      var _this10 = this;
      this._rpcWebSocketConnected = false;
      this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
      if (this._rpcWebSocketIdleTimeout) {
        clearTimeout(this._rpcWebSocketIdleTimeout);
        this._rpcWebSocketIdleTimeout = null;
      }
      if (this._rpcWebSocketHeartbeat) {
        clearInterval(this._rpcWebSocketHeartbeat);
        this._rpcWebSocketHeartbeat = null;
      }
      if (code === 1000) {
        // explicit close, check if any subscriptions have been made since close
        this._updateSubscriptions();
        return;
      }

      // implicit close, prepare subscriptions for auto-reconnect
      this._subscriptionCallbacksByServerSubscriptionId = {};
      Object.entries(this._subscriptionsByHash).forEach(function (_ref19) {
        var _ref20 = _slicedToArray(_ref19, 2),
          hash = _ref20[0],
          subscription = _ref20[1];
        _this10._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
          state: 'pending'
        }));
      });
    }

    /**
     * @internal
     */
  }, {
    key: "_setSubscription",
    value: function _setSubscription(hash, nextSubscription) {
      var _this$_subscriptionsB;
      var prevState = (_this$_subscriptionsB = this._subscriptionsByHash[hash]) === null || _this$_subscriptionsB === void 0 ? void 0 : _this$_subscriptionsB.state;
      this._subscriptionsByHash[hash] = nextSubscription;
      if (prevState !== nextSubscription.state) {
        var stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
        if (stateChangeCallbacks) {
          stateChangeCallbacks.forEach(function (cb) {
            try {
              cb(nextSubscription.state);
              // eslint-disable-next-line no-empty
            } catch (_unused2) {}
          });
        }
      }
    }

    /**
     * @internal
     */
  }, {
    key: "_onSubscriptionStateChange",
    value: function _onSubscriptionStateChange(clientSubscriptionId, callback) {
      var _this$_subscriptionSt,
        _this11 = this;
      var hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      if (hash == null) {
        return function () {};
      }
      var stateChangeCallbacks = (_this$_subscriptionSt = this._subscriptionStateChangeCallbacksByHash)[hash] || (_this$_subscriptionSt[hash] = new Set());
      stateChangeCallbacks.add(callback);
      return function () {
        stateChangeCallbacks["delete"](callback);
        if (stateChangeCallbacks.size === 0) {
          delete _this11._subscriptionStateChangeCallbacksByHash[hash];
        }
      };
    }

    /**
     * @internal
     */
  }, {
    key: "_updateSubscriptions",
    value: function () {
      var _updateSubscriptions2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee94() {
        var _this12 = this;
        var activeWebSocketGeneration, isCurrentConnectionStillActive;
        return _regeneratorRuntime.wrap(function _callee94$(_context95) {
          while (1) switch (_context95.prev = _context95.next) {
            case 0:
              if (!(Object.keys(this._subscriptionsByHash).length === 0)) {
                _context95.next = 3;
                break;
              }
              if (this._rpcWebSocketConnected) {
                this._rpcWebSocketConnected = false;
                this._rpcWebSocketIdleTimeout = setTimeout(function () {
                  _this12._rpcWebSocketIdleTimeout = null;
                  try {
                    _this12._rpcWebSocket.close();
                  } catch (err) {
                    // swallow error if socket has already been closed.
                    if (err instanceof Error) {
                      console.log("Error when closing socket connection: ".concat(err.message));
                    }
                  }
                }, 500);
              }
              return _context95.abrupt("return");
            case 3:
              if (this._rpcWebSocketIdleTimeout !== null) {
                clearTimeout(this._rpcWebSocketIdleTimeout);
                this._rpcWebSocketIdleTimeout = null;
                this._rpcWebSocketConnected = true;
              }
              if (this._rpcWebSocketConnected) {
                _context95.next = 7;
                break;
              }
              this._rpcWebSocket.connect();
              return _context95.abrupt("return");
            case 7:
              activeWebSocketGeneration = this._rpcWebSocketGeneration;
              isCurrentConnectionStillActive = function isCurrentConnectionStillActive() {
                return activeWebSocketGeneration === _this12._rpcWebSocketGeneration;
              };
              _context95.next = 11;
              return Promise.all(
              // Don't be tempted to change this to `Object.entries`. We call
              // `_updateSubscriptions` recursively when processing the state,
              // so it's important that we look up the *current* version of
              // each subscription, every time we process a hash.
              Object.keys(this._subscriptionsByHash).map( /*#__PURE__*/function () {
                var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee93(hash) {
                  var subscription;
                  return _regeneratorRuntime.wrap(function _callee93$(_context94) {
                    while (1) switch (_context94.prev = _context94.next) {
                      case 0:
                        subscription = _this12._subscriptionsByHash[hash];
                        if (!(subscription === undefined)) {
                          _context94.next = 3;
                          break;
                        }
                        return _context94.abrupt("return");
                      case 3:
                        _context94.t0 = subscription.state;
                        _context94.next = _context94.t0 === 'pending' ? 6 : _context94.t0 === 'unsubscribed' ? 6 : _context94.t0 === 'subscribed' ? 15 : _context94.t0 === 'subscribing' ? 19 : _context94.t0 === 'unsubscribing' ? 19 : 20;
                        break;
                      case 6:
                        if (!(subscription.callbacks.size === 0)) {
                          _context94.next = 12;
                          break;
                        }
                        /**
                         * You can end up here when:
                         *
                         * - a subscription has recently unsubscribed
                         *   without having new callbacks added to it
                         *   while the unsubscribe was in flight, or
                         * - when a pending subscription has its
                         *   listeners removed before a request was
                         *   sent to the server.
                         *
                         * Being that nobody is interested in this
                         * subscription any longer, delete it.
                         */
                        delete _this12._subscriptionsByHash[hash];
                        if (subscription.state === 'unsubscribed') {
                          delete _this12._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                        }
                        _context94.next = 11;
                        return _this12._updateSubscriptions();
                      case 11:
                        return _context94.abrupt("return");
                      case 12:
                        _context94.next = 14;
                        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee91() {
                          var args, method, _serverSubscriptionId;
                          return _regeneratorRuntime.wrap(function _callee91$(_context92) {
                            while (1) switch (_context92.prev = _context92.next) {
                              case 0:
                                args = subscription.args, method = subscription.method;
                                _context92.prev = 1;
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'subscribing'
                                }));
                                _context92.next = 5;
                                return _this12._rpcWebSocket.call(method, args);
                              case 5:
                                _serverSubscriptionId = _context92.sent;
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  serverSubscriptionId: _serverSubscriptionId,
                                  state: 'subscribed'
                                }));
                                _this12._subscriptionCallbacksByServerSubscriptionId[_serverSubscriptionId] = subscription.callbacks;
                                _context92.next = 10;
                                return _this12._updateSubscriptions();
                              case 10:
                                _context92.next = 20;
                                break;
                              case 12:
                                _context92.prev = 12;
                                _context92.t0 = _context92["catch"](1);
                                if (_context92.t0 instanceof Error) {
                                  console.error("".concat(method, " error for argument"), args, _context92.t0.message);
                                }
                                if (isCurrentConnectionStillActive()) {
                                  _context92.next = 17;
                                  break;
                                }
                                return _context92.abrupt("return");
                              case 17:
                                // TODO: Maybe add an 'errored' state or a retry limit?
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'pending'
                                }));
                                _context92.next = 20;
                                return _this12._updateSubscriptions();
                              case 20:
                              case "end":
                                return _context92.stop();
                            }
                          }, _callee91, null, [[1, 12]]);
                        }))();
                      case 14:
                        return _context94.abrupt("break", 20);
                      case 15:
                        if (!(subscription.callbacks.size === 0)) {
                          _context94.next = 18;
                          break;
                        }
                        _context94.next = 18;
                        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee92() {
                          var serverSubscriptionId, unsubscribeMethod;
                          return _regeneratorRuntime.wrap(function _callee92$(_context93) {
                            while (1) switch (_context93.prev = _context93.next) {
                              case 0:
                                serverSubscriptionId = subscription.serverSubscriptionId, unsubscribeMethod = subscription.unsubscribeMethod;
                                if (!_this12._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                                  _context93.next = 5;
                                  break;
                                }
                                /**
                                 * Special case.
                                 * If we're dealing with a subscription that has been auto-
                                 * disposed by the RPC, then we can skip the RPC call to
                                 * tear down the subscription here.
                                 *
                                 * NOTE: There is a proposal to eliminate this special case, here:
                                 * https://github.com/solana-labs/solana/issues/18892
                                 */
                                _this12._subscriptionsAutoDisposedByRpc["delete"](serverSubscriptionId);
                                _context93.next = 21;
                                break;
                              case 5:
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'unsubscribing'
                                }));
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'unsubscribing'
                                }));
                                _context93.prev = 7;
                                _context93.next = 10;
                                return _this12._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                              case 10:
                                _context93.next = 21;
                                break;
                              case 12:
                                _context93.prev = 12;
                                _context93.t0 = _context93["catch"](7);
                                if (_context93.t0 instanceof Error) {
                                  console.error("".concat(unsubscribeMethod, " error:"), _context93.t0.message);
                                }
                                if (isCurrentConnectionStillActive()) {
                                  _context93.next = 17;
                                  break;
                                }
                                return _context93.abrupt("return");
                              case 17:
                                // TODO: Maybe add an 'errored' state or a retry limit?
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'subscribed'
                                }));
                                _context93.next = 20;
                                return _this12._updateSubscriptions();
                              case 20:
                                return _context93.abrupt("return");
                              case 21:
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'unsubscribed'
                                }));
                                _context93.next = 24;
                                return _this12._updateSubscriptions();
                              case 24:
                              case "end":
                                return _context93.stop();
                            }
                          }, _callee92, null, [[7, 12]]);
                        }))();
                      case 18:
                        return _context94.abrupt("break", 20);
                      case 19:
                        return _context94.abrupt("break", 20);
                      case 20:
                      case "end":
                        return _context94.stop();
                    }
                  }, _callee93);
                }));
                return function (_x136) {
                  return _ref21.apply(this, arguments);
                };
              }()));
            case 11:
            case "end":
              return _context95.stop();
          }
        }, _callee94, this);
      }));
      function _updateSubscriptions() {
        return _updateSubscriptions2.apply(this, arguments);
      }
      return _updateSubscriptions;
    }()
    /**
     * @internal
     */
  }, {
    key: "_handleServerNotification",
    value: function _handleServerNotification(serverSubscriptionId, callbackArgs) {
      var callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
      if (callbacks === undefined) {
        return;
      }
      callbacks.forEach(function (cb) {
        try {
          cb.apply(void 0, _toConsumableArray(callbackArgs));
        } catch (e) {
          console.error(e);
        }
      });
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnAccountNotification",
    value: function _wsOnAccountNotification(notification) {
      var _create = create(notification, AccountNotificationResult),
        result = _create.result,
        subscription = _create.subscription;
      this._handleServerNotification(subscription, [result.value, result.context]);
    }

    /**
     * @internal
     */
  }, {
    key: "_makeSubscription",
    value: function _makeSubscription(subscriptionConfig,
    /**
     * When preparing `args` for a call to `_makeSubscription`, be sure
     * to carefully apply a default `commitment` property, if necessary.
     *
     * - If the user supplied a `commitment` use that.
     * - Otherwise, if the `Connection::commitment` is set, use that.
     * - Otherwise, set it to the RPC server default: `finalized`.
     *
     * This is extremely important to ensure that these two fundamentally
     * identical subscriptions produce the same identifying hash:
     *
     * - A subscription made without specifying a commitment.
     * - A subscription made where the commitment specified is the same
     *   as the default applied to the subscription above.
     *
     * Example; these two subscriptions must produce the same hash:
     *
     * - An `accountSubscribe` subscription for `'PUBKEY'`
     * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment
     *   `'finalized'`.
     *
     * See the 'making a subscription with defaulted params omitted' test
     * in `connection-subscriptions.ts` for more.
     */
    args) {
      var _this13 = this;
      var clientSubscriptionId = this._nextClientSubscriptionId++;
      var hash = fastStableStringify$1([subscriptionConfig.method, args], true /* isArrayProp */);

      var existingSubscription = this._subscriptionsByHash[hash];
      if (existingSubscription === undefined) {
        this._subscriptionsByHash[hash] = _objectSpread(_objectSpread({}, subscriptionConfig), {}, {
          args: args,
          callbacks: new Set([subscriptionConfig.callback]),
          state: 'pending'
        });
      } else {
        existingSubscription.callbacks.add(subscriptionConfig.callback);
      }
      this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
      this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee95() {
        var subscription;
        return _regeneratorRuntime.wrap(function _callee95$(_context96) {
          while (1) switch (_context96.prev = _context96.next) {
            case 0:
              delete _this13._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
              delete _this13._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
              subscription = _this13._subscriptionsByHash[hash];
              assert(subscription !== undefined, "Could not find a `Subscription` when tearing down client subscription #".concat(clientSubscriptionId));
              subscription.callbacks["delete"](subscriptionConfig.callback);
              _context96.next = 7;
              return _this13._updateSubscriptions();
            case 7:
            case "end":
              return _context96.stop();
          }
        }, _callee95);
      }));
      this._updateSubscriptions();
      return clientSubscriptionId;
    }

    /**
     * Register a callback to be invoked whenever the specified account changes
     *
     * @param publicKey Public key of the account to monitor
     * @param callback Function to invoke whenever the account is changed
     * @param commitment Specify the commitment level account changes must reach before notification
     * @return subscription id
     */
  }, {
    key: "onAccountChange",
    value: function onAccountChange(publicKey, callback, commitment) {
      var args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized',
      // Apply connection/server default.
      'base64');
      return this._makeSubscription({
        callback: callback,
        method: 'accountSubscribe',
        unsubscribeMethod: 'accountUnsubscribe'
      }, args);
    }

    /**
     * Deregister an account notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeAccountChangeListener",
    value: function () {
      var _removeAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee96(clientSubscriptionId) {
        return _regeneratorRuntime.wrap(function _callee96$(_context97) {
          while (1) switch (_context97.prev = _context97.next) {
            case 0:
              _context97.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');
            case 2:
            case "end":
              return _context97.stop();
          }
        }, _callee96, this);
      }));
      function removeAccountChangeListener(_x137) {
        return _removeAccountChangeListener.apply(this, arguments);
      }
      return removeAccountChangeListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnProgramAccountNotification",
    value: function _wsOnProgramAccountNotification(notification) {
      var _create2 = create(notification, ProgramAccountNotificationResult),
        result = _create2.result,
        subscription = _create2.subscription;
      this._handleServerNotification(subscription, [{
        accountId: result.value.pubkey,
        accountInfo: result.value.account
      }, result.context]);
    }

    /**
     * Register a callback to be invoked whenever accounts owned by the
     * specified program change
     *
     * @param programId Public key of the program to monitor
     * @param callback Function to invoke whenever the account is changed
     * @param commitment Specify the commitment level account changes must reach before notification
     * @param filters The program account filters to pass into the RPC method
     * @return subscription id
     */
  }, {
    key: "onProgramAccountChange",
    value: function onProgramAccountChange(programId, callback, commitment, filters) {
      var args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized',
      // Apply connection/server default.
      'base64' /* encoding */, filters ? {
        filters: filters
      } : undefined /* extra */);

      return this._makeSubscription({
        callback: callback,
        method: 'programSubscribe',
        unsubscribeMethod: 'programUnsubscribe'
      }, args);
    }

    /**
     * Deregister an account notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeProgramAccountChangeListener",
    value: function () {
      var _removeProgramAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee97(clientSubscriptionId) {
        return _regeneratorRuntime.wrap(function _callee97$(_context98) {
          while (1) switch (_context98.prev = _context98.next) {
            case 0:
              _context98.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');
            case 2:
            case "end":
              return _context98.stop();
          }
        }, _callee97, this);
      }));
      function removeProgramAccountChangeListener(_x138) {
        return _removeProgramAccountChangeListener.apply(this, arguments);
      }
      return removeProgramAccountChangeListener;
    }()
    /**
     * Registers a callback to be invoked whenever logs are emitted.
     */
  }, {
    key: "onLogs",
    value: function onLogs(filter, callback, commitment) {
      var args = this._buildArgs([_typeof(filter) === 'object' ? {
        mentions: [filter.toString()]
      } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.
      );

      return this._makeSubscription({
        callback: callback,
        method: 'logsSubscribe',
        unsubscribeMethod: 'logsUnsubscribe'
      }, args);
    }

    /**
     * Deregister a logs callback.
     *
     * @param id client subscription id to deregister.
     */
  }, {
    key: "removeOnLogsListener",
    value: function () {
      var _removeOnLogsListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee98(clientSubscriptionId) {
        return _regeneratorRuntime.wrap(function _callee98$(_context99) {
          while (1) switch (_context99.prev = _context99.next) {
            case 0:
              _context99.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');
            case 2:
            case "end":
              return _context99.stop();
          }
        }, _callee98, this);
      }));
      function removeOnLogsListener(_x139) {
        return _removeOnLogsListener.apply(this, arguments);
      }
      return removeOnLogsListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnLogsNotification",
    value: function _wsOnLogsNotification(notification) {
      var _create3 = create(notification, LogsNotificationResult),
        result = _create3.result,
        subscription = _create3.subscription;
      this._handleServerNotification(subscription, [result.value, result.context]);
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnSlotNotification",
    value: function _wsOnSlotNotification(notification) {
      var _create4 = create(notification, SlotNotificationResult),
        result = _create4.result,
        subscription = _create4.subscription;
      this._handleServerNotification(subscription, [result]);
    }

    /**
     * Register a callback to be invoked upon slot changes
     *
     * @param callback Function to invoke whenever the slot changes
     * @return subscription id
     */
  }, {
    key: "onSlotChange",
    value: function onSlotChange(callback) {
      return this._makeSubscription({
        callback: callback,
        method: 'slotSubscribe',
        unsubscribeMethod: 'slotUnsubscribe'
      }, [] /* args */);
    }

    /**
     * Deregister a slot notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeSlotChangeListener",
    value: function () {
      var _removeSlotChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee99(clientSubscriptionId) {
        return _regeneratorRuntime.wrap(function _callee99$(_context100) {
          while (1) switch (_context100.prev = _context100.next) {
            case 0:
              _context100.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');
            case 2:
            case "end":
              return _context100.stop();
          }
        }, _callee99, this);
      }));
      function removeSlotChangeListener(_x140) {
        return _removeSlotChangeListener.apply(this, arguments);
      }
      return removeSlotChangeListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnSlotUpdatesNotification",
    value: function _wsOnSlotUpdatesNotification(notification) {
      var _create5 = create(notification, SlotUpdateNotificationResult),
        result = _create5.result,
        subscription = _create5.subscription;
      this._handleServerNotification(subscription, [result]);
    }

    /**
     * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
     * may be useful to track live progress of a cluster.
     *
     * @param callback Function to invoke whenever the slot updates
     * @return subscription id
     */
  }, {
    key: "onSlotUpdate",
    value: function onSlotUpdate(callback) {
      return this._makeSubscription({
        callback: callback,
        method: 'slotsUpdatesSubscribe',
        unsubscribeMethod: 'slotsUpdatesUnsubscribe'
      }, [] /* args */);
    }

    /**
     * Deregister a slot update notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeSlotUpdateListener",
    value: function () {
      var _removeSlotUpdateListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee100(clientSubscriptionId) {
        return _regeneratorRuntime.wrap(function _callee100$(_context101) {
          while (1) switch (_context101.prev = _context101.next) {
            case 0:
              _context101.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');
            case 2:
            case "end":
              return _context101.stop();
          }
        }, _callee100, this);
      }));
      function removeSlotUpdateListener(_x141) {
        return _removeSlotUpdateListener.apply(this, arguments);
      }
      return removeSlotUpdateListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_unsubscribeClientSubscription",
    value: function () {
      var _unsubscribeClientSubscription2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee101(clientSubscriptionId, subscriptionName) {
        var dispose;
        return _regeneratorRuntime.wrap(function _callee101$(_context102) {
          while (1) switch (_context102.prev = _context102.next) {
            case 0:
              dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
              if (!dispose) {
                _context102.next = 6;
                break;
              }
              _context102.next = 4;
              return dispose();
            case 4:
              _context102.next = 7;
              break;
            case 6:
              console.warn('Ignored unsubscribe request because an active subscription with id ' + "`".concat(clientSubscriptionId, "` for '").concat(subscriptionName, "' events ") + 'could not be found.');
            case 7:
            case "end":
              return _context102.stop();
          }
        }, _callee101, this);
      }));
      function _unsubscribeClientSubscription(_x142, _x143) {
        return _unsubscribeClientSubscription2.apply(this, arguments);
      }
      return _unsubscribeClientSubscription;
    }()
  }, {
    key: "_buildArgs",
    value: function _buildArgs(args, override, encoding, extra) {
      var commitment = override || this._commitment;
      if (commitment || encoding || extra) {
        var _options = {};
        if (encoding) {
          _options.encoding = encoding;
        }
        if (commitment) {
          _options.commitment = commitment;
        }
        if (extra) {
          _options = Object.assign(_options, extra);
        }
        args.push(_options);
      }
      return args;
    }

    /**
     * @internal
     */
  }, {
    key: "_buildArgsAtLeastConfirmed",
    value: function _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
      var commitment = override || this._commitment;
      if (commitment && !['confirmed', 'finalized'].includes(commitment)) {
        throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');
      }
      return this._buildArgs(args, override, encoding, extra);
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnSignatureNotification",
    value: function _wsOnSignatureNotification(notification) {
      var _create6 = create(notification, SignatureNotificationResult),
        result = _create6.result,
        subscription = _create6.subscription;
      if (result.value !== 'receivedSignature') {
        /**
         * Special case.
         * After a signature is processed, RPCs automatically dispose of the
         * subscription on the server side. We need to track which of these
         * subscriptions have been disposed in such a way, so that we know
         * whether the client is dealing with a not-yet-processed signature
         * (in which case we must tear down the server subscription) or an
         * already-processed signature (in which case the client can simply
         * clear out the subscription locally without telling the server).
         *
         * NOTE: There is a proposal to eliminate this special case, here:
         * https://github.com/solana-labs/solana/issues/18892
         */
        this._subscriptionsAutoDisposedByRpc.add(subscription);
      }
      this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{
        type: 'received'
      }, result.context] : [{
        type: 'status',
        result: result.value
      }, result.context]);
    }

    /**
     * Register a callback to be invoked upon signature updates
     *
     * @param signature Transaction signature string in base 58
     * @param callback Function to invoke on signature notifications
     * @param commitment Specify the commitment level signature must reach before notification
     * @return subscription id
     */
  }, {
    key: "onSignature",
    value: function onSignature(signature, _callback, commitment) {
      var _this14 = this;
      var args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.
      );

      var clientSubscriptionId = this._makeSubscription({
        callback: function callback(notification, context) {
          if (notification.type === 'status') {
            _callback(notification.result, context);
            // Signatures subscriptions are auto-removed by the RPC service
            // so no need to explicitly send an unsubscribe message.
            try {
              _this14.removeSignatureListener(clientSubscriptionId);
              // eslint-disable-next-line no-empty
            } catch (_err) {
              // Already removed.
            }
          }
        },
        method: 'signatureSubscribe',
        unsubscribeMethod: 'signatureUnsubscribe'
      }, args);
      return clientSubscriptionId;
    }

    /**
     * Register a callback to be invoked when a transaction is
     * received and/or processed.
     *
     * @param signature Transaction signature string in base 58
     * @param callback Function to invoke on signature notifications
     * @param options Enable received notifications and set the commitment
     *   level that signature must reach before notification
     * @return subscription id
     */
  }, {
    key: "onSignatureWithOptions",
    value: function onSignatureWithOptions(signature, _callback2, options) {
      var _this15 = this;
      var _options$commitment = _objectSpread(_objectSpread({}, options), {}, {
          commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.
        }),
        commitment = _options$commitment.commitment,
        extra = _objectWithoutProperties(_options$commitment, _excluded4);
      var args = this._buildArgs([signature], commitment, undefined /* encoding */, extra);
      var clientSubscriptionId = this._makeSubscription({
        callback: function callback(notification, context) {
          _callback2(notification, context);
          // Signatures subscriptions are auto-removed by the RPC service
          // so no need to explicitly send an unsubscribe message.
          try {
            _this15.removeSignatureListener(clientSubscriptionId);
            // eslint-disable-next-line no-empty
          } catch (_err) {
            // Already removed.
          }
        },
        method: 'signatureSubscribe',
        unsubscribeMethod: 'signatureUnsubscribe'
      }, args);
      return clientSubscriptionId;
    }

    /**
     * Deregister a signature notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeSignatureListener",
    value: function () {
      var _removeSignatureListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee102(clientSubscriptionId) {
        return _regeneratorRuntime.wrap(function _callee102$(_context103) {
          while (1) switch (_context103.prev = _context103.next) {
            case 0:
              _context103.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');
            case 2:
            case "end":
              return _context103.stop();
          }
        }, _callee102, this);
      }));
      function removeSignatureListener(_x144) {
        return _removeSignatureListener.apply(this, arguments);
      }
      return removeSignatureListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnRootNotification",
    value: function _wsOnRootNotification(notification) {
      var _create7 = create(notification, RootNotificationResult),
        result = _create7.result,
        subscription = _create7.subscription;
      this._handleServerNotification(subscription, [result]);
    }

    /**
     * Register a callback to be invoked upon root changes
     *
     * @param callback Function to invoke whenever the root changes
     * @return subscription id
     */
  }, {
    key: "onRootChange",
    value: function onRootChange(callback) {
      return this._makeSubscription({
        callback: callback,
        method: 'rootSubscribe',
        unsubscribeMethod: 'rootUnsubscribe'
      }, [] /* args */);
    }

    /**
     * Deregister a root notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeRootChangeListener",
    value: function () {
      var _removeRootChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee103(clientSubscriptionId) {
        return _regeneratorRuntime.wrap(function _callee103$(_context104) {
          while (1) switch (_context104.prev = _context104.next) {
            case 0:
              _context104.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');
            case 2:
            case "end":
              return _context104.stop();
          }
        }, _callee103, this);
      }));
      function removeRootChangeListener(_x145) {
        return _removeRootChangeListener.apply(this, arguments);
      }
      return removeRootChangeListener;
    }()
  }]);
  return Connection;
}();

/**
 * Keypair signer interface
 */

/**
 * An account keypair used for signing transactions.
 */
var Keypair = /*#__PURE__*/function () {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */
  function Keypair(keypair) {
    _classCallCheck(this, Keypair);
    this._keypair = void 0;
    this._keypair = keypair !== null && keypair !== void 0 ? keypair : generateKeypair();
  }

  /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */
  _createClass(Keypair, [{
    key: "publicKey",
    get:
    /**
     * The public key for this keypair
     *
     * @returns {PublicKey} PublicKey
     */
    function get() {
      return new PublicKey(this._keypair.publicKey);
    }

    /**
     * The raw secret key for this keypair
     * @returns {Uint8Array} Secret key in an array of Uint8 bytes
     */
  }, {
    key: "secretKey",
    get: function get() {
      return new Uint8Array(this._keypair.secretKey);
    }
  }], [{
    key: "generate",
    value: function generate() {
      return new Keypair(generateKeypair());
    }

    /**
     * Create a keypair from a raw secret key byte array.
     *
     * This method should only be used to recreate a keypair from a previously
     * generated secret key. Generating keypairs from a random seed should be done
     * with the {@link Keypair.fromSeed} method.
     *
     * @throws error if the provided secret key is invalid and validation is not skipped.
     *
     * @param secretKey secret key byte array
     * @param options skip secret key validation
     *
     * @returns {Keypair} Keypair
     */
  }, {
    key: "fromSecretKey",
    value: function fromSecretKey(secretKey, options) {
      if (secretKey.byteLength !== 64) {
        throw new Error('bad secret key size');
      }
      var publicKey = secretKey.slice(32, 64);
      if (!options || !options.skipValidation) {
        var privateScalar = secretKey.slice(0, 32);
        var computedPublicKey = getPublicKey(privateScalar);
        for (var ii = 0; ii < 32; ii++) {
          if (publicKey[ii] !== computedPublicKey[ii]) {
            throw new Error('provided secretKey is invalid');
          }
        }
      }
      return new Keypair({
        publicKey: publicKey,
        secretKey: secretKey
      });
    }

    /**
     * Generate a keypair from a 32 byte seed.
     *
     * @param seed seed byte array
     *
     * @returns {Keypair} Keypair
     */
  }, {
    key: "fromSeed",
    value: function fromSeed(seed) {
      var publicKey = getPublicKey(seed);
      var secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return new Keypair({
        publicKey: publicKey,
        secretKey: secretKey
      });
    }
  }]);
  return Keypair;
}();

/**
 * An enumeration of valid LookupTableInstructionType's
 */

/**
 * An enumeration of valid address lookup table InstructionType's
 * @internal
 */
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), u64('recentSlot'), BufferLayout.u8('bumpSeed')])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), u64(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), 'addresses')])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  }
});
var AddressLookupTableInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function AddressLookupTableInstruction() {
    _classCallCheck(this, AddressLookupTableInstruction);
  }
  _createClass(AddressLookupTableInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = BufferLayout.u32('instruction');
      var index = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          layoutType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == index) {
          type = layoutType;
          break;
        }
      }
      if (!type) {
        throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
      }
      return type;
    }
  }, {
    key: "decodeCreateLookupTable",
    value: function decodeCreateLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 4);
      var _decodeData = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data),
        recentSlot = _decodeData.recentSlot;
      return {
        authority: instruction.keys[1].pubkey,
        payer: instruction.keys[2].pubkey,
        recentSlot: Number(recentSlot)
      };
    }
  }, {
    key: "decodeExtendLookupTable",
    value: function decodeExtendLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      if (instruction.keys.length < 2) {
        throw new Error("invalid instruction; found ".concat(instruction.keys.length, " keys, expected at least 2"));
      }
      var _decodeData2 = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data),
        addresses = _decodeData2.addresses;
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey,
        payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
        addresses: addresses.map(function (buffer) {
          return new PublicKey(buffer);
        })
      };
    }
  }, {
    key: "decodeCloseLookupTable",
    value: function decodeCloseLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 3);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey,
        recipient: instruction.keys[2].pubkey
      };
    }
  }, {
    key: "decodeFreezeLookupTable",
    value: function decodeFreezeLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 2);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey
      };
    }
  }, {
    key: "decodeDeactivateLookupTable",
    value: function decodeDeactivateLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 2);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(AddressLookupTableProgram.programId)) {
        throw new Error('invalid instruction; programId is not AddressLookupTable Program');
      }
    }
    /**
     * @internal
     */
  }, {
    key: "checkKeysLength",
    value: function checkKeysLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return AddressLookupTableInstruction;
}();
var AddressLookupTableProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function AddressLookupTableProgram() {
    _classCallCheck(this, AddressLookupTableProgram);
  }
  _createClass(AddressLookupTableProgram, null, [{
    key: "createLookupTable",
    value: function createLookupTable(params) {
      var _PublicKey$findProgra = PublicKey.findProgramAddressSync([params.authority.toBuffer(), toBufferLE(BigInt(params.recentSlot), 8)], this.programId),
        _PublicKey$findProgra2 = _slicedToArray(_PublicKey$findProgra, 2),
        lookupTableAddress = _PublicKey$findProgra2[0],
        bumpSeed = _PublicKey$findProgra2[1];
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
      var data = encodeData(type, {
        recentSlot: BigInt(params.recentSlot),
        bumpSeed: bumpSeed
      });
      var keys = [{
        pubkey: lookupTableAddress,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      }];
      return [new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      }), lookupTableAddress];
    }
  }, {
    key: "freezeLookupTable",
    value: function freezeLookupTable(params) {
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
      var data = encodeData(type);
      var keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      });
    }
  }, {
    key: "extendLookupTable",
    value: function extendLookupTable(params) {
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
      var data = encodeData(type, {
        addresses: params.addresses.map(function (addr) {
          return addr.toBytes();
        })
      });
      var keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      if (params.payer) {
        keys.push({
          pubkey: params.payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false
        });
      }
      return new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      });
    }
  }, {
    key: "deactivateLookupTable",
    value: function deactivateLookupTable(params) {
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
      var data = encodeData(type);
      var keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      });
    }
  }, {
    key: "closeLookupTable",
    value: function closeLookupTable(params) {
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
      var data = encodeData(type);
      var keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.recipient,
        isSigner: false,
        isWritable: true
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      });
    }
  }]);
  return AddressLookupTableProgram;
}();
AddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');

/**
 * Compute Budget Instruction class
 */
var ComputeBudgetInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function ComputeBudgetInstruction() {
    _classCallCheck(this, ComputeBudgetInstruction);
  }

  /**
   * Decode a compute budget instruction and retrieve the instruction type.
   */
  _createClass(ComputeBudgetInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = BufferLayout.u8('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
      }
      return type;
    }

    /**
     * Decode request units compute budget instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeRequestUnits",
    value: function decodeRequestUnits(instruction) {
      this.checkProgramId(instruction.programId);
      var _decodeData = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data),
        units = _decodeData.units,
        additionalFee = _decodeData.additionalFee;
      return {
        units: units,
        additionalFee: additionalFee
      };
    }

    /**
     * Decode request heap frame compute budget instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeRequestHeapFrame",
    value: function decodeRequestHeapFrame(instruction) {
      this.checkProgramId(instruction.programId);
      var _decodeData2 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data),
        bytes = _decodeData2.bytes;
      return {
        bytes: bytes
      };
    }

    /**
     * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeSetComputeUnitLimit",
    value: function decodeSetComputeUnitLimit(instruction) {
      this.checkProgramId(instruction.programId);
      var _decodeData3 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data),
        units = _decodeData3.units;
      return {
        units: units
      };
    }

    /**
     * Decode set compute unit price compute budget instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeSetComputeUnitPrice",
    value: function decodeSetComputeUnitPrice(instruction) {
      this.checkProgramId(instruction.programId);
      var _decodeData4 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data),
        microLamports = _decodeData4.microLamports;
      return {
        microLamports: microLamports
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(ComputeBudgetProgram.programId)) {
        throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
      }
    }
  }]);
  return ComputeBudgetInstruction;
}();

/**
 * An enumeration of valid ComputeBudgetInstructionType's
 */

/**
 * Request units instruction params
 */

/**
 * Request heap frame instruction params
 */

/**
 * Set compute unit limit instruction params
 */

/**
 * Set compute unit price instruction params
 */

/**
 * An enumeration of valid ComputeBudget InstructionType's
 * @internal
 */
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u8('instruction'), BufferLayout.u32('units'), BufferLayout.u32('additionalFee')])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u8('instruction'), BufferLayout.u32('bytes')])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u8('instruction'), BufferLayout.u32('units')])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u8('instruction'), u64('microLamports')])
  }
});

/**
 * Factory class for transaction instructions to interact with the Compute Budget program
 */
var ComputeBudgetProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function ComputeBudgetProgram() {
    _classCallCheck(this, ComputeBudgetProgram);
  }

  /**
   * Public key that identifies the Compute Budget program
   */
  _createClass(ComputeBudgetProgram, null, [{
    key: "requestUnits",
    value:
    /**
     * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
     */
    function requestUnits(params) {
      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
      var data = encodeData(type, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "requestHeapFrame",
    value: function requestHeapFrame(params) {
      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
      var data = encodeData(type, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "setComputeUnitLimit",
    value: function setComputeUnitLimit(params) {
      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
      var data = encodeData(type, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "setComputeUnitPrice",
    value: function setComputeUnitPrice(params) {
      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
      var data = encodeData(type, {
        microLamports: BigInt(params.microLamports)
      });
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data: data
      });
    }
  }]);
  return ComputeBudgetProgram;
}();
ComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');

var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;

/**
 * Params for creating an ed25519 instruction using a public key
 */

/**
 * Params for creating an ed25519 instruction using a private key
 */

var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8('numSignatures'), BufferLayout.u8('padding'), BufferLayout.u16('signatureOffset'), BufferLayout.u16('signatureInstructionIndex'), BufferLayout.u16('publicKeyOffset'), BufferLayout.u16('publicKeyInstructionIndex'), BufferLayout.u16('messageDataOffset'), BufferLayout.u16('messageDataSize'), BufferLayout.u16('messageInstructionIndex')]);
var Ed25519Program = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Ed25519Program() {
    _classCallCheck(this, Ed25519Program);
  }

  /**
   * Public key that identifies the ed25519 program
   */
  _createClass(Ed25519Program, null, [{
    key: "createInstructionWithPublicKey",
    value:
    /**
     * Create an ed25519 instruction with a public key and signature. The
     * public key must be a buffer that is 32 bytes long, and the signature
     * must be a buffer of 64 bytes.
     */
    function createInstructionWithPublicKey(params) {
      var publicKey = params.publicKey,
        message = params.message,
        signature = params.signature,
        instructionIndex = params.instructionIndex;
      assert(publicKey.length === PUBLIC_KEY_BYTES$1, "Public Key must be ".concat(PUBLIC_KEY_BYTES$1, " bytes but received ").concat(publicKey.length, " bytes"));
      assert(signature.length === SIGNATURE_BYTES, "Signature must be ".concat(SIGNATURE_BYTES, " bytes but received ").concat(signature.length, " bytes"));
      var publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
      var signatureOffset = publicKeyOffset + publicKey.length;
      var messageDataOffset = signatureOffset + signature.length;
      var numSignatures = 1;
      var instructionData = Buffer.alloc(messageDataOffset + message.length);
      var index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.
      : instructionIndex;
      ED25519_INSTRUCTION_LAYOUT.encode({
        numSignatures: numSignatures,
        padding: 0,
        signatureOffset: signatureOffset,
        signatureInstructionIndex: index,
        publicKeyOffset: publicKeyOffset,
        publicKeyInstructionIndex: index,
        messageDataOffset: messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: index
      }, instructionData);
      instructionData.fill(publicKey, publicKeyOffset);
      instructionData.fill(signature, signatureOffset);
      instructionData.fill(message, messageDataOffset);
      return new TransactionInstruction({
        keys: [],
        programId: Ed25519Program.programId,
        data: instructionData
      });
    }

    /**
     * Create an ed25519 instruction with a private key. The private key
     * must be a buffer that is 64 bytes long.
     */
  }, {
    key: "createInstructionWithPrivateKey",
    value: function createInstructionWithPrivateKey(params) {
      var privateKey = params.privateKey,
        message = params.message,
        instructionIndex = params.instructionIndex;
      assert(privateKey.length === PRIVATE_KEY_BYTES$1, "Private key must be ".concat(PRIVATE_KEY_BYTES$1, " bytes but received ").concat(privateKey.length, " bytes"));
      try {
        var keypair = Keypair.fromSecretKey(privateKey);
        var publicKey = keypair.publicKey.toBytes();
        var signature = sign(message, keypair.secretKey);
        return this.createInstructionWithPublicKey({
          publicKey: publicKey,
          message: message,
          signature: signature,
          instructionIndex: instructionIndex
        });
      } catch (error) {
        throw new Error("Error creating instruction; ".concat(error));
      }
    }
  }]);
  return Ed25519Program;
}();
Ed25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');

var ecdsaSign = function ecdsaSign(msgHash, privKey) {
  var signature = secp256k1.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
secp256k1.utils.isValidPrivateKey;
var publicKeyCreate = secp256k1.getPublicKey;

var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;

/**
 * Params for creating an secp256k1 instruction using a public key
 */

/**
 * Params for creating an secp256k1 instruction using an Ethereum address
 */

/**
 * Params for creating an secp256k1 instruction using a private key
 */

var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8('numSignatures'), BufferLayout.u16('signatureOffset'), BufferLayout.u8('signatureInstructionIndex'), BufferLayout.u16('ethAddressOffset'), BufferLayout.u8('ethAddressInstructionIndex'), BufferLayout.u16('messageDataOffset'), BufferLayout.u16('messageDataSize'), BufferLayout.u8('messageInstructionIndex'), BufferLayout.blob(20, 'ethAddress'), BufferLayout.blob(64, 'signature'), BufferLayout.u8('recoveryId')]);
var Secp256k1Program = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Secp256k1Program() {
    _classCallCheck(this, Secp256k1Program);
  }

  /**
   * Public key that identifies the secp256k1 program
   */
  _createClass(Secp256k1Program, null, [{
    key: "publicKeyToEthAddress",
    value:
    /**
     * Construct an Ethereum address from a secp256k1 public key buffer.
     * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
     */
    function publicKeyToEthAddress(publicKey) {
      assert(publicKey.length === PUBLIC_KEY_BYTES, "Public key must be ".concat(PUBLIC_KEY_BYTES, " bytes but received ").concat(publicKey.length, " bytes"));
      try {
        return Buffer.from(keccak_256(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);
      } catch (error) {
        throw new Error("Error constructing Ethereum address: ".concat(error));
      }
    }

    /**
     * Create an secp256k1 instruction with a public key. The public key
     * must be a buffer that is 64 bytes long.
     */
  }, {
    key: "createInstructionWithPublicKey",
    value: function createInstructionWithPublicKey(params) {
      var publicKey = params.publicKey,
        message = params.message,
        signature = params.signature,
        recoveryId = params.recoveryId,
        instructionIndex = params.instructionIndex;
      return Secp256k1Program.createInstructionWithEthAddress({
        ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),
        message: message,
        signature: signature,
        recoveryId: recoveryId,
        instructionIndex: instructionIndex
      });
    }

    /**
     * Create an secp256k1 instruction with an Ethereum address. The address
     * must be a hex string or a buffer that is 20 bytes long.
     */
  }, {
    key: "createInstructionWithEthAddress",
    value: function createInstructionWithEthAddress(params) {
      var rawAddress = params.ethAddress,
        message = params.message,
        signature = params.signature,
        recoveryId = params.recoveryId,
        _params$instructionIn = params.instructionIndex,
        instructionIndex = _params$instructionIn === void 0 ? 0 : _params$instructionIn;
      var ethAddress;
      if (typeof rawAddress === 'string') {
        if (rawAddress.startsWith('0x')) {
          ethAddress = Buffer.from(rawAddress.substr(2), 'hex');
        } else {
          ethAddress = Buffer.from(rawAddress, 'hex');
        }
      } else {
        ethAddress = rawAddress;
      }
      assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, "Address must be ".concat(ETHEREUM_ADDRESS_BYTES, " bytes but received ").concat(ethAddress.length, " bytes"));
      var dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
      var ethAddressOffset = dataStart;
      var signatureOffset = dataStart + ethAddress.length;
      var messageDataOffset = signatureOffset + signature.length + 1;
      var numSignatures = 1;
      var instructionData = Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
      SECP256K1_INSTRUCTION_LAYOUT.encode({
        numSignatures: numSignatures,
        signatureOffset: signatureOffset,
        signatureInstructionIndex: instructionIndex,
        ethAddressOffset: ethAddressOffset,
        ethAddressInstructionIndex: instructionIndex,
        messageDataOffset: messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: instructionIndex,
        signature: toBuffer(signature),
        ethAddress: toBuffer(ethAddress),
        recoveryId: recoveryId
      }, instructionData);
      instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
      return new TransactionInstruction({
        keys: [],
        programId: Secp256k1Program.programId,
        data: instructionData
      });
    }

    /**
     * Create an secp256k1 instruction with a private key. The private key
     * must be a buffer that is 32 bytes long.
     */
  }, {
    key: "createInstructionWithPrivateKey",
    value: function createInstructionWithPrivateKey(params) {
      var pkey = params.privateKey,
        message = params.message,
        instructionIndex = params.instructionIndex;
      assert(pkey.length === PRIVATE_KEY_BYTES, "Private key must be ".concat(PRIVATE_KEY_BYTES, " bytes but received ").concat(pkey.length, " bytes"));
      try {
        var privateKey = toBuffer(pkey);
        var publicKey = publicKeyCreate(privateKey, false /* isCompressed */).slice(1); // throw away leading byte
        var messageHash = Buffer.from(keccak_256(toBuffer(message)));
        var _ecdsaSign = ecdsaSign(messageHash, privateKey),
          _ecdsaSign2 = _slicedToArray(_ecdsaSign, 2),
          signature = _ecdsaSign2[0],
          recoveryId = _ecdsaSign2[1];
        return this.createInstructionWithPublicKey({
          publicKey: publicKey,
          message: message,
          signature: signature,
          recoveryId: recoveryId,
          instructionIndex: instructionIndex
        });
      } catch (error) {
        throw new Error("Error creating instruction; ".concat(error));
      }
    }
  }]);
  return Secp256k1Program;
}();
Secp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');

/**
 * Address of the stake config account which configures the rate
 * of stake warmup and cooldown as well as the slashing penalty.
 */
var STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');

/**
 * Stake account authority info
 */
var Authorized = /*#__PURE__*/_createClass(
/**
 * Create a new Authorized object
 * @param staker the stake authority
 * @param withdrawer the withdraw authority
 */
function Authorized(staker, withdrawer) {
  _classCallCheck(this, Authorized);
  /** stake authority */
  this.staker = void 0;
  /** withdraw authority */
  this.withdrawer = void 0;
  this.staker = staker;
  this.withdrawer = withdrawer;
});
/**
 * Stake account lockup info
 */
var Lockup = /*#__PURE__*/_createClass(
/**
 * Create a new Lockup object
 */
function Lockup(unixTimestamp, epoch, custodian) {
  _classCallCheck(this, Lockup);
  /** Unix timestamp of lockup expiration */
  this.unixTimestamp = void 0;
  /** Epoch of lockup expiration */
  this.epoch = void 0;
  /** Lockup custodian authority */
  this.custodian = void 0;
  this.unixTimestamp = unixTimestamp;
  this.epoch = epoch;
  this.custodian = custodian;
}

/**
 * Default, inactive Lockup value
 */);
Lockup["default"] = new Lockup(0, 0, PublicKey["default"]);
/**
 * Create stake account transaction params
 */
/**
 * Create stake account with seed transaction params
 */
/**
 * Initialize stake instruction params
 */
/**
 * Delegate stake instruction params
 */
/**
 * Authorize stake instruction params
 */
/**
 * Authorize stake instruction params using a derived key
 */
/**
 * Split stake instruction params
 */
/**
 * Split with seed transaction params
 */
/**
 * Withdraw stake instruction params
 */
/**
 * Deactivate stake instruction params
 */
/**
 * Merge stake instruction params
 */
/**
 * Stake Instruction class
 */
var StakeInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function StakeInstruction() {
    _classCallCheck(this, StakeInstruction);
  }

  /**
   * Decode a stake instruction and retrieve the instruction type.
   */
  _createClass(StakeInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = BufferLayout.u32('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(STAKE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a StakeInstruction');
      }
      return type;
    }

    /**
     * Decode a initialize stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeInitialize",
    value: function decodeInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data),
        authorized = _decodeData.authorized,
        lockup = _decodeData.lockup;
      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
        lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
      };
    }

    /**
     * Decode a delegate stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeDelegate",
    value: function decodeDelegate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 6);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        votePubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[5].pubkey
      };
    }

    /**
     * Decode an authorize stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAuthorize",
    value: function decodeAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData2 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),
        newAuthorized = _decodeData2.newAuthorized,
        stakeAuthorizationType = _decodeData2.stakeAuthorizationType;
      var o = {
        stakePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        stakeAuthorizationType: {
          index: stakeAuthorizationType
        }
      };
      if (instruction.keys.length > 3) {
        o.custodianPubkey = instruction.keys[3].pubkey;
      }
      return o;
    }

    /**
     * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAuthorizeWithSeed",
    value: function decodeAuthorizeWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData3 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),
        newAuthorized = _decodeData3.newAuthorized,
        stakeAuthorizationType = _decodeData3.stakeAuthorizationType,
        authoritySeed = _decodeData3.authoritySeed,
        authorityOwner = _decodeData3.authorityOwner;
      var o = {
        stakePubkey: instruction.keys[0].pubkey,
        authorityBase: instruction.keys[1].pubkey,
        authoritySeed: authoritySeed,
        authorityOwner: new PublicKey(authorityOwner),
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        stakeAuthorizationType: {
          index: stakeAuthorizationType
        }
      };
      if (instruction.keys.length > 3) {
        o.custodianPubkey = instruction.keys[3].pubkey;
      }
      return o;
    }

    /**
     * Decode a split stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeSplit",
    value: function decodeSplit(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData4 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data),
        lamports = _decodeData4.lamports;
      return {
        stakePubkey: instruction.keys[0].pubkey,
        splitStakePubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        lamports: lamports
      };
    }

    /**
     * Decode a merge stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeMerge",
    value: function decodeMerge(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        sourceStakePubKey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey
      };
    }

    /**
     * Decode a withdraw stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeWithdraw",
    value: function decodeWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);
      var _decodeData5 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),
        lamports = _decodeData5.lamports;
      var o = {
        stakePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports: lamports
      };
      if (instruction.keys.length > 5) {
        o.custodianPubkey = instruction.keys[5].pubkey;
      }
      return o;
    }

    /**
     * Decode a deactivate stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeDeactivate",
    value: function decodeDeactivate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(StakeProgram.programId)) {
        throw new Error('invalid instruction; programId is not StakeProgram');
      }
    }

    /**
     * @internal
     */
  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return StakeInstruction;
}();

/**
 * An enumeration of valid StakeInstructionType's
 */

/**
 * An enumeration of valid stake InstructionType's
 * @internal
 */
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('newAuthorized'), BufferLayout.u32('stakeAuthorizationType')])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  Split: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  Merge: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('newAuthorized'), BufferLayout.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])
  }
});

/**
 * Stake authorization type
 */

/**
 * An enumeration of valid StakeAuthorizationLayout's
 */
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

/**
 * Factory class for transactions to interact with the Stake program
 */
var StakeProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function StakeProgram() {
    _classCallCheck(this, StakeProgram);
  }

  /**
   * Public key that identifies the Stake program
   */
  _createClass(StakeProgram, null, [{
    key: "initialize",
    value:
    /**
     * Generate an Initialize instruction to add to a Stake Create transaction
     */
    function initialize(params) {
      var stakePubkey = params.stakePubkey,
        authorized = params.authorized,
        maybeLockup = params.lockup;
      var lockup = maybeLockup || Lockup["default"];
      var type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
      var data = encodeData(type, {
        authorized: {
          staker: toBuffer(authorized.staker.toBuffer()),
          withdrawer: toBuffer(authorized.withdrawer.toBuffer())
        },
        lockup: {
          unixTimestamp: lockup.unixTimestamp,
          epoch: lockup.epoch,
          custodian: toBuffer(lockup.custodian.toBuffer())
        }
      });
      var instructionData = {
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate a Transaction that creates a new Stake account at
     *   an address generated with `from`, a seed, and the Stake programId
     */
  }, {
    key: "createAccountWithSeed",
    value: function createAccountWithSeed(params) {
      var transaction = new Transaction();
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      var stakePubkey = params.stakePubkey,
        authorized = params.authorized,
        lockup = params.lockup;
      return transaction.add(this.initialize({
        stakePubkey: stakePubkey,
        authorized: authorized,
        lockup: lockup
      }));
    }

    /**
     * Generate a Transaction that creates a new Stake account
     */
  }, {
    key: "createAccount",
    value: function createAccount(params) {
      var transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      var stakePubkey = params.stakePubkey,
        authorized = params.authorized,
        lockup = params.lockup;
      return transaction.add(this.initialize({
        stakePubkey: stakePubkey,
        authorized: authorized,
        lockup: lockup
      }));
    }

    /**
     * Generate a Transaction that delegates Stake tokens to a validator
     * Vote PublicKey. This transaction can also be used to redelegate Stake
     * to a new validator Vote PublicKey.
     */
  }, {
    key: "delegate",
    value: function delegate(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        votePubkey = params.votePubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
      var data = encodeData(type);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: votePubkey,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: STAKE_CONFIG_ID,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that authorizes a new PublicKey as Staker
     * or Withdrawer on the Stake account.
     */
  }, {
    key: "authorize",
    value: function authorize(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        newAuthorizedPubkey = params.newAuthorizedPubkey,
        stakeAuthorizationType = params.stakeAuthorizationType,
        custodianPubkey = params.custodianPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
      var data = encodeData(type, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        stakeAuthorizationType: stakeAuthorizationType.index
      });
      var keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: false,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that authorizes a new PublicKey as Staker
     * or Withdrawer on the Stake account.
     */
  }, {
    key: "authorizeWithSeed",
    value: function authorizeWithSeed(params) {
      var stakePubkey = params.stakePubkey,
        authorityBase = params.authorityBase,
        authoritySeed = params.authoritySeed,
        authorityOwner = params.authorityOwner,
        newAuthorizedPubkey = params.newAuthorizedPubkey,
        stakeAuthorizationType = params.stakeAuthorizationType,
        custodianPubkey = params.custodianPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
      var data = encodeData(type, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        stakeAuthorizationType: stakeAuthorizationType.index,
        authoritySeed: authoritySeed,
        authorityOwner: toBuffer(authorityOwner.toBuffer())
      });
      var keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorityBase,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: false,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * @internal
     */
  }, {
    key: "splitInstruction",
    value: function splitInstruction(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        splitStakePubkey = params.splitStakePubkey,
        lamports = params.lamports;
      var type = STAKE_INSTRUCTION_LAYOUTS.Split;
      var data = encodeData(type, {
        lamports: lamports
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: splitStakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that splits Stake tokens into another stake account
     */
  }, {
    key: "split",
    value: function split(params) {
      var transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.authorizedPubkey,
        newAccountPubkey: params.splitStakePubkey,
        lamports: 0,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.splitInstruction(params));
    }

    /**
     * Generate a Transaction that splits Stake tokens into another account
     * derived from a base public key and seed
     */
  }, {
    key: "splitWithSeed",
    value: function splitWithSeed(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        splitStakePubkey = params.splitStakePubkey,
        basePubkey = params.basePubkey,
        seed = params.seed,
        lamports = params.lamports;
      var transaction = new Transaction();
      transaction.add(SystemProgram.allocate({
        accountPubkey: splitStakePubkey,
        basePubkey: basePubkey,
        seed: seed,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.splitInstruction({
        stakePubkey: stakePubkey,
        authorizedPubkey: authorizedPubkey,
        splitStakePubkey: splitStakePubkey,
        lamports: lamports
      }));
    }

    /**
     * Generate a Transaction that merges Stake accounts.
     */
  }, {
    key: "merge",
    value: function merge(params) {
      var stakePubkey = params.stakePubkey,
        sourceStakePubKey = params.sourceStakePubKey,
        authorizedPubkey = params.authorizedPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Merge;
      var data = encodeData(type);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: sourceStakePubKey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that withdraws deactivated Stake tokens.
     */
  }, {
    key: "withdraw",
    value: function withdraw(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        toPubkey = params.toPubkey,
        lamports = params.lamports,
        custodianPubkey = params.custodianPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
      var data = encodeData(type, {
        lamports: lamports
      });
      var keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: false,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that deactivates Stake tokens.
     */
  }, {
    key: "deactivate",
    value: function deactivate(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
      var data = encodeData(type);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
  }]);
  return StakeProgram;
}();
StakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');
/**
 * Max space of a Stake account
 *
 * This is generated from the solana-stake-program StakeState struct as
 * `StakeState::size_of()`:
 * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeState.html
 */
StakeProgram.space = 200;

/**
 * Vote account info
 */
var VoteInit = /*#__PURE__*/_createClass( /** [0, 100] */

function VoteInit(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
  _classCallCheck(this, VoteInit);
  this.nodePubkey = void 0;
  this.authorizedVoter = void 0;
  this.authorizedWithdrawer = void 0;
  this.commission = void 0;
  this.nodePubkey = nodePubkey;
  this.authorizedVoter = authorizedVoter;
  this.authorizedWithdrawer = authorizedWithdrawer;
  this.commission = commission;
});

/**
 * Create vote account transaction params
 */

/**
 * InitializeAccount instruction params
 */

/**
 * Authorize instruction params
 */

/**
 * AuthorizeWithSeed instruction params
 */

/**
 * Withdraw from vote account transaction params
 */

/**
 * Vote Instruction class
 */
var VoteInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function VoteInstruction() {
    _classCallCheck(this, VoteInstruction);
  }

  /**
   * Decode a vote instruction and retrieve the instruction type.
   */
  _createClass(VoteInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = BufferLayout.u32('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(VOTE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a VoteInstruction');
      }
      return type;
    }

    /**
     * Decode an initialize vote instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeInitializeAccount",
    value: function decodeInitializeAccount(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 4);
      var _decodeData = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data),
        voteInit = _decodeData.voteInit;
      return {
        votePubkey: instruction.keys[0].pubkey,
        nodePubkey: instruction.keys[3].pubkey,
        voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)
      };
    }

    /**
     * Decode an authorize instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAuthorize",
    value: function decodeAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData2 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),
        newAuthorized = _decodeData2.newAuthorized,
        voteAuthorizationType = _decodeData2.voteAuthorizationType;
      return {
        votePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        voteAuthorizationType: {
          index: voteAuthorizationType
        }
      };
    }

    /**
     * Decode an authorize instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAuthorizeWithSeed",
    value: function decodeAuthorizeWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData3 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),
        _decodeData3$voteAuth = _decodeData3.voteAuthorizeWithSeedArgs,
        currentAuthorityDerivedKeyOwnerPubkey = _decodeData3$voteAuth.currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed = _decodeData3$voteAuth.currentAuthorityDerivedKeySeed,
        newAuthorized = _decodeData3$voteAuth.newAuthorized,
        voteAuthorizationType = _decodeData3$voteAuth.voteAuthorizationType;
      return {
        currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
        currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        voteAuthorizationType: {
          index: voteAuthorizationType
        },
        votePubkey: instruction.keys[0].pubkey
      };
    }

    /**
     * Decode a withdraw instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeWithdraw",
    value: function decodeWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData4 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),
        lamports = _decodeData4.lamports;
      return {
        votePubkey: instruction.keys[0].pubkey,
        authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
        lamports: lamports,
        toPubkey: instruction.keys[1].pubkey
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(VoteProgram.programId)) {
        throw new Error('invalid instruction; programId is not VoteProgram');
      }
    }

    /**
     * @internal
     */
  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return VoteInstruction;
}();

/**
 * An enumeration of valid VoteInstructionType's
 */

/** @internal */

var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('newAuthorized'), BufferLayout.u32('voteAuthorizationType')])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), voteAuthorizeWithSeedArgs()])
  }
});

/**
 * VoteAuthorize type
 */

/**
 * An enumeration of valid VoteAuthorization layouts.
 */
var VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

/**
 * Factory class for transactions to interact with the Vote program
 */
var VoteProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function VoteProgram() {
    _classCallCheck(this, VoteProgram);
  }

  /**
   * Public key that identifies the Vote program
   */
  _createClass(VoteProgram, null, [{
    key: "initializeAccount",
    value:
    /**
     * Generate an Initialize instruction.
     */
    function initializeAccount(params) {
      var votePubkey = params.votePubkey,
        nodePubkey = params.nodePubkey,
        voteInit = params.voteInit;
      var type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
      var data = encodeData(type, {
        voteInit: {
          nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),
          authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),
          authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),
          commission: voteInit.commission
        }
      });
      var instructionData = {
        keys: [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: nodePubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate a transaction that creates a new Vote account.
     */
  }, {
    key: "createAccount",
    value: function createAccount(params) {
      var transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.votePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.initializeAccount({
        votePubkey: params.votePubkey,
        nodePubkey: params.voteInit.nodePubkey,
        voteInit: params.voteInit
      }));
    }

    /**
     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
     */
  }, {
    key: "authorize",
    value: function authorize(params) {
      var votePubkey = params.votePubkey,
        authorizedPubkey = params.authorizedPubkey,
        newAuthorizedPubkey = params.newAuthorizedPubkey,
        voteAuthorizationType = params.voteAuthorizationType;
      var type = VOTE_INSTRUCTION_LAYOUTS.Authorize;
      var data = encodeData(type, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      });
      var keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
     * where the current Voter or Withdrawer authority is a derived key.
     */
  }, {
    key: "authorizeWithSeed",
    value: function authorizeWithSeed(params) {
      var currentAuthorityDerivedKeyBasePubkey = params.currentAuthorityDerivedKeyBasePubkey,
        currentAuthorityDerivedKeyOwnerPubkey = params.currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed = params.currentAuthorityDerivedKeySeed,
        newAuthorizedPubkey = params.newAuthorizedPubkey,
        voteAuthorizationType = params.voteAuthorizationType,
        votePubkey = params.votePubkey;
      var type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
      var data = encodeData(type, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
          currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          voteAuthorizationType: voteAuthorizationType.index
        }
      });
      var keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: currentAuthorityDerivedKeyBasePubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction to withdraw from a Vote account.
     */
  }, {
    key: "withdraw",
    value: function withdraw(params) {
      var votePubkey = params.votePubkey,
        authorizedWithdrawerPubkey = params.authorizedWithdrawerPubkey,
        lamports = params.lamports,
        toPubkey = params.toPubkey;
      var type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
      var data = encodeData(type, {
        lamports: lamports
      });
      var keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedWithdrawerPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction to withdraw safely from a Vote account.
     *
     * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
     * checks that the withdraw amount will not exceed the specified balance while leaving enough left
     * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
     * `withdraw` method directly.
     */
  }, {
    key: "safeWithdraw",
    value: function safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
      if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
        throw new Error('Withdraw will leave vote account with insuffcient funds.');
      }
      return VoteProgram.withdraw(params);
    }
  }]);
  return VoteProgram;
}();
VoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');
/**
 * Max space of a Vote account
 *
 * This is generated from the solana-vote-program VoteState struct as
 * `VoteState::size_of()`:
 * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of
 *
 * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342
 */
VoteProgram.space = 3731;

var VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');

/**
 * @internal
 */

/**
 * Info used to identity validators.
 */

var InfoString = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  keybaseUsername: optional(string())
});

/**
 * ValidatorInfo class
 */
var ValidatorInfo = /*#__PURE__*/function () {
  /**
   * Construct a valid ValidatorInfo
   *
   * @param key validator public key
   * @param info validator information
   */
  function ValidatorInfo(key, info) {
    _classCallCheck(this, ValidatorInfo);
    /**
     * validator public key
     */
    this.key = void 0;
    /**
     * validator information
     */
    this.info = void 0;
    this.key = key;
    this.info = info;
  }

  /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   *
   * @param buffer config account data
   * @return null if info was not found
   */
  _createClass(ValidatorInfo, null, [{
    key: "fromConfigData",
    value: function fromConfigData(buffer) {
      var byteArray = _toConsumableArray(buffer);
      var configKeyCount = decodeLength(byteArray);
      if (configKeyCount !== 2) return null;
      var configKeys = [];
      for (var i = 0; i < 2; i++) {
        var publicKey = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));
        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
        var isSigner = byteArray.slice(0, 1)[0] === 1;
        byteArray = byteArray.slice(1);
        configKeys.push({
          publicKey: publicKey,
          isSigner: isSigner
        });
      }
      if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
        if (configKeys[1].isSigner) {
          var rawInfo = rustString().decode(Buffer.from(byteArray));
          var info = JSON.parse(rawInfo);
          assert$1(info, InfoString);
          return new ValidatorInfo(configKeys[1].publicKey, info);
        }
      }
      return null;
    }
  }]);
  return ValidatorInfo;
}();

var VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');

/**
 * History of how many credits earned by the end of each epoch
 */

/**
 * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
 *
 * @internal
 */
var VoteAccountLayout = BufferLayout.struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), BufferLayout.u8('commission'), BufferLayout.nu64(),
// votes.length
BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64('slot'), BufferLayout.u32('confirmationCount')]), BufferLayout.offset(BufferLayout.u32(), -8), 'votes'), BufferLayout.u8('rootSlotValid'), BufferLayout.nu64('rootSlot'), BufferLayout.nu64(),
// authorizedVoters.length
BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64('epoch'), publicKey('authorizedVoter')]), BufferLayout.offset(BufferLayout.u32(), -8), 'authorizedVoters'), BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey('authorizedPubkey'), BufferLayout.nu64('epochOfLastAuthorizedSwitch'), BufferLayout.nu64('targetEpoch')]), 32, 'buf'), BufferLayout.nu64('idx'), BufferLayout.u8('isEmpty')], 'priorVoters'), BufferLayout.nu64(),
// epochCredits.length
BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64('epoch'), BufferLayout.nu64('credits'), BufferLayout.nu64('prevCredits')]), BufferLayout.offset(BufferLayout.u32(), -8), 'epochCredits'), BufferLayout.struct([BufferLayout.nu64('slot'), BufferLayout.nu64('timestamp')], 'lastTimestamp')]);
/**
 * VoteAccount class
 */
var VoteAccount = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function VoteAccount(args) {
    _classCallCheck(this, VoteAccount);
    this.nodePubkey = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.rootSlot = void 0;
    this.votes = void 0;
    this.authorizedVoters = void 0;
    this.priorVoters = void 0;
    this.epochCredits = void 0;
    this.lastTimestamp = void 0;
    this.nodePubkey = args.nodePubkey;
    this.authorizedWithdrawer = args.authorizedWithdrawer;
    this.commission = args.commission;
    this.rootSlot = args.rootSlot;
    this.votes = args.votes;
    this.authorizedVoters = args.authorizedVoters;
    this.priorVoters = args.priorVoters;
    this.epochCredits = args.epochCredits;
    this.lastTimestamp = args.lastTimestamp;
  }

  /**
   * Deserialize VoteAccount from the account data.
   *
   * @param buffer account data
   * @return VoteAccount
   */
  _createClass(VoteAccount, null, [{
    key: "fromAccountData",
    value: function fromAccountData(buffer) {
      var versionOffset = 4;
      var va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
      var rootSlot = va.rootSlot;
      if (!va.rootSlotValid) {
        rootSlot = null;
      }
      return new VoteAccount({
        nodePubkey: new PublicKey(va.nodePubkey),
        authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
        commission: va.commission,
        votes: va.votes,
        rootSlot: rootSlot,
        authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
        priorVoters: getPriorVoters(va.priorVoters),
        epochCredits: va.epochCredits,
        lastTimestamp: va.lastTimestamp
      });
    }
  }]);
  return VoteAccount;
}();
function parseAuthorizedVoter(_ref) {
  var authorizedVoter = _ref.authorizedVoter,
    epoch = _ref.epoch;
  return {
    epoch: epoch,
    authorizedVoter: new PublicKey(authorizedVoter)
  };
}
function parsePriorVoters(_ref2) {
  var authorizedPubkey = _ref2.authorizedPubkey,
    epochOfLastAuthorizedSwitch = _ref2.epochOfLastAuthorizedSwitch,
    targetEpoch = _ref2.targetEpoch;
  return {
    authorizedPubkey: new PublicKey(authorizedPubkey),
    epochOfLastAuthorizedSwitch: epochOfLastAuthorizedSwitch,
    targetEpoch: targetEpoch
  };
}
function getPriorVoters(_ref3) {
  var buf = _ref3.buf,
    idx = _ref3.idx,
    isEmpty = _ref3.isEmpty;
  if (isEmpty) {
    return [];
  }
  return [].concat(_toConsumableArray(buf.slice(idx + 1).map(parsePriorVoters)), _toConsumableArray(buf.slice(0, idx).map(parsePriorVoters)));
}

var endpoint = {
  http: {
    devnet: 'http://api.devnet.solana.com',
    testnet: 'http://api.testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'
  },
  https: {
    devnet: 'https://api.devnet.solana.com',
    testnet: 'https://api.testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'
  }
};
/**
 * Retrieves the RPC API URL for the specified cluster
 * @param {Cluster} [cluster="devnet"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'
 * @param {boolean} [tls="http"] - Use TLS when connecting to cluster.
 *
 * @returns {string} URL string of the RPC endpoint
 */
function clusterApiUrl(cluster, tls) {
  var key = tls === false ? 'http' : 'https';
  if (!cluster) {
    return endpoint[key]['devnet'];
  }
  var url = endpoint[key][cluster];
  if (!url) {
    throw new Error("Unknown ".concat(key, " cluster: ").concat(cluster));
  }
  return url;
}

/**
 * Send and confirm a raw transaction
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Buffer} rawTransaction
 * @param {TransactionConfirmationStrategy} confirmationStrategy
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */

/**
 * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`
 * is no longer supported and will be removed in a future version.
 */ // eslint-disable-next-line no-redeclare
// eslint-disable-next-line no-redeclare
function sendAndConfirmRawTransaction(_x, _x2, _x3, _x4) {
  return _sendAndConfirmRawTransaction.apply(this, arguments);
}
function _sendAndConfirmRawTransaction() {
  _sendAndConfirmRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
    var confirmationStrategy, options, sendOptions, signature, commitment, confirmationPromise, status;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {
            confirmationStrategy = confirmationStrategyOrConfirmOptions;
            options = maybeConfirmOptions;
          } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {
            confirmationStrategy = confirmationStrategyOrConfirmOptions;
            options = maybeConfirmOptions;
          } else {
            options = confirmationStrategyOrConfirmOptions;
          }
          sendOptions = options && {
            skipPreflight: options.skipPreflight,
            preflightCommitment: options.preflightCommitment || options.commitment,
            minContextSlot: options.minContextSlot
          };
          _context.next = 4;
          return connection.sendRawTransaction(rawTransaction, sendOptions);
        case 4:
          signature = _context.sent;
          commitment = options && options.commitment;
          confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);
          _context.next = 9;
          return confirmationPromise;
        case 9:
          status = _context.sent.value;
          if (!status.err) {
            _context.next = 12;
            break;
          }
          throw new Error("Raw transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));
        case 12:
          return _context.abrupt("return", signature);
        case 13:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _sendAndConfirmRawTransaction.apply(this, arguments);
}

/**
 * There are 1-billion lamports in one SOL
 */
var LAMPORTS_PER_SOL = 1000000000;

export { Account, AddressLookupTableAccount, AddressLookupTableInstruction, AddressLookupTableProgram, Authorized, BLOCKHASH_CACHE_TIMEOUT_MS, BPF_LOADER_DEPRECATED_PROGRAM_ID, BPF_LOADER_PROGRAM_ID, BpfLoader, COMPUTE_BUDGET_INSTRUCTION_LAYOUTS, ComputeBudgetInstruction, ComputeBudgetProgram, Connection, Ed25519Program, Enum, EpochSchedule, FeeCalculatorLayout, Keypair, LAMPORTS_PER_SOL, LOOKUP_TABLE_INSTRUCTION_LAYOUTS, Loader, Lockup, MAX_SEED_LENGTH, Message, MessageAccountKeys, MessageV0, NONCE_ACCOUNT_LENGTH, NonceAccount, PACKET_DATA_SIZE, PUBLIC_KEY_LENGTH, PublicKey, SIGNATURE_LENGTH_IN_BYTES, SOLANA_SCHEMA, STAKE_CONFIG_ID, STAKE_INSTRUCTION_LAYOUTS, SYSTEM_INSTRUCTION_LAYOUTS, SYSVAR_CLOCK_PUBKEY, SYSVAR_EPOCH_SCHEDULE_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_RECENT_BLOCKHASHES_PUBKEY, SYSVAR_RENT_PUBKEY, SYSVAR_REWARDS_PUBKEY, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_SLOT_HISTORY_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY, Secp256k1Program, SendTransactionError, SolanaJSONRPCError, SolanaJSONRPCErrorCode, StakeAuthorizationLayout, StakeInstruction, StakeProgram, Struct, SystemInstruction, SystemProgram, Transaction, TransactionExpiredBlockheightExceededError, TransactionExpiredNonceInvalidError, TransactionExpiredTimeoutError, TransactionInstruction, TransactionMessage, TransactionStatus, VALIDATOR_INFO_KEY, VERSION_PREFIX_MASK, VOTE_PROGRAM_ID, ValidatorInfo, VersionedMessage, VersionedTransaction, VoteAccount, VoteAuthorizationLayout, VoteInit, VoteInstruction, VoteProgram, clusterApiUrl, sendAndConfirmRawTransaction, sendAndConfirmTransaction };
//# sourceMappingURL=index.esm.js.map
