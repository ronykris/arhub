"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateContractImpl = void 0;
/* eslint-disable */
const SourceImpl_1 = require("./SourceImpl");
const warp_contracts_1 = require("warp-contracts");
const warp_arbundles_1 = require("warp-arbundles");
const utils_1 = require("../../deploy/utils");
class CreateContractImpl {
    constructor(warp) {
        this.warp = warp;
        this.logger = warp_contracts_1.LoggerFactory.INST.create('DefaultCreateContract');
        this.deployFromSourceTx = this.deployFromSourceTx.bind(this);
        this.source = new SourceImpl_1.SourceImpl(this.warp);
        this.warpFetchWrapper = new warp_contracts_1.WarpFetchWrapper(this.warp);
    }
    async deploy(contractData, disableBundling) {
        const { wallet, initState, tags, transfer, data, evaluationManifest } = contractData;
        let srcTx;
        const effectiveUseBundler = disableBundling == undefined ? this.warp.definitionLoader.type() == 'warp' : !disableBundling;
        srcTx = await this.source.createSource(contractData, wallet, !effectiveUseBundler);
        if (!effectiveUseBundler) {
            await this.source.saveSource(srcTx, true);
        }
        this.logger.debug('Creating new contract');
        const srcTxId = await srcTx.id;
        return await this.deployFromSourceTx({
            srcTxId,
            wallet,
            initState,
            tags,
            transfer,
            data,
            evaluationManifest
        }, !effectiveUseBundler, srcTx);
    }
    async deployFromSourceTx(contractData, disableBundling, srcTx = null) {
        this.logger.debug('Creating new contract from src tx');
        const { wallet, srcTxId, initState, data } = contractData;
        let contract;
        let responseOk;
        let response;
        const effectiveUseBundler = disableBundling == undefined ? this.warp.definitionLoader.type() == 'warp' : !disableBundling;
        if (!effectiveUseBundler && (0, utils_1.isSigner)(wallet)) {
            throw new Error('Only ArWallet | CustomSignature wallet type are allowed when bundling is disabled.');
        }
        if (effectiveUseBundler && !(0, utils_1.isSigner)(wallet)) {
            throw new Error('Only Signer wallet type is allowed when bundling is enabled.');
        }
        const contractTags = {
            contract: [
                { name: warp_contracts_1.SMART_WEAVE_TAGS.APP_NAME, value: 'SmartWeaveContract' },
                { name: warp_contracts_1.SMART_WEAVE_TAGS.APP_VERSION, value: '0.3.0' },
                { name: warp_contracts_1.SMART_WEAVE_TAGS.CONTRACT_SRC_TX_ID, value: srcTxId },
                { name: warp_contracts_1.SMART_WEAVE_TAGS.SDK, value: 'Warp' },
                { name: warp_contracts_1.WARP_TAGS.NONCE, value: Date.now().toString() }
            ],
            contractData: [
                { name: warp_contracts_1.SMART_WEAVE_TAGS.CONTENT_TYPE, value: data && data['Content-Type'] },
                { name: warp_contracts_1.WARP_TAGS.INIT_STATE, value: initState }
            ],
            contractNonData: [{ name: warp_contracts_1.SMART_WEAVE_TAGS.CONTENT_TYPE, value: 'application/json' }],
            contractTestnet: [{ name: warp_contracts_1.WARP_TAGS.WARP_TESTNET, value: '1.0.0' }],
            contractEvaluationManifest: [{ name: warp_contracts_1.WARP_TAGS.MANIFEST, value: JSON.stringify(contractData.evaluationManifest) }]
        };
        if (!effectiveUseBundler) {
            ({ contract, responseOk } = await this.deployContractArweave(effectiveUseBundler, contractData, contractTags));
        }
        else {
            ({ contract, responseOk } = await this.deployContractBundlr(contractData, contractTags, srcTx));
        }
        const contractTxId = await contract.id;
        if (responseOk) {
            return { contractTxId, srcTxId };
        }
        else {
            throw new Error(`Unable to write Contract. Arweave responded with status ${response.status}: ${response.statusText}`);
        }
    }
    async deployBundled(rawDataItem) {
        return await (0, warp_contracts_1.getJsonResponse)(fetch(`${this.warp.gwUrl()}/gateway/contracts/deploy-bundled`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/octet-stream',
                Accept: 'application/json'
            },
            body: rawDataItem
        }));
    }
    async register(id, bundlrNode) {
        return await (0, warp_contracts_1.getJsonResponse)(fetch(`${this.warp.gwUrl()}/gateway/contracts/register`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json'
            },
            body: JSON.stringify({ id, bundlrNode })
        }));
    }
    async createSource(sourceData, wallet, disableBundling = false) {
        return this.source.createSource(sourceData, wallet, disableBundling);
    }
    async saveSource(srcTx, disableBundling) {
        return this.source.saveSource(srcTx, disableBundling);
    }
    async postContract(contract, src = null) {
        let body = {
            contract
        };
        if (src) {
            body = {
                ...body,
                src
            };
        }
        return await (0, warp_contracts_1.getJsonResponse)(this.warpFetchWrapper.fetch(`${this.warp.gwUrl()}/gateway/v2/contracts/deploy`, {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'Accept-Encoding': 'gzip, deflate, br',
                'Content-Type': 'application/json',
                Accept: 'application/json'
            }
        }));
    }
    async deployContractArweave(effectiveUseBundler, contractData, contractTags) {
        const { wallet, initState, transfer, data, tags } = contractData;
        this.signature = new warp_contracts_1.Signature(this.warp, wallet);
        !(0, utils_1.isSigner)(wallet) && this.signature.checkNonArweaveSigningAvailability(effectiveUseBundler);
        const signer = this.signature.signer;
        !(0, utils_1.isSigner)(wallet) && this.signature.checkNonArweaveSigningAvailability(effectiveUseBundler);
        let contract = await this.warp.arweave.createTransaction({ data: (data === null || data === void 0 ? void 0 : data.body) || initState });
        if (+(transfer === null || transfer === void 0 ? void 0 : transfer.winstonQty) > 0 && transfer.target.length) {
            this.logger.debug('Creating additional transaction with AR transfer', transfer);
            contract = await this.warp.arweave.createTransaction({
                data: (data === null || data === void 0 ? void 0 : data.body) || initState,
                target: transfer.target,
                quantity: transfer.winstonQty
            });
        }
        if (tags === null || tags === void 0 ? void 0 : tags.length) {
            for (const tag of tags) {
                contract.addTag(tag.name.toString(), tag.value.toString());
            }
        }
        contractTags.contract.forEach((t) => contract.addTag(t.name, t.value));
        if (data) {
            contractTags.contractData.forEach((t) => contract.addTag(t.name, t.value));
        }
        else {
            contractTags.contractNonData.forEach((t) => contract.addTag(t.name, t.value));
        }
        if (this.warp.environment === 'testnet') {
            contractTags.contractTestnet.forEach((t) => contract.addTag(t.name, t.value));
        }
        if (contractData.evaluationManifest) {
            contractTags.contractEvaluationManifest.forEach((t) => contract.addTag(t.name, t.value));
        }
        await signer(contract);
        const response = await this.warp.arweave.transactions.post(contract);
        return { contract, responseOk: response.status === 200 || response.status === 208 };
    }
    async deployContractBundlr(contractData, contractTags, src = null) {
        const { wallet, initState, data, tags } = contractData;
        const contractDataItemTags = [...contractTags.contract];
        if (tags === null || tags === void 0 ? void 0 : tags.length) {
            for (const tag of tags) {
                contractDataItemTags.push(new warp_contracts_1.Tag(tag.name.toString(), tag.value.toString()));
            }
        }
        if (data) {
            contractTags.contractData.forEach((t) => contractDataItemTags.push(new warp_contracts_1.Tag(t.name, t.value)));
        }
        else {
            contractTags.contractNonData.forEach((t) => contractDataItemTags.push(new warp_contracts_1.Tag(t.name, t.value)));
        }
        if (this.warp.environment === 'testnet') {
            contractTags.contractTestnet.forEach((t) => contractDataItemTags.push(new warp_contracts_1.Tag(t.name, t.value)));
        }
        if (contractData.evaluationManifest) {
            contractTags.contractEvaluationManifest.forEach((t) => contractDataItemTags.push(new warp_contracts_1.Tag(t.name, t.value)));
        }
        let contract;
        if ((0, warp_contracts_1.isBrowser)() && wallet.signer && wallet.signer.signDataItem) {
            contract = await wallet.signDataItem((data === null || data === void 0 ? void 0 : data.body) || initState, contractDataItemTags);
        }
        else {
            contract = (0, warp_arbundles_1.createData)((data === null || data === void 0 ? void 0 : data.body) || initState, wallet, { tags: contractDataItemTags });
            await contract.sign(wallet);
        }
        await this.postContract(contract.getRaw(), src === null || src === void 0 ? void 0 : src.getRaw());
        return { contract, responseOk: true };
    }
    isBundlrNodeType(value) {
        return warp_contracts_1.BUNDLR_NODES.includes(value);
    }
}
exports.CreateContractImpl = CreateContractImpl;
//# sourceMappingURL=CreateContractImpl.js.map