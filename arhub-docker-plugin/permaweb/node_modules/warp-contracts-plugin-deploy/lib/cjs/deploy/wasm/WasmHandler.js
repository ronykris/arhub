"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WasmHandler = void 0;
/* eslint-disable */
const warp_wasm_metering_1 = __importDefault(require("warp-wasm-metering"));
const fs_1 = __importDefault(require("fs"));
const warp_contracts_1 = require("warp-contracts");
const wasmTypeMapping = new Map([
    // [1, 'assemblyscript'],
    [2, 'rust']
    /*[3, 'go']
    [4, 'swift'],
      [5, 'c']*/
]);
class WasmHandler {
    constructor(src, wasmSrcCodeDir, wasmGlueCode) {
        this.src = src;
        this.wasmSrcCodeDir = wasmSrcCodeDir;
        this.wasmGlueCode = wasmGlueCode;
    }
    async createWasmSrc() {
        const data = [];
        let wasmVersion;
        const metadata = {};
        const meteredWasmBinary = warp_wasm_metering_1.default.meterWASM(this.src, {
            meterType: 'i32'
        });
        data.push(this.src);
        const wasmModule = await WebAssembly.compile(this.src);
        const moduleImports = WebAssembly.Module.imports(wasmModule);
        let lang;
        // @ts-ignore
        const module = await WebAssembly.instantiate(this.src, dummyImports(moduleImports));
        // @ts-ignore
        if (!module.instance.exports.lang) {
            throw new Error(`No info about source type in wasm binary. Did you forget to export "lang" function?`);
        }
        // @ts-ignore
        lang = module.instance.exports.lang();
        // @ts-ignore
        wasmVersion = module.instance.exports.version();
        if (!wasmTypeMapping.has(lang)) {
            throw new Error(`Unknown wasm source type ${lang}`);
        }
        const wasmLang = wasmTypeMapping.get(lang);
        if (this.wasmSrcCodeDir == null) {
            throw new Error('No path to original wasm contract source code');
        }
        const zippedSourceCode = await this.zipContents(this.wasmSrcCodeDir);
        data.push(zippedSourceCode);
        if (wasmLang == 'rust') {
            if (!this.wasmGlueCode) {
                throw new Error('No path to generated wasm-bindgen js code');
            }
            const wasmBindgenSrc = fs_1.default.readFileSync(this.wasmGlueCode, 'utf-8');
            const dtor = (0, warp_contracts_1.matchMutClosureDtor)(wasmBindgenSrc);
            metadata['dtor'] = parseInt(dtor);
            data.push(Buffer.from(wasmBindgenSrc));
        }
        const wasmData = this.joinBuffers(data);
        const srcWasmTags = [
            { name: warp_contracts_1.WARP_TAGS.WASM_LANG, value: wasmLang },
            { name: warp_contracts_1.WARP_TAGS.WASM_LANG_VERSION, value: wasmVersion.toString() },
            { name: warp_contracts_1.WARP_TAGS.WASM_META, value: JSON.stringify(metadata) }
        ];
        return { wasmData, srcWasmTags };
    }
    joinBuffers(buffers) {
        const length = buffers.length;
        const result = [];
        result.push(Buffer.from(length.toString()));
        result.push(Buffer.from('|'));
        buffers.forEach((b) => {
            result.push(Buffer.from(b.length.toString()));
            result.push(Buffer.from('|'));
        });
        result.push(...buffers);
        return result.reduce((prev, b) => Buffer.concat([prev, b]));
    }
    async zipContents(source) {
        const archiver = require('archiver'), streamBuffers = require('stream-buffers');
        const outputStreamBuffer = new streamBuffers.WritableStreamBuffer({
            initialSize: 1000 * 1024,
            incrementAmount: 1000 * 1024 // grow by 1000 kilobytes each time buffer overflows.
        });
        const archive = archiver('zip', {
            zlib: { level: 9 } // Sets the compression level.
        });
        archive.on('error', function (err) {
            throw err;
        });
        archive.pipe(outputStreamBuffer);
        archive.directory(source.toString(), source.toString());
        await archive.finalize();
        outputStreamBuffer.end();
        return outputStreamBuffer.getContents();
    }
}
exports.WasmHandler = WasmHandler;
function dummyImports(moduleImports) {
    const imports = {};
    moduleImports.forEach((moduleImport) => {
        if (!Object.prototype.hasOwnProperty.call(imports, moduleImport.module)) {
            imports[moduleImport.module] = {};
        }
        imports[moduleImport.module][moduleImport.name] = function () { };
    });
    return imports;
}
//# sourceMappingURL=WasmHandler.js.map