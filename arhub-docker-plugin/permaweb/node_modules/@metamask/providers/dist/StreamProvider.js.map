{"version":3,"file":"StreamProvider.js","sourceRoot":"","sources":["../src/StreamProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import ObjectMultiplex from '@metamask/object-multiplex';\nimport SafeEventEmitter from '@metamask/safe-event-emitter';\nimport { duplex as isDuplex } from 'is-stream';\nimport type { JsonRpcMiddleware } from 'json-rpc-engine';\nimport { createStreamMiddleware } from 'json-rpc-middleware-stream';\nimport pump from 'pump';\nimport type { Duplex } from 'stream';\n\nimport { BaseProvider, BaseProviderOptions } from './BaseProvider';\nimport messages from './messages';\nimport {\n  EMITTED_NOTIFICATIONS,\n  isValidChainId,\n  isValidNetworkVersion,\n} from './utils';\n\nexport type StreamProviderOptions = {\n  /**\n   * The name of the stream used to connect to the wallet.\n   */\n  jsonRpcStreamName: string;\n} & BaseProviderOptions;\n\nexport type JsonRpcConnection = {\n  events: SafeEventEmitter;\n  middleware: JsonRpcMiddleware<unknown, unknown>;\n  stream: Duplex;\n};\n\n/**\n * An abstract EIP-1193 provider wired to some duplex stream via a\n * `json-rpc-middleware-stream` JSON-RPC stream middleware. Implementers must\n * call {@link AbstractStreamProvider._initializeStateAsync} after instantiation\n * to initialize the provider's state.\n */\nexport abstract class AbstractStreamProvider extends BaseProvider {\n  protected _jsonRpcConnection: JsonRpcConnection;\n\n  /**\n   * Creates a new AbstractStreamProvider instance.\n   *\n   * @param connectionStream - A Node.js duplex stream.\n   * @param options - An options bag.\n   * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.\n   * @param options.logger - The logging API to use. Default: `console`.\n   * @param options.maxEventListeners - The maximum number of event\n   * listeners. Default: 100.\n   * @param options.rpcMiddleware - The RPC middleware stack to use.\n   */\n  constructor(\n    connectionStream: Duplex,\n    {\n      jsonRpcStreamName,\n      logger = console,\n      maxEventListeners = 100,\n      rpcMiddleware = [],\n    }: StreamProviderOptions,\n  ) {\n    super({ logger, maxEventListeners, rpcMiddleware });\n\n    if (!isDuplex(connectionStream)) {\n      throw new Error(messages.errors.invalidDuplexStream());\n    }\n\n    // Bind functions to prevent consumers from making unbound calls\n    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n\n    // Set up connectionStream multiplexing\n    const mux = new ObjectMultiplex();\n    pump(\n      connectionStream,\n      mux as unknown as Duplex,\n      connectionStream,\n      this._handleStreamDisconnect.bind(this, 'MetaMask'),\n    );\n\n    // Set up RPC connection\n    // Typecast: The type of `Duplex` is incompatible with the type of\n    // `JsonRpcConnection`.\n    this._jsonRpcConnection = createStreamMiddleware({\n      retryOnMessage: 'METAMASK_EXTENSION_CONNECT_CAN_RETRY',\n    }) as unknown as JsonRpcConnection;\n\n    pump(\n      this._jsonRpcConnection.stream,\n      mux.createStream(jsonRpcStreamName) as unknown as Duplex,\n      this._jsonRpcConnection.stream,\n      this._handleStreamDisconnect.bind(this, 'MetaMask RpcProvider'),\n    );\n\n    // Wire up the JsonRpcEngine to the JSON-RPC connection stream\n    this._rpcEngine.push(this._jsonRpcConnection.middleware);\n\n    // Handle JSON-RPC notifications\n    this._jsonRpcConnection.events.on('notification', (payload) => {\n      const { method, params } = payload;\n      if (method === 'metamask_accountsChanged') {\n        this._handleAccountsChanged(params);\n      } else if (method === 'metamask_unlockStateChanged') {\n        this._handleUnlockStateChanged(params);\n      } else if (method === 'metamask_chainChanged') {\n        this._handleChainChanged(params);\n      } else if (EMITTED_NOTIFICATIONS.includes(method)) {\n        this.emit('message', {\n          type: method,\n          data: params,\n        });\n      } else if (method === 'METAMASK_STREAM_FAILURE') {\n        connectionStream.destroy(\n          new Error(messages.errors.permanentlyDisconnected()),\n        );\n      }\n    });\n  }\n\n  //====================\n  // Private Methods\n  //====================\n\n  /**\n   * MUST be called by child classes.\n   *\n   * Calls `metamask_getProviderState` and passes the result to\n   * {@link BaseProvider._initializeState}. Logs an error if getting initial state\n   * fails. Throws if called after initialization has completed.\n   */\n  protected async _initializeStateAsync() {\n    let initialState: Parameters<BaseProvider['_initializeState']>[0];\n\n    try {\n      initialState = (await this.request({\n        method: 'metamask_getProviderState',\n      })) as Parameters<BaseProvider['_initializeState']>[0];\n    } catch (error) {\n      this._log.error(\n        'MetaMask: Failed to get initial state. Please report this bug.',\n        error,\n      );\n    }\n    this._initializeState(initialState);\n  }\n\n  /**\n   * Called when connection is lost to critical streams. Emits an 'error' event\n   * from the provider with the error message and stack if present.\n   *\n   * @param streamName - The name of the stream that disconnected.\n   * @param error - The error that caused the disconnection.\n   * @fires BaseProvider#disconnect - If the provider is not already\n   * disconnected.\n   */\n  // eslint-disable-next-line no-restricted-syntax\n  private _handleStreamDisconnect(streamName: string, error: Error) {\n    let warningMsg = `MetaMask: Lost connection to \"${streamName}\".`;\n    if (error?.stack) {\n      warningMsg += `\\n${error.stack}`;\n    }\n\n    this._log.warn(warningMsg);\n    if (this.listenerCount('error') > 0) {\n      this.emit('error', warningMsg);\n    }\n\n    this._handleDisconnect(false, error ? error.message : undefined);\n  }\n\n  /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state. This class does not have a\n   * `networkVersion` property, but we rely on receiving a `networkVersion`\n   * with the value of `loading` to detect when the network is changing and\n   * a recoverable `disconnect` even has occurred. Child classes that use the\n   * `networkVersion` for other purposes must implement additional handling\n   * therefore.\n   *\n   * @fires BaseProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   * @param networkInfo.chainId - The latest chain ID.\n   * @param networkInfo.networkVersion - The latest network ID.\n   */\n  protected _handleChainChanged({\n    chainId,\n    networkVersion,\n  }: {\n    chainId?: string | undefined;\n    networkVersion?: string | undefined;\n  } = {}) {\n    if (!isValidChainId(chainId) || !isValidNetworkVersion(networkVersion)) {\n      this._log.error(messages.errors.invalidNetworkParams(), {\n        chainId,\n        networkVersion,\n      });\n      return;\n    }\n\n    if (networkVersion === 'loading') {\n      this._handleDisconnect(true);\n    } else {\n      super._handleChainChanged({ chainId });\n    }\n  }\n}\n\n/**\n * An EIP-1193 provider wired to some duplex stream via a\n * `json-rpc-middleware-stream` JSON-RPC stream middleware. Consumers must\n * call {@link StreamProvider.initialize} after instantiation to complete\n * initialization.\n */\nexport class StreamProvider extends AbstractStreamProvider {\n  /**\n   * MUST be called after instantiation to complete initialization.\n   *\n   * Calls `metamask_getProviderState` and passes the result to\n   * {@link BaseProvider._initializeState}. Logs an error if getting initial state\n   * fails. Throws if called after initialization has completed.\n   */\n  async initialize() {\n    return this._initializeStateAsync();\n  }\n}\n"]}