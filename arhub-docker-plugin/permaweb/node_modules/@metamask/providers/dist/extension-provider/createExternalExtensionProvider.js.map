{"version":3,"file":"createExternalExtensionProvider.js","sourceRoot":"","sources":["../../src/extension-provider/createExternalExtensionProvider.ts"],"names":[],"mappings":";;;;;;AAAA,mDAAwC;AACxC,kFAA+C;AAI/C,sGAAsD;AACtD,sEAA6E;AAC7E,sDAAmD;AACnD,oCAAwD;AAExD,MAAM,OAAO,GAAG,IAAA,uBAAM,GAAE,CAAC;AAIzB;;;;;GAKG;AACH,SAAgB,+BAA+B,CAC7C,WAA0B,QAAQ;IAElC,IAAI,QAAQ,CAAC;IAEb,IAAI;QACF,MAAM,WAAW,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;QAC7C,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAiB,CAAC;QAEzE,MAAM,YAAY,GAAG,IAAI,+BAAU,CAAC,YAAY,CAAC,CAAC;QAClD,QAAQ,GAAG,IAAI,+BAAc,CAAC,YAAiC,EAAE;YAC/D,iBAAiB,EAAE,yDAAgC;YACnD,MAAM,EAAE,OAAO;YACf,aAAa,EAAE,IAAA,oCAA4B,EAAC,OAAO,CAAC;SACrD,CAAC,CAAC;QAEH,wEAAwE;QACxE,iEAAiE;QACjE,eAAe;QACf,mEAAmE;QACnE,QAAQ,CAAC,UAAU,EAAE,CAAC;KACvB;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,CAAC,GAAG,CAAC,yBAAyB,EAAE,KAAK,CAAC,CAAC;QAC9C,MAAM,KAAK,CAAC;KACb;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AA1BD,0EA0BC;AAED;;;;;GAKG;AACH,SAAS,cAAc,CAAC,QAAuB;IAC7C,MAAM,GAAG,GACP,OAAO,EAAE,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,wCAAM,CAAC,UAAU,CAAC,CAAC,CAAC,wCAAM,CAAC,SAAS,CAAC;IACrE,OAAO,GAAG,CAAC,QAA4B,CAAC,IAAI,QAAQ,CAAC;AACvD,CAAC","sourcesContent":["import { detect } from 'detect-browser';\nimport PortStream from 'extension-port-stream';\nimport { Duplex } from 'stream';\nimport type { Runtime } from 'webextension-polyfill';\n\nimport config from './external-extension-config.json';\nimport { MetaMaskInpageProviderStreamName } from '../MetaMaskInpageProvider';\nimport { StreamProvider } from '../StreamProvider';\nimport { getDefaultExternalMiddleware } from '../utils';\n\nconst browser = detect();\n\nexport type ExtensionType = 'stable' | 'flask' | 'beta' | string;\n\n/**\n * Creates an external extension provider for the given extension type or ID.\n *\n * @param typeOrId - The extension type or ID.\n * @returns The external extension provider.\n */\nexport function createExternalExtensionProvider(\n  typeOrId: ExtensionType = 'stable',\n) {\n  let provider;\n\n  try {\n    const extensionId = getExtensionId(typeOrId);\n    const metamaskPort = chrome.runtime.connect(extensionId) as Runtime.Port;\n\n    const pluginStream = new PortStream(metamaskPort);\n    provider = new StreamProvider(pluginStream as unknown as Duplex, {\n      jsonRpcStreamName: MetaMaskInpageProviderStreamName,\n      logger: console,\n      rpcMiddleware: getDefaultExternalMiddleware(console),\n    });\n\n    // This is asynchronous but merely logs an error and does not throw upon\n    // failure. Previously this just happened as a side-effect in the\n    // constructor.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    provider.initialize();\n  } catch (error) {\n    console.dir(`MetaMask connect error.`, error);\n    throw error;\n  }\n  return provider;\n}\n\n/**\n * Gets the extension ID for the given extension type or ID.\n *\n * @param typeOrId - The extension type or ID.\n * @returns The extension ID.\n */\nfunction getExtensionId(typeOrId: ExtensionType) {\n  const ids =\n    browser?.name === 'firefox' ? config.firefoxIds : config.chromeIds;\n  return ids[typeOrId as keyof typeof ids] ?? typeOrId;\n}\n"]}